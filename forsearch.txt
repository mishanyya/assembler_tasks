123456789
///////////////////////////////////////////////////////////////
'это неправильно
;void *start, size_t length, int prot , int flags, ioff_t offset

mov eax,90       ; системный вызов
mov ebx,invite1  ; Адрес *start
mov ecx,linvite1 ; size_t length
mov edx,1        ; чтение int prot? 1-можно читать, 2-в нее можно записать информацию
mov esi,1        ; flags? 0, 1 или 2

int 80h ; Вызов ядра

////////

;Написать программу со следующим алгоритмом:
;- получить из стека командную строку (содержащую имя файла и
;параметры, переданные программе при запуске);
;- первый параметр вывести на экран красным цветом, второй —
;синим и с новой строки.
;- выполнить побайтный «переворот» содержимого файла, имя которого задано первым параметром командной строки; информацию записывать в этот же файл без промежуточных и дополнительных файлов, с использованием отображения файла на память;
;- каждая файловая операция контролируются на ошибку без анализа ее номера с выдачей на терминал своего сообщения, типа
;«Ошибка открытия файла», «Ошибка записи» и т.д.
;- завершить программу


SECTION .data        ;для инициализированных данных

;27, обозначается как ^[  - код в ASCII для виртуальной кнопки Esc, работает как нажатие клавиш Ctrl+V и Esc!

invite db "Вывести в терминал In color с атрибутами настройки вывода текста 5;34;42",0xa,0
linvite equ $-invite

text db "echo",27,"[5;34;42mIn color",0xa,0
ltext equ $-text

invite1 db "forsearch.txt",0
linvite1 equ $-invite1

n db 0xa                   ;переменная для переноса строки

SECTION .bss         ;для НЕинициализированных данных

input: resb 100               ;что ищем
linput equ $-input

SECTION .text      ;начало кода самой программы
GLOBAL _start
      _start:

;вывести на экран приглашение. This thing  works!
;mov ecx,invite        ;ввод адреса
;mov edx,linvite       ;ввод количества символов
;mov eax,4
;mov ebx,1
;int 80h


;это работает! выводит текст из файла!
;- открыть файл, прочитать его в буфер
mov eax,5             ;open
mov ebx,invite1    ;имя/адрес файла
mov ecx,2             ;read and write mode
int 80h

;это работает! поместить данные из файла в память input
;mov ebx,3
;mov ecx,input
;mov edx,linput
;int 80h

 ;mov eax,function_number
 ;mov ebx,param_1  ; если есть
 ;mov ecx,param_2  ; если есть
 ;mov edx,param_3  ; если есть
 ;mov esi,param_4  ; если есть
 ;mov edi,param_5  ; если есть
 ;mov ebp,param_6  ; если есть
 ;int 0x80  ; вызов!



;void * mmap (void *address, size_t length, int protect, int flags, int filedes,off_t offset)
mov eax,90    ; № системного вызова
mov ebx,0     ;*address - указатель/адрес участка памяти процесса, в который отображается содержимое файла, обычно 0
mov ecx,13    ;length - длина отображаемого участка файла с начала или с символа offset (по умолчанию = 0)
mov edx,1     ;protect - защита файла, 0 - доступ запрещен, 1 - только для чтения,
;2 - только для записи, 4 - для исполнения кода
mov esi,1     ;flags - 1 или 2,4 передача изменений: да или нет
mov edi,1     ;filedes - дескриптор отображаемого файла, описатель файла
mov ebp,0     ;offset - от какого символа считать начало отображаемого текста
int 80h

;это работает! вывод текста, при этом кнопка Esc (27) срабатывает!
mov ecx,eax        ;ввод адреса
mov edx,13      ;ввод количества символов
mov eax,4
mov ebx,1
int 80h


;- завершить программу.

mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается



//////////
Для отключения отображения объекта в адресное пространство процесса используется вызов munmap:

int munmap(void *addr, size_t len);

/* Возвращает 0 в случае успешного завершения, –1 – в случае ошибки */

Аргумент addr должен содержать адрес, возвращенный mmap, a len — длину области
отображения.
После вызова munmap любые попытки обратиться к этой области
памяти приведут к отправке процессу сигнала SIGSEGV



//////////////
Файловый дескриптор — это неотрицательное число, которое является
 идентификатором потока ввода-вывода. Дескриптор может быть связан
  с файлом, каталогом, сокетом.

Например, когда вы открываете или создаете новый файл, операционная
система формирует для себя запись для представления этого файла и
хранения информации о нем. У каждого файла индивидуальный файловый
 дескриптор Linux. Открыли 100 файлов — где-то в ядре
 появились 100 записей, представленных целыми числами.

Как файлы получают дескрипторы
Обычно файловые дескрипторы выделяются последовательно. Есть
 пул свободных номеров. Когда вы создаете новый файл или открываете
 существующий, ему присваивается номер. Следующий файл получает
 очередной номер — например, 101, 102, 103 и так далее.

Как работает файловый дескриптор

Дескриптор для каждого процесса является уникальным. Но есть три
жестко закрепленных индекса — это первые три номера (0, 1, 2).

0 — стандартный ввод (stdin), место, из которого программа получает интерактивный ввод.
1 — стандартный вывод (stdout), на который направлена большая часть вывода программы.
2 — стандартный поток ошибок (stderror), в который направляются сообщения об ошибках.
Когда вы завершаете работу с файлом, присвоенный ему дескриптор освобождается и
 возвращается в пул свободных номеров. Он снова доступен для выделения под новый файл.
Номер файлового дескриптора и режим

В Unix-подобных системах файловые дескрипторы могут относиться
 к любому типу файлов Unix: обычным файлам, каталогам, блочным
 и символьным устройствам, сокетам домена, именованным каналам.
 Дескрипторы также могут относиться к объектам, которые не существуют
  в файловой системе: анонимным каналам и сетевым сокетам.


Что можно делать с файловыми дескрипторами
Файловые дескрипторы можно использовать для исправления ошибок. Например,
если на диске нет свободного места, но вы не видите файлы, которые занимают
пространство, то можно посмотреть открытые дескрипторы. Это поможет понять,
какое приложение заняло весь доступный объем.

Важно понимать, что если мы один раз открыли файл, и он получил файловый
дескриптор, то мы можем взаимодействовать с ним дальше. Не имеет значения, что
 с этим файлом происходит. Его могут переименовать, удалить, могут изменить
 его владельца, отобрать права на запись и чтение. Если вы уже начали работать
 с файлом и знаете его дескриптор, то можете продолжать с ним работать.

 ////////////////////////////
 Отображения файла в память под Linux с помощью mmap

 int fd = open(fname, O_RDONLY, 0);

 ;mov eax,function_number
 ;mov ebx,param_1  ; если есть
 ;mov ecx,param_2  ; если есть
 ;mov edx,param_3  ; если есть
 ;mov esi,param_4  ; если есть
 ;mov edi,param_5  ; если есть
 ;mov ebp,param_6  ; если есть
 ;int 0x80  ; вызов!
/////////////////////




Описание системного вызова

Системный вызов mmap служит для отображения предварительно открытого файла (например, с
помощью системного вызова open() ) в адресное пространство вычислительной системы. После
его выполнения файл может быть закрыт (например, системным вызовом close() ), что никак не
повлияет на дальнейшую работу с отображенным файлом.

Настоящее описание не является полным описанием системного вызова, а предназначено
только для использования в рамках данного курса. Для получения полной информации
обращайтесь к UNIX Manual.

Параметр fd является файловым дескриптором для файла, который мы хотим отобразить в адресное
пространство (т.е. значением, которое вернул системный вызов open() ).

Ненулевое значение параметра start может использоваться только очень квалифицированными
системными программистами, поэтому мы в семинарах будем всегда полагать его равным
значению NULL, позволяя операционной системе самой выбрать начало области адресного
 пространства, в которую будет отображен файл.

В память будет отображаться часть файла, начиная с позиции внутри его, заданной значением
параметра offset – смещение от начала файла в байтах, и длиной, равной значению параметра
length (естественно, тоже в байтах). Значение параметра length может и превышать реальную
длину от позиции offset до конца существующего файла. На поведении системного вызова это
никак не отразится, но в дальнейшем при попытке доступа к ячейкам памяти, лежащим вне границ
 реального файла, возникнет сигнал SIGBUS (реакция на него по умолчанию – прекращение процесса
  с образованием core файла).

Параметр flags определяет способ отображения файла в адресное пространство. В рамках нашего
 курса мы будем использовать только два его возможных значения: MAP_SHARED и MAP_PRIVATE. Если
  в качестве его значения выбрано MAP_SHARED, то полученное отображение файла впоследствии будет
  использоваться и другими процессами, вызвавшими mmap для этого файла с аналогичными значениями
  параметров, а все изменения, сделанные в отображенном файле, будут сохранены во вторичной
  памяти. Если в качестве значения параметра flags указано MAP_PRIVATE, то процесс получает
  отображение файла в свое монопольное распоряжение, но все изменения в нем не могут быть
  занесены во вторичную память (т.е., проще говоря, не сохранятся).

Параметр prot определяет разрешенные операции над областью памяти, в которую будет отображен
файл. В качестве его значения мы будем использовать значения PROT_READ (разрешено чтение),
PROT_WRITE (разрешена запись) или их комбинацию через операцию "побитовое или" – " | ". Необходимо
отметить две существенные особенности системного вызова, связанные с этим параметром:

Значение параметра prot не может быть шире, чем операции над файлом, заявленные при его открытии
в параметре flags системного вызова open() . Например, нельзя открыть файл только для чтения, а
при его отображении в память использовать значение prot = PROT_READ | PROT_WRITE.
В результате ошибки в операционной системе Linux при работе на 486-х и 586-х процессорах попытка
записать в отображение файла, открытое только для записи, более 32-х байт одновременно приводит
к ошибке (возникает сигнал о нарушении защиты памяти).
Возвращаемое значение

При нормальном завершении системный вызов возвращает начальный адрес области памяти, в которую
отображен файл (или его часть), при возникновении ошибки – специальное значение MAP_FAILED.

После этого с содержимым файла можно работать, как с содержимым обычной области памяти.
По окончании работы с содержимым файла, необходимо освободить дополнительно выделенную процессу
область памяти, предварительно синхронизировав содержимое файла на диске с содержимым этой
области (если, конечно, необходимо). Эти действия выполняет системный вызов munmap() .
Системный вызов munmap

Прототип системного вызова

#include <sys/types.h>
#include <unistd.h>
#include <sys/mman.h>

int munmap (void *start, size_t length);
Описание системного вызова

Системный вызов munmap служит для прекращения отображения memory mapped файла в адресное
 пространство вычислительной системы. Если при системном вызове mmap() было задано значение
 параметра flags, равное MAP_SHARED, и в отображении файла была разрешена операция записи (в
  параметре prot использовалось значение PROT_WRITE ), то munmap синхронизирует содержимое
  отображения с содержимым файла во вторичной памяти. После его выполнения области памяти,
  использовавшиеся для отображения файла, становятся недоступны текущему процессу.

Параметр start является адресом начала области памяти, выделенной для отображения файла, т.е.
значением, которое вернул системный вызов mmap() .

Параметр length определяет ее длину, и его значение должно совпадать со значением соответствующего
параметра в системном вызове mmap() .

Возвращаемое значение

При нормальном завершении системный вызов возвращает значение 0, при возникновении ошибки –
значение -1.

Анализ, компиляция и прогон программы для создания memory mapped файла и записи его содержимого
Для закрепления материала, изложенного в предыдущем разделе, рассмотрим пример программы.

/* Программа 11-1.с для иллюстрации работы с
memory mapped файлом */
int main(void)
{
    int fd; /* Файловый дескриптор для файла, в
котором будет храниться наша информация*/
    size_t length; /* Длина отображаемой части файла */
    int i;
    /* Ниже следует описание типа структуры, которым мы забьем
    файл, и двух указателей на подобный тип. Указатель ptr
    будет использоваться в качестве начального адреса
    выделенной области памяти, а указатель tmpptr – для
    перемещения внутри этой области. */
    struct A {
        double f;
        double f2;
    } *ptr, tmpptr;
    /* Открываем файл или сначала создаем его (если
такого файла не было). Права доступа к файлу при создании
определяем как read-write для всех категорий пользователей
(0666). Из-за ошибки в Linux мы будем вынуждены ниже в
системном вызове mmap() разрешить в отображении файла и
чтение, и запись, хотя реально нам нужна только запись.
Поэтому и при открытии файла мы вынуждены задавать O_RDWR. */
    fd = open("mapped.dat", O_RDWR | O_CREAT, 0666);
    if( fd == -1){
        /* Если файл открыть не удалось, выдаем
сообщение об ошибке и завершаем работу */
        printf("File open failed!\n");
        exit(1);
    }
    /* Вычисляем будущую длину файла (мы собираемся записать
    в него 100000 структур) */
    length = 100000*sizeof(struct A);
    /* Вновь созданный файл имеет длину 0. Если мы его
    отобразим в память с такой длиной, то любая попытка
    записи в выделенную память приведет к ошибке. Увеличиваем
    длину файла с помощью вызова ftruncate(). */
    ftruncate(fd,length);
    /* Отображаем файл в память. Разрешенные операции над
    отображением указываем как PROT_WRITE | PROT_READ по
    уже названным причинам. Значение флагов ставим в
    MAP_SHARED, так как мы хотим с охранить информацию,
    которую занесем в отображение, на диске. Файл
    отображаем с его начала (offset = 0) и до конца
    (length = длине файла). */
    ptr = (struct A )mmap(NULL, length, PROT_WRITE |
        PROT_READ, MAP_SHARED, fd, 0);
    /* Файловый дескриптор нам более не нужен, и мы его
    закрываем */
    close(fd);
    if( ptr == MAP_FAILED ){
        /* Если отобразить файл не удалось, сообщаем об
        ошибке и завершаем работу */
        printf("Mapping failed!\n");
        exit(2);
    }
    /* В цикле заполняем образ файла числами от 1 до 100000
    и их квадратами. Для перемещения по области памяти
    используем указатель tmpptr, так как указатель ptr на
    начало образа файла нам понадобится для прекращения
    иотображения вызовом munmap(). */
    tmpptr = ptr;
    for(i = 1; i <=100000; i++){
        tmpptr->f = i;
        tmpptr->f2 = tmpptr->f*tmpptr->f;
        tmpptr++;
    }
    /* Прекращаем отображать файл в память, записываем
    содержимое отображения на диск и освобождаем память. */
    munmap((void *)ptr, length);
    return 0;
}
Листинг 11.1. Программа 11-1.с для иллюстрации работы с memory mapped файлом.
Эта программа создает файл, отображает его в адресное пространство процесса и заносит в него
информацию с помощью обычных операций языка С.

Обратите внимание на необходимость увеличения размера файла перед его отображением. Созданный
файл имеет нулевой размер, и если его с этим размером отобразить в память, то мы сможем записать
 в него или прочитать из него не более 0 байт, т.е. ничего. Для увеличения размера файла
 использован системный вызов ftruncate() , хотя это можно было бы сделать и любым другим способом.

При отображении файла мы вынуждены разрешить в нем и запись, и чтение, хотя реально совершаем
только запись. Это сделано для того, чтобы избежать ошибки в операционной системе Linux,
связанной с использованием 486-х и 586-х процессоров. Такой список разрешенных операций
однозначно требует, чтобы при открытии файла системным вызовом open() файл открывался и на
 запись, и на чтение. Поскольку информацию мы желаем сохранить на диске, при отображении
 использовано значение флагов MAP_SHARED. Откомпилируйте эту программу и запустите ее.

Изменение предыдущей программы для чтения из файла, используя его отображение в память
Модифицируйте программу из предыдущего раздела так, чтобы она отображала файл, записанный
программой из раздела "Анализ, компиляция и прогон программы для создания memory mapped файла
 и записи его содержимого", в память и считала сумму квадратов чисел от 1 до 100000, которые
  уже находятся в этом файле.

Задача повышенной сложности: напишите две программы, использующие memory mapped файл для обмена
информацией при одновременной работе, подобно тому, как они могли бы использовать разделяемую память


***************************************************

;- получить из стека командную строку (содержащую имя файла и
;параметры, переданные программе при запуске);
;- первый параметр вывести на экран красным цветом, второй —
;синим и с новой строки.
;- выполнить побайтный «переворот» содержимого файла, имя которого задано первым параметром командной строки; информацию записывать в этот же файл без промежуточных и дополнительных файлов, с использованием отображения файла на память;
;- каждая файловая операция контролируются на ошибку без анализа ее номера с выдачей на терминал своего сообщения, типа
;«Ошибка открытия файла», «Ошибка записи» и т.д.
;-; завершить программу.

;./text one two three four five six seven - передача параметров
;которые помещаются в стек

;"^[[5;34;42mIn color"

;Командная строка:

;forsearch.txt Ctrl+@ Ctrl+V+Esc [;31;m   Ctrl+V+Esc [;34;m    Ctrl+V+Esc[1E

SECTION .data        ;для инициализированных данных

invite1 db "Введите с клавиатуры адрес/имя файла forsearch.txt Ctrl+@",0xa,0
;символ NUL обозначается ^@ и вводится с помощью клавиш Ctrl+@
linvite1 equ $-invite1

match db "Найдено",0xa,0
lmatch equ $-match

nomatch db "Не найдено",0xa,0
lnomatch equ $-nomatch

filetoopen: db "forsearch.txt",0 ;ввод адреса
lfiletoopen equ $-filetoopen
;return rax=fffffffffffffffe или 18446744073709551614,а eax=-2
;не меняется при изменении имени файла



n db 0xa                   ;переменная для переноса строки

SECTION .bss         ;для НЕинициализированных данных
input: resb 100               ;что ищем
linput equ $-input

input2: resb 100               ;где ищем
linput2 equ $-input2

input3: resb 10               ;выделение памяти в 10 байт, где input3- адрес первого символа
linput3 equ $-input3             ;адрес с длиной сообщения


SECTION .text      ;начало кода самой программы
GLOBAL _start
      _start:

;- открыть файл, прочитать его в буфер и найти в содержимом подстроку, используя строковые инструкции;-
mov eax,5             ;open
mov ebx,filetoopen    ;имя/адрес файла
mov ecx,0             ;0-read, 1-write, 2-read and write
int 80h

;возвращаемое значение — неотрицательное целое число, равное дескриптору файла.
;в случае ошибки возвращается значение -1.

mov edi,eax   ;filedes - дескриптор отображаемого файла, описатель файла
mov eax,192     ;90-возможно устаревший системный вызов, № системного вызова  192 работает, а 90 - нет
mov ebx,0     ;*address - указатель/адрес участка памяти процесса, в который отображается содержимое файла, обычно 0
mov ecx,50    ;length - длина отображаемого участка файла с начала или с символа offset (по умолчанию = 0)
mov edx,1     ;protect - защита файла, 0 - доступ запрещен, 1 - read, 2 - write, 4 - для исполнения кода
mov esi,2     ;flags - 1 или 2 передача изменений: да или нет
;mov edi,1     ;filedes - дескриптор отображаемого файла, описатель файла, 1 - для вывода данных
mov ebp,0     ;offset - от какого символа считать начало отображаемого текста
int 80h
;возвращает fffffffffffffff2 в rax

;вывод результата
 mov ecx,eax   ;ввод полученного адреса памяти от mmap
 mov edx,50      ;ввод количества символов
 mov eax,4
 mov ebx,1
 int 80h

 ;закрыть файл
 mov eax,6
 mov ebx,0    ;дескриптор
 int 0x80
;возвращаемое значение — 0; значение -1 возвращается в случае ошибки.

;- завершить программу.+


mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
/*/*/*/*/*/*/*/

;- получить из стека командную строку (содержащую имя файла и
;параметры, переданные программе при запуске);
;- первый параметр вывести на экран красным цветом, второй —
;синим и с новой строки.
;- выполнить побайтный «переворот» содержимого файла, имя которого задано первым параметром командной
; строки; информацию записывать в этот же файл без промежуточных и дополнительных файлов,
;с использованием отображения файла на память;
;- каждая файловая операция контролируются на ошибку без анализа ее номера с выдачей на
терминал своего сообщения, типа
;;«Ошибка открытия файла», «Ошибка записи» и т.д.
;-; завершить программу.

;./text one two three four five six seven - передача параметров
;которые помещаются в стек

;"^[[5;34;42mIn color"

;Командная строка:

;forsearch.txt Ctrl+@ Ctrl+V+Esc [;31;m   Ctrl+V+Esc [;34;m    Ctrl+V+Esc[1E

SECTION .data        ;для инициализированных данных

invite1 db "Введите с клавиатуры адрес/имя файла forsearch.txt Ctrl+@",0xa,0
;символ NUL обозначается ^@ и вводится с помощью клавиш Ctrl+@
linvite1 equ $-invite1

match db "Найдено",0xa,0
lmatch equ $-match

nomatch db "Не найдено",0xa,0
lnomatch equ $-nomatch

filetoopen: db "forsearch.txt",0 ;ввод адреса
lfiletoopen equ $-filetoopen
;return rax=fffffffffffffffe или 18446744073709551614,а eax=-2
;не меняется при изменении имени файла



n db 0xa                   ;переменная для переноса строки

SECTION .bss         ;для НЕинициализированных данных
input: resb 100               ;что ищем
linput equ $-input

input2: resb 100               ;где ищем
linput2 equ $-input2

input3: resb 10               ;выделение памяти в 10 байт, где input3- адрес первого символа
linput3 equ $-input3             ;адрес с длиной сообщения


SECTION .text      ;начало кода самой программы
GLOBAL _start
      _start:

;показать параметры программы , которые вводятся в командной строке
;и помещаются в стек, например:
;./text one two three four five six seven - передача параметров

;первый элемент в стеке - количество введенных символов в ком.строке, включая имя,
;исполняемого файла, добавляем символ '0' для вывода этого числа на экран
mov eax,input3
pop rbx
add bl,'0'
mov [eax],bl
inc eax

;ввод через командную строку на ассемблере, это то же, что и
;функция int main(int argc, char *argv[]); на языке C;
;например ввод в строке:  ./text 1 2  9
выводит 4(кол-во элементов) и указатели/адрес для каждого элемента  .129(первый символ каждого элемента)


;вывод элементов массива, работает!
;пробелы не учитываются!
;кол-во элементов должно быть не меньше выводов из стека!!!
;показывает только первый символ из каждого элемента!!!
;выводит в порядке ввода, т.е. ввод в стек начинается с последнего вводимого элемента, заодно и
;идет подсчет элементов!
pop rbx
mov cl,byte[rbx]
;add cl,'0'
mov [eax],cl
inc eax

pop rbx
mov cl,byte[rbx]
;add cl,'0'
mov [eax],cl
inc eax

pop rbx
mov cl,byte[rbx]
;add cl,'0'
mov [eax],cl
inc eax

pop rbx
mov cl,byte[rbx]
;add cl,'0'
mov [eax],cl


mov ecx,input3        ;ввод адреса
mov edx,linput3      ;ввод количества символов
mov eax,4
mov ebx,1
int 80h






;- открыть файл, прочитать его в буфер и найти в содержимом подстроку, используя строковые инструкции;-
;mov eax,5             ;open
;mov ebx,filetoopen    ;имя/адрес файла
;mov ecx,0             ;0-read, 1-write, 2-read and write
;int 80h

;возвращаемое значение — неотрицательное целое число, равное дескриптору файла.
;в случае ошибки возвращается значение -1.

;mov edi,eax   ;filedes - дескриптор отображаемого файла, описатель файла
;mov eax,192     ;90-возможно устаревший системный вызов, № системного вызова  192 работает, а 90 - нет
;mov ebx,0     ;*address - указатель/адрес участка памяти процесса, в который отображается содержимое файла, обычно 0
;mov ecx,50    ;length - длина отображаемого участка файла с начала или с символа offset (по умолчанию = 0)
;mov edx,1     ;protect - защита файла, 0 - доступ запрещен, 1 - read, 2 - write, 4 - для исполнения кода
;mov esi,2     ;flags - 1 или 2 передача изменений: да или нет
;mov edi,1     ;filedes - дескриптор отображаемого файла, описатель файла, 1 - для вывода данных
;mov ebp,0     ;offset - от какого символа считать начало отображаемого текста
;int 80h
;возвращает fffffffffffffff2 в rax

;вывод результата
 ;mov ecx,eax   ;ввод полученного адреса памяти от mmap
 ;mov edx,50      ;ввод количества символов
 ;mov eax,4
 ;mov ebx,1
 ;int 80h

 ;закрыть файл
 ;mov eax,6
 ;mov ebx,0    ;дескриптор
 ;int 0x80
;возвращаемое значение — 0; значение -1 возвращается в случае ошибки.

;- завершить программу.+
;вывод результата
 mov ecx,n   ;ввод полученного адреса памяти от mmap
 mov edx,1      ;ввод количества символов
 mov eax,4
 mov ebx,1
 int 80h

mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
