SECTION .data        ;для инициализированных данных

invite db "Введите несколько букв и цифр:",0xa,0
linvite equ $-invite

aless db "less",0xa,0
lless equ $-aless

agreater db "greater",0xa,0
lgreater equ $-agreater

aequal db "equal",0xa,0
lequal equ $-aequal


n db 0xa                   ;переменная для переноса строки

SECTION .bss         ;для НЕинициализированных данных
;ввод символов
input: resb 100                              ;выделение памяти в 100 байт, где input- адрес первого символа
linput equ $-input                           ;адрес с длиной сообщения

;вывод повторяющихся символов
output: resb 100                              ;выделение памяти в 100 байт
loutput equ $-output                            ;адрес с длиной сообщения

;вывод неповторяющихся символов
nodub: resb 10                              ;выделение памяти в 10 байт
lnodub equ $-nodub                            ;адрес с длиной сообщения

;вывод байтов
byteout: resb 16                             ;выделение памяти в 16 байт
lbyteout equ $-byteout                            ;адрес с длиной сообщения

;проверка пунктов
awork: resb 1
lawork  equ $-awork



SECTION .text     ;начало кода самой программы


GLOBAL _start

;подпрограммы
;вывод записи, использование стандартных обязательных данных
PRINT:
mov eax,4
mov ebx,1
int 80h
ret

;ввод записи
WRITE:
mov eax,3
mov ebx,0
int 80h
ret

    _start:

;отсюда начинается обработка и ввод данных:




;вывод приглашения ввести символы
mov ecx,invite       ;ввод адреса
mov edx,linvite      ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

;ввод символов
mov ecx,input       ;ввод адреса
mov edx,linput     ;ввод количества символов
mov eax,3
mov ebx,0
int 80h

;по моему здесь выдает в gdb ;Program received signal SIGSEGV, Segmentation fault
;поместить адрес из памяти в регистр
mov esi,input
mov edi,output

;кол-во циклов для ввода найденных чисел в память output
mov ecx,linput

;следующий символ
next:

;перенос значений из input в output через 1-байтный регистр bpl для сравнения
mov al,byte[esi]

;проверяем каждый символ 10 раз на совпадение с цифрой от от 0 до 9

;в ASCII с 48 по 57 номера цифр
;0 - 48 или 00110000b, для поиска ставим 11001111b
;1 - 49 или 00110001b, для поиска ставим 11001110b
;2 - 50 или 00110010b, для поиска ставим 11001101b
;3 - 51 или 00110011b, для поиска ставим 11001100b
;4 - 52 или 00110100b, для поиска ставим 11001011b
;5 - 53 или 00110101b, для поиска ставим 11001010b
;6 - 54 или 00110110b, для поиска ставим 11001010b
;7 - 55 или 00110111b, для поиска ставим 11001000b
;8 - 56 или 00111000b, для поиска ставим 11000111b
;9 - 57 или 00111001b, для поиска ставим 11000110b
;проверим каждое значение методом test
;сравнение символа через его номер в ASCII в 2-м формате с инвертированной маской этого номера в том же виде
;при замене 0 на 1 и наоборот - при операции И или TEST во флаг ZF помещается 1,  и можно осуществить переход по условию
;например ,если для поиска 001100b использовать 110011b, то искомый результат будет 0, а при любом другом значении - 1
;если совпадает
;jnz yes  ;ZF = 0    1 и 1 = 1, а остальные комбинации = 0
;если не совпадает
;jz   ZF = 1

mov ah,'0'        ;номер в регистре обычно обозначает номер символа в ASCII
                 ;он может быть в двоичной форме или десятичной, например 00111001b или 57
                 ;или же просто указать сам символ в ковычках, и он автоматически переведется в номер
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
;т.к. №0 в таблице=48 или 001100000b, то ставим инвертированное (замененное) значение 11001111b
jz yes

mov ah,'1'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah               ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

mov ah,'2'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah               ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

mov ah,'3'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

mov ah,'4'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

mov ah,'5'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

mov ah,'6'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

mov ah,'7'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah               ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

mov ah,'8'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

mov ah,'9'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

;если не найдена цифра

;увеличение адресов на 1, т.е. получение следующей ячейки памяти
inc esi          ;только для адреса ввода, для вывода не надо!!! иначе память вывода расходуется впустую!!!

;на проверку следующего символа
loop next

;на выход
jmp exit

;ввод символа в память out
yes:
;перенос значений в output через 1-байтный регистр al
mov byte[edi],al

;увеличение адресов на 1, т.е. получение следующей ячейки памяти
inc esi
inc edi

;на проверку следующего символа
loop next

;на выход
jmp exit

exit:
;вывод введенных символов
mov ecx,output       ;ввод адреса
mov edx,loutput      ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

;переход на новую строку
mov ecx, n
mov edx, 1
mov eax,4
mov ebx,1
int 80h


;;;;;;;;;;;;


;замена значений в памяти
mov edi,loutput
mov ebx,loutput
mov esi,output
mov ebp,esi


dec edi
mov ecx,edi
two:
mov dh,byte[esi]
inc esi

;все работает, кроме реакции на пустой символа
;если появляется NULL, то надо брать следующий символ и вставлять опять в ту же ячейку

one:

cmp dh,byte[esi]
jg greater
jl less
je equal
greater:

;если символы кончились, то выходим
;если пробел вместо числа
mov ah,0   ;если символ с номером 0, т.е. null, или пустое место (не пробел!)
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dh,ah                ;проверяем на null, не 0! и не НОЛЬ!, обозначение символа в таблице ASCII в двоичном формате
;т.к. №NULL в таблице=0 или 000000000b, то ставим инвертированное (замененное) значение 11111111b
jz toexit

;если пробел вместо числа
mov ah,0   ;если символ с номером 0, т.е. null, или пустое место (не пробел!)
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test byte[esi],ah                ;проверяем на null, не 0! и не НОЛЬ!, обозначение символа в таблице ASCII в двоичном формате
;т.к. №NULL в таблице=0 или 000000000b, то ставим инвертированное (замененное) значение 11111111b
jz toend

mov dl,byte[esi]
mov byte[ebp],dl
mov byte[esi],dh
mov dh,dl

nextto:
inc esi
loop one
jmp toend

less:
jmp nextto

equal:
;надо доработать!чтоб не было одинаковых значений!
;при одинаковых значениях символ меняется на больший по размеру
;и соответственно сдвигается вправо!
;потом их можно отрезать и все, вместо того, чтобы циклом сдвигать все следующие значения!

mov byte[esi],'a'
jmp nextto

toend:
mov ecx,ebx
dec ebx
inc ebp
mov esi,ebp
loop two

toexit:

mov ecx, output
mov edx,loutput
mov eax,4
mov ebx,1
int 80h

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;выбрать только цифры из output
;ecx - счетчик
mov ecx,loutput
;адрес первого символа для ввода
mov ebx,output

;адрес первого символа для вывода
mov edx,nodub


again1:
;ввод первого символа в регистр
mov al,byte[ebx]


mov ah,'0'        ;номер в регистре обычно обозначает номер символа в ASCII
                 ;он может быть в двоичной форме или десятичной, например 00111001b или 57
                 ;или же просто указать сам символ в ковычках, и он автоматически переведется в номер
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
;т.к. №0 в таблице=48 или 001100000b, то ставим инвертированное (замененное) значение 11001111b
jz match

mov ah,'1'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah               ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'2'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah               ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'3'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'4'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'5'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'6'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'7'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah               ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'8'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'9'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

jnz nomatch
nomatch:
inc ebx
loop again1
jmp away

match:
mov byte[edx],al
inc ebx      ;увеличить номер ячейки памяти ввода
inc edx      ;увеличить номер ячейки памяти для вывода
loop again1
jmp away
away:


;переход на новую строку
mov ecx, n
mov edx, 1
mov eax,4
mov ebx,1
int 80h

mov ecx,nodub
mov edx,lnodub
mov eax,4
mov ebx,1
int 80h

;переход на новую строку
mov ecx, n
mov edx, 1
mov eax,4
mov ebx,1
int 80h
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
xor ax,ax                          ;задать нулевое значение для регистра ax
;mov ax,0000000000000000b             ;задать нулевое значение для регистра ax
mov ebx,nodub        ;адрес первой ячейки nodub
mov ecx,lnodub      ;счетчик по количеству символов в строке (10)

;;;;;;;;;;;


toshift:

mov dl,byte[ebx]   ;значение по адресу ebx

mov dh,'0'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match0

mov dh,'1'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match1

mov dh,'2'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match2

mov dh,'3'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match3

mov dh,'4'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match4

mov dh,'5'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match5

mov dh,'6'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match6

mov dh,'7'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match7

mov dh,'8'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match8

mov dh,'9'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match9

;;
match0:
;or ax,0000000000000001b
or ax,1
jmp again3

match1:
;or ax,0000000000000010b
or ax,2
jmp again3

match2:
;or ax,0000000000000100b
or ax,4
jmp again3

match3:
;or ax,0000000000001000b
or ax,8
jmp again3

match4:
;or ax,0000000000010000b
or ax,16
jmp again3

match5:
;or ax,0000000000100000b
or ax,32
jmp again3

match6:
;or ax,0000000001000000b
or ax,64
jmp again3

match7:
;or ax,0000000001000000b
or ax,128
jmp again3

match8:
;or ax,0000000100000000b
or ax,256
jmp again3

match9:
;or ax,0000001000000000b
or ax,512
jmp again3


;;

again3:
inc ebx            ;увеличить номер ячейки
;если loop toshift не срабатывает из-за длинного кода
;можно использовать следующий код:
dec ecx
jnz toshift


;;;;;;;;;;;


mov bl,2             ;делитель для степени 2 ax
mov edx,byteout

metka1:
div bl
;div делит значение из ax на bl
;целый результат - al
;остаток - ah
mov byte[edx],ah        ;ввод остатка
add byte[edx],'0'       ;чтобы вывести число из регистра, его надо перевести в символ путем добавления '0'
inc edx

movzx ax,al     ;перенос целого в ax
cmp al,bl
jge metka1        ;если целое больше или равно делителю
jl metka2         ;если целое меньше делителя

metka2:
mov byte[edx],al        ;ввод целого
add byte[edx],'0'       ;добавление '0', чтобы чисто перевести в символ


;на этих местах единицы 236
;вводимое значение 00100110 = 38
;проблема - сдвигает биты и добавляет 1 бит справа

;выводит 1011001 а должно 011001, но нули в конце не ставит, но это надо доработать потом
;вводится вместо 100110 вот это, 1 лишняя справа 1001101

;1 вариант он реагирует на '0' и добавляет 1 - не то!
;добавляет 0 вместо 1
;2 вариант попробовать реакцию на NULL или номер 0 в ASCII - не то
;3 вариант добавлять номер ячейки перед проверкой
;4 вариант обновить весь регистр eax - не то
;5 вариант убрать вывод целого - не то
;6 вариант уменьщить кол-во проходов - не то




;вывод битов
mov ecx, byteout
mov edx, lbyteout
mov eax,4
mov ebx,1
int 80h


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
