SECTION .data        ;для инициализированных данных

invite db "Введите с клавиатуры символы для поиска",0xa,0
linvite equ $-invite

invite1 db "Введите с клавиатуры адрес/имя файла с последним символом в виде NUL = 0, клавиша ^@",0xa,0
;символ NUL обозначается ^@ и вводится с помощью клавиш Ctrl+@
linvite1 equ $-invite1

match db "Найдено",0xa,0
lmatch equ $-match

nomatch db "Не найдено",0xa,0
lnomatch equ $-nomatch

n db 0xa                   ;переменная для переноса строки

SECTION .bss         ;для НЕинициализированных данных
filetoopen: resb 100

input: resb 100               ;что ищем
linput equ $-input

input2: resb 100               ;где ищем
linput2 equ $-input2

input3: resb 10               ;выделение памяти в 10 байт, где input3- адрес первого символа
linput3 equ $-input3             ;адрес с длиной сообщения


SECTION .text      ;начало кода самой программы
GLOBAL _start
      _start:

;- вывести на экран приглашение, и ввести с клавиатуры символьную подстроку для поиска;+
mov ecx,invite        ;ввод адреса
mov edx,linvite       ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

mov ecx,input        ;ввод адреса
mov edx,linput       ;ввод количества символов
mov eax,3
mov ebx,0
int 80h

mov ecx,linput ; счетчик
;количество введенных символов, но не больше 255
xor ebx,ebx    ;обнуление регистра ebx для подсчета символов input
mov edx,input  ;получить адрес первого символа 456
againinput:
mov al,byte[edx]
inc edx
cmp al,0
je nextinput
inc ebx     ;увеличить кол-во символов
loop againinput
nextinput:
dec ebx     ;уменьшить на 1 кол-во символов, так как возможно считает 'enter'
mov ebp,ebx ;кол-во символов

;- вывести на экран еще одно приглашение, и ввести с клавиатуры имя файла;+
mov ecx,invite1        ;ввод адреса
mov edx,linvite1       ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

mov ecx,filetoopen        ;ввод адреса
mov edx,100               ;ввод количества символов
mov eax,3
mov ebx,0
int 80h

;- открыть файл, прочитать его в буфер и найти в содержимом подстроку, используя строковые инструкции;-
mov eax,5             ;open
mov ebx,filetoopen    ;имя/адрес файла
mov ecx,2             ;read and write mode
int 80h

;поместить данные из файла в память input2
mov ebx,3
mov ecx,input2
mov edx,linput2
int 80h

;закрыть файл
mov eax,6
mov ebx,0
int 0x80

;кол-во проходов ebx =длина строки в которой ищем-длина искомой строки
;ebx=100-[input3]
;ebp - кол-во символов в строке которую ищем 1
;mov ecx , ? - цикл, сколько символов проверяется в каждой из строк по символьно 'cmpsb'
;mov esi , input - что ищем адрес [2]
;mov edi , input2 - где ищем адрес [123456789]
xor edx,edx
add edx,input2
dec edx       ;т.к. иначе первый элемент не находит

mov ebx,linput2 ;кол-во циклов проверки всего файла
sub ebx,ebp     ;высчитаем кол-во символов, которые ищем

again:
;это нужно в цикл поместить
mov eax,linput2
sub eax,ebp         ;кол-во циклов прохода по строке которую ищем
inc edx         ;если увеличить, то ищет 2 и 3 символ, а 1 не ищет!
mov edi,edx      ;где ищем , если увеличить этот адрес, то можно еще искать!!
mov ecx,ebp       ;цикл, кол-во символов, которые ищем в 'repe cmpsb'
mov esi,input       ;что ищем
;edi - где ищем
repe cmpsb          ;сравнивать, пока совпадают
je yes             ;если найдено

;работает поиск, но если не находит ошибка с памятью!
;ее решить и можно проверить на большое кол-во символов!
dec ebx
cmp ebx,0  ;проверяем количество циклов на 0, если больше цикл повторяем
jg again
jmp no             ;если не найдено

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Команда CMPSB сравнивает один байт из памяти по
;адресу DS:SI с байтом по адресу ES:DI. Аналогична по действию команде CMP.
;Если команда используется в 32-разрядном режиме адресации,
;то используются регистры ESI и EDI соответственно.
;rep,repne,repe - циклы вместо loop, только для поиска,
;но метку возврата им не надо
;rep - повтор любых действий
;repne и repe - поиск до тех пор, пока не найдено
;или найдено соответственно

;флаги
;0 - открывает файл для чтения.
;1 - открывает файл для записи.
;2 - открывает файл для чтения и для записи.
;2000 - записывает данные в конец файла, расширяя его.
;100 - создает файл, если он еще не существует.

;Нуль-терминированная строка или C-строка или ASCIIZ-строка, это когда в
;конце строки устанавливается нуль-символ (NUL из кода ASCII, со значением 0)
;его можно ввести с клавиатуры путем сочетания клавиш Ctrl+@
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;- вывести результат поиска в виде сообщения «Найдено» или «Не найдено»;+
yes:
 ;вывод результата
 mov ecx,match        ;ввод адреса
 mov edx,lmatch       ;ввод количества символов
 mov eax,4
 mov ebx,1
 int 80h
 jmp end

no:
 ;вывод результата
 mov ecx,nomatch        ;ввод адреса
 mov edx,lnomatch       ;ввод количества символов
 mov eax,4
 mov ebx,1
 int 80h
 jmp end

;- завершить программу.+
end:                     ;здесь заканчивается вывод данных:
;;;;;;

mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
