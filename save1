SECTION .data        ;для инициализированных данных

invite db "Введите несколько букв и цифр:",0xa,0
linvite equ $-invite


n db 0xa                   ;переменная для переноса строки
ln equ $-n

SECTION .bss         ;для НЕинициализированных данных
;ввод символов
input: resb 100                               ;выделение памяти в 100 байт, где input- адрес первого символа
linput equ $-input                           ;адрес с длиной сообщения

;вывод повторяющихся символов
output: resb 100                              ;выделение памяти в 100 байт
loutput equ $-output                            ;адрес с длиной сообщения

;вывод неповторяющихся символов
nodub: resb 10                              ;выделение памяти в 10 байт
lnodub equ $-nodub                            ;адрес с длиной сообщения

;вывод байтов
byteout: resb 16                             ;выделение памяти в 16 байт
lbyteout equ $-byteout                            ;адрес с длиной сообщения


SECTION .text     ;начало кода самой программы


;подпрограммы
;вывод записи, использование стандартных обязательных данных
PRINT:
mov eax,4
mov ebx,1
int 80h
ret

;ввод записи
WRITE:
mov eax,3
mov ebx,0
int 80h
ret

GLOBAL _start
    _start:
                                              ;1 ввод символов:

;вывод приглашения ввести символы
mov ecx,invite       ;ввод адреса
mov edx,linvite      ;ввод количества символов
call PRINT

;ввод символов
mov ecx,input       ;ввод адреса
mov edx,linput     ;ввод количества символов
call WRITE

;поместить адрес из памяти в регистр
mov ebx,input
mov edx,output

;кол-во циклов для ввода найденных чисел в память output
mov ecx,linput

;следующий символ
next:

;перенос значений из input в output через 1-байтный регистр al для сравнения
mov al,byte[ebx]

;проверяем каждый символ на совпадение с цифрой от от 0 до 9
;в ASCII с 48 по 57 номера цифр

cmp al,48
jge continue1
jl no

continue1:
cmp al,57
jle yes
jg no

;если не найдена цифра
no:

;увеличение адресов на 1, т.е. получение следующей ячейки памяти
inc ebx          ;только для адреса ввода, для вывода не надо!!! иначе память вывода расходуется впустую!!!

;на проверку следующего символа
loop next
;при завершении цикла - на выход
jmp exit

;ввод цифры в память out
yes:
;перенос значений в output через 1-байтный регистр al
mov byte[edx],al

;увеличение адресов на 1, т.е. получение следующей ячейки памяти
inc ebx
inc edx

;на проверку следующего символа
loop next
;при завершении цикла - на выход
jmp exit

exit:
;вывод введенных символов
mov ecx,output       ;ввод адреса
mov edx,loutput      ;ввод количества символов
call PRINT

;переход на новую строку
mov ecx,n
mov edx,ln
call PRINT

                                                   ;2 вывод символов

;замена значений в памяти
mov edi,loutput
mov ebx,loutput
mov esi,output
mov ebp,esi

dec edi
mov ecx,edi

two:
mov dh,byte[esi]
inc esi

one:
cmp dh,byte[esi]
jg greater
jl less
je equal
greater:
;если символы кончились, то выходим

mov dl,byte[esi]
mov byte[ebp],dl
mov byte[esi],dh
mov dh,dl

nextto:
inc esi
loop one
jmp toend

less:
jmp nextto
equal:

;при одинаковых значениях символ меняется на больший по размеру
;и соответственно сдвигается вправо!
;потом их можно отрезать и все, вместо того, чтобы циклом сдвигать все следующие значения!

mov byte[esi],58          ;замена символа на символ с номером 58
jmp nextto

toend:
mov ecx,ebx
dec ebx
inc ebp
mov esi,ebp
loop two

toexit:

mov ecx, output
mov edx,loutput
call PRINT

;переход на новую строку
mov ecx,n
mov edx,ln
call PRINT

;Обычно ошибка сегментации segmentation fault происходит потому, что:
;указатель нулевой,
;указатель указывает на произвольный участок памяти (возможно потому, что не был инициализирован),
;указатель указывает на удалённый участок памяти.
;в качестве размера массива указана неинициализированная переменная

                                              ;3 выбрать только цифры

;выбрать только цифры из output
;ecx - счетчик
mov ecx,loutput
;адрес первого символа для ввода
mov ebx,output

;адрес первого символа для вывода
mov edx,nodub

again1:
;ввод первого символа в регистр
mov al,byte[ebx]

mov ah,'0'        ;номер в регистре обычно обозначает номер символа в ASCII
;он может быть в двоичной форме или десятичной, например 00111001b или 57
;или же просто указать сам символ в ковычках, и он автоматически переведется в номер
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
;т.к. №0 в таблице=48 или 001100000b, то ставим инвертированное (замененное) значение 11001111b
jz match

mov ah,'1'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah               ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'2'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah               ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'3'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'4'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'5'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'6'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'7'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah               ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'8'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'9'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

jnz nomatch
nomatch:
inc ebx
loop again1
jmp away

match:
mov byte[edx],al
inc ebx      ;увеличить номер ячейки памяти ввода
inc edx      ;увеличить номер ячейки памяти для вывода
loop again1
jmp away

away:


mov ecx,nodub
mov edx,lnodub
call PRINT

;переход на новую строку
mov ecx,n
mov edx,ln
call PRINT

                                         ;4 убрать дублирование и установить биты в 1

;0 - 48 или 00110000b, для поиска ставим 11001111b
;1 - 49 или 00110001b, для поиска ставим 11001110b и т.д.
;проверим каждое значение методом test
;сравнение символа через его номер в ASCII в 2-м формате с инвертированной маской этого номера в том же виде
;при замене 0 на 1 и наоборот - при операции И или TEST во флаг ZF помещается 1,  и можно осуществить переход по условию
;например ,если для поиска 001100b использовать 110011b, то искомый результат будет 0, а при любом другом значении - 1
;если совпадает
;jnz yes  ;ZF = 0    1 и 1 = 1, а остальные комбинации = 0
;если не совпадает
;jz   ZF = 1

;xor ax,ax                          ;задать нулевое значение для регистра ax
;mov rsi,0                            ;задать нулевое значение для регистра rsi, а потом перенести его в rax
xor si,si                            ;обнулить регистр
mov ebx,nodub        ;адрес первой ячейки nodub
mov ecx,lnodub      ;счетчик по количеству символов в строке (10)


toshift:

mov dl,byte[ebx]   ;значение по адресу ebx

mov dh,'0'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match0

mov dh,'1'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match1

mov dh,'2'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match2

mov dh,'3'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match3

mov dh,'4'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match4

mov dh,'5'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match5

mov dh,'6'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match6

mov dh,'7'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match7

mov dh,'8'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match8

mov dh,'9'        ;номер в регистре обычно обозначает номер символа в ASCII
not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match9

;;
match0:
;or ax,0000000000000001b
or si,1
jmp again3

match1:
;or ax,0000000000000010b
or si,2
jmp again3

match2:
;or ax,0000000000000100b
or si,4
jmp again3

match3:
;or ax,0000000000001000b
or si,8
jmp again3

match4:
;or ax,0000000000010000b
or si,16
jmp again3

match5:
;or ax,0000000000100000b
or si,32
jmp again3

match6:
;or ax,0000000001000000b
or si,64
jmp again3

match7:
;or ax,0000000001000000b
or si,128
jmp again3

match8:
;or ax,0000000100000000b
or si,256
jmp again3

match9:
;or ax,0000001000000000b
or si,512
jmp again3


again3:
inc ebx            ;увеличить номер ячейки
;если loop toshift не срабатывает из-за длинного кода
;можно использовать следующий код:
dec ecx
jnz toshift

mov edx,byteout     ;указать адрес первого элемента
add edx,15  ;lbyteout    ;увеличить номер ячейки памяти на lbyteout
mov ax,si             ;перенос значения из si в ax, т.к. в ax может добавляться ответ от какой-либо функции
mov bl,2             ;делитель для степени 2 ax

;в памяти надо разместить 16 цифр 0 и 1,
;посчитать выводимые цифры и дополнить остальное до конца справа нулями
mov ecx,16    ;счетчик

;номера памяти 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;первый номер 0+15=15
;

metka1:

;dec ecx                 ;уменьшить счетчик
div bl
;div делит значение из ax на bl
;целый результат - al
;остаток - ah
mov byte[edx],ah        ;ввод остатка
add byte[edx],'0'       ;чтобы вывести число из регистра, его надо перевести в символ путем добавления '0'
movzx ax,al     ;перенос целого в ax
;inc edx          ;увеличить номер ячейки памяти для вывода
dec edx                 ;уменьшить номер ячейки памяти
loop metka1    ;повторение цикла 16 раз и вывод только остатка

;cmp al,bl
;jge metka1        ;если целое больше или равно делителю
;jl metka2         ;если целое меньше делителя

;metka2:
;dec edx
;dec ecx                 ;уменьшить счетчик
;mov byte[edx],al        ;ввод целого
;add byte[edx],'0'       ;добавление '0', чтобы чисто перевести в символ




;на этих местах единицы 236
;выводит 1011001 а должно 0011001, в результате всегда ставится 1 на месте 0, независимо прописан 0 или нет

;добавить нули до полного регистра ax из 16 байтов



;addzero:

;mov byte[edx],0         ;ввести остальные значения 0
;add byte[edx],'0'       ;чтобы вывести число из регистра, его надо перевести в символ путем добавления '0'
;dec edx
;loop addzero


;вывод битов
mov ecx, byteout
mov edx, lbyteout
call PRINT

;переход на новую строку
mov ecx,n
mov edx,ln
call PRINT


                                             ;6 выход из программы

mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
