     1                                  SECTION .data        ;для инициализированных данных
     2                                  
     3 00000000 D092D0B2D0B5D0B4D0-     invite db "Введите первое число от 0 до 65535 включительно:",0xa,0
     3 00000009 B8D182D0B520D0BFD0-
     3 00000012 B5D180D0B2D0BED0B5-
     3 0000001B 20D187D0B8D181D0BB-
     3 00000024 D0BE20D0BED1822030-
     3 0000002D 20D0B4D0BE20363535-
     3 00000036 333520D0B2D0BAD0BB-
     3 0000003F D18ED187D0B8D182D0-
     3 00000048 B5D0BBD18CD0BDD0BE-
     3 00000051 3A0A00             
     4                                  linvite equ $-invite
     5                                  
     6 00000054 D092D0B2D0B5D0B4D0-     invite1 db "Введите второе число от 0 до 65535 включительно:",0xa,0
     6 0000005D B8D182D0B520D0B2D1-
     6 00000066 82D0BED180D0BED0B5-
     6 0000006F 20D187D0B8D181D0BB-
     6 00000078 D0BE20D0BED1822030-
     6 00000081 20D0B4D0BE20363535-
     6 0000008A 333520D0B2D0BAD0BB-
     6 00000093 D18ED187D0B8D182D0-
     6 0000009C B5D0BBD18CD0BDD0BE-
     6 000000A5 3A0A00             
     7                                  linvite1 equ $-invite1
     8                                  
     9 000000A8 D092D0B2D0B5D0B4D0-     invite2 db "Введите знак операции:",0xa,0
     9 000000B1 B8D182D0B520D0B7D0-
     9 000000BA BDD0B0D0BA20D0BED0-
     9 000000C3 BFD0B5D180D0B0D186-
     9 000000CC D0B8D0B83A0A00     
    10                                  linvite2 equ $-invite2
    11                                  
    12 000000D3 D0A0D0B5D0B7D183D0-     invite3 db "Результат:",0xa,0
    12 000000DC BBD18CD182D0B0D182-
    12 000000E5 3A0A00             
    13                                  linvite3 equ $-invite3
    14                                  
    15 000000E8 D09ED181D182D0B0D1-     invite4 db "Остаток:",0xa,0
    15 000000F1 82D0BED0BA3A0A00   
    16                                  linvite4 equ $-invite4
    17                                  
    18 000000F9 D097D0BDD0B0D0BA20-     nosign db "Знак не введен!",0xa,0
    18 00000102 D0BDD0B520D0B2D0B2-
    18 0000010B D0B5D0B4D0B5D0BD21-
    18 00000114 0A00               
    19                                  lnosign equ $-nosign
    20                                  
    21 00000116 D092D0B2D0B5D0B4D0-     nocorrectvalue db "Введено некорректное значение!",0xa,0
    21 0000011F B5D0BDD0BE20D0BDD0-
    21 00000128 B5D0BAD0BED180D180-
    21 00000131 D0B5D0BAD182D0BDD0-
    21 0000013A BED0B520D0B7D0BDD0-
    21 00000143 B0D187D0B5D0BDD0B8-
    21 0000014C D0B5210A00         
    22                                  lnocorrectvalue equ $-nocorrectvalue
    23                                  
    24                                  
    25 00000151 0A                      n db 0xa                   ;переменная для переноса строки
    26                                  ln equ $-n
    27                                  
    28                                  
    29                                  SECTION .bss         ;для НЕинициализированных данных
    30                                  ;при выделении памяти лучше выделить больше чем надо, хотя бы на 1 байт
    31                                  
    32                                  ;ввод символов
    33 00000000 ????????????            value1: resb 6                              ;выделение памяти в 5 байт, где value1 - адрес первого символа
    34                                  lvalue1 equ $-value1                        ;адрес с длиной сообщения
    35                                  
    36                                  ;ввод символов
    37 00000006 ????????????            value2: resb 6                              ;выделение памяти в 5 байт, где value2 - адрес первого символа
    38                                  lvalue2 equ $-value2
    39                                  
    40                                  ;ввод знака
    41 0000000C ????                    sign: resb 2                                ;выделение памяти в 1 байт, где sign - адрес первого символа
    42                                  lsign equ $-sign
    43                                  
    44                                  ;вывод целого результата
    45 0000000E <res Ah>                output: resb 10                             ;выделение памяти в 10 байт
    46                                  loutput equ $-output                        ;адрес с длиной сообщения
    47                                  
    48                                  ;вывод остатка от деления
    49 00000018 <res Ah>                output1: resb 10                             ;выделение памяти в 10 байт
    50                                  loutput1 equ $-output1                        ;адрес с длиной сообщения
    51                                  
    52                                  SECTION .text     ;начало кода самой программы
    53                                  
    54                                  ;инструкция ret подпрограммы использует стек и регистр RSP/ESP, поэтому его не трогать!
    55                                  ;вывод записи, использование стандартных обязательных данных
    56                                  PRINT:
    57 00000000 B804000000              mov eax,4
    58 00000005 BB01000000              mov ebx,1
    59 0000000A CD80                    int 80h       ;данные из rdx копируются в rax
    60 0000000C C3                      ret
    61                                  
    62                                  ;ввод записи
    63                                  WRITE:
    64 0000000D B803000000              mov eax,3
    65 00000012 BB00000000              mov ebx,0
    66 00000017 CD80                    int 80h      ;в rax помещается 0
    67 00000019 C3                      ret
    68                                  
    69                                  GLOBAL _start
    70                                      _start:
    71                                  ;вывод приглашения ввести символы
    72 0000001A B9[00000000]            mov ecx,invite       ;ввод адреса
    73 0000001F BA54000000              mov edx,linvite      ;ввод количества символов
    74 00000024 E8D7FFFFFF              call PRINT
    75                                  
    76                                  ;ввод первого значения
    77 00000029 B9[00000000]            mov ecx,value1       ;ввод адреса
    78 0000002E BA06000000              mov edx,lvalue1    ;ввод количества символов
    79 00000033 E8D5FFFFFF              call WRITE
    80                                  
    81 00000038 B9[A8000000]            mov ecx,invite2       ;ввод адреса
    82 0000003D BA2B000000              mov edx,linvite2    ;ввод количества символов
    83 00000042 E8B9FFFFFF              call PRINT
    84                                  
    85                                  ;ввод арифметического знака
    86 00000047 B9[0C000000]            mov ecx,sign       ;ввод адреса
    87 0000004C BA02000000              mov edx,lsign    ;ввод количества символов
    88 00000051 E8B7FFFFFF              call WRITE
    89                                  
    90                                  ;вывод приглашения ввести символы
    91 00000056 B9[54000000]            mov ecx,invite1       ;ввод адреса
    92 0000005B BA54000000              mov edx,linvite1      ;ввод количества символов
    93 00000060 E89BFFFFFF              call PRINT
    94                                  
    95                                  ;ввод второго значения
    96 00000065 B9[06000000]            mov ecx,value2       ;ввод адреса
    97 0000006A BA06000000              mov edx,lvalue2    ;ввод количества символов
    98 0000006F E899FFFFFF              call WRITE
    99                                  
   100                                  ;вывод результата
   101 00000074 B9[D3000000]            mov ecx,invite3       ;ввод адреса
   102 00000079 BA15000000              mov edx,linvite3      ;ввод количества символов
   103 0000007E E87DFFFFFF              call PRINT
   104                                  
   105                                  ;переставить первое число в памяти в обратном порядке
   106                                  ;проверка на символ '-' №45 в начале строки
   107 00000083 803C25[00000000]2D      cmp byte[value1],45
   108 0000008B 0F846C030000            je incorrectvalue
   109                                  
   110 00000091 BF[00000000]            mov edi,value1   ;поместить адрес, т.е. указатель в регистр
   111 00000096 4831D2                  xor rdx,rdx        ;для счета значений
   112 00000099 4831C0                  xor rax,rax
   113 0000009C 66B90500                mov cx,5           ; счетчик
   114                                  input:
   115 000000A0 678A07                  mov al,byte[edi]    ;поместить значение в al
   116                                  ;проверка на число
   117 000000A3 3C30                    cmp al,48
   118 000000A5 7D02                    jge nextto
   119 000000A7 7C0E                    jl exitto
   120                                  nextto:
   121 000000A9 3C39                    cmp al,57
   122 000000AB 7E02                    jle inputok
   123 000000AD 7F08                    jg exitto
   124                                  inputok:
   125 000000AF 66FFC2                  inc dx
   126 000000B2 FFC7                    inc edi
   127 000000B4 50                      push rax
   128 000000B5 E2E9                    loop input
   129                                  exitto:  ;выход из цикла
   130 000000B7 89D1                    mov ecx,edx        ;счетчик
   131 000000B9 BF[00000000]            mov edi,value1     ;поместить адрес, т.е. указатель в регистр
   132                                  
   133                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   134 000000BE 83FA00                  cmp edx,0
   135 000000C1 7E08                    jle novalue
   136                                  opo:
   137 000000C3 58                      pop rax
   138 000000C4 678807                  mov byte[edi],al
   139 000000C7 FFC7                    inc edi
   140 000000C9 E2F8                    loop opo
   141                                  novalue:
   142                                  
   143                                  ;переставить второе число в памяти в обратном порядке
   144 000000CB BF[06000000]            mov edi,value2    ;поместить адрес, т.е. указатель в регистр
   145 000000D0 6631D2                  xor dx,dx            ;для счета значений
   146 000000D3 66B90500                mov cx,5              ; счетчик
   147                                  input1:
   148 000000D7 678A07                  mov al,byte[edi]       ;поместить значение в al
   149                                  ;проверка на число
   150 000000DA 3C30                    cmp al,48
   151 000000DC 7D02                    jge nextto1
   152 000000DE 7C0E                    jl exitto1
   153                                  nextto1:
   154 000000E0 3C39                    cmp al,57
   155 000000E2 7E02                    jle inputok1
   156 000000E4 7F08                    jg exitto1
   157                                  inputok1:
   158 000000E6 66FFC2                  inc dx
   159 000000E9 FFC7                    inc edi
   160 000000EB 50                      push rax
   161 000000EC E2E9                    loop input1
   162                                  exitto1:  ;выход из цикла
   163 000000EE 89D1                    mov ecx,edx        ;счетчик
   164 000000F0 BF[06000000]            mov edi,value2     ;поместить адрес, т.е. указатель в регистр
   165                                  
   166                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   167 000000F5 83FA00                  cmp edx,0
   168 000000F8 7E08                    jle novalue1
   169                                  opo1:
   170 000000FA 58                      pop rax
   171 000000FB 678807                  mov byte[edi],al
   172 000000FE FFC7                    inc edi
   173 00000100 E2F8                    loop opo1
   174                                  novalue1:
   175                                  
   176                                  ;;;;;;;;;;;
   177                                  ;поместить первое число в регистр esi, проверить его на корректность
   178                                  ;перенести его в si, сдвинуть вправо и поместить в стек
   179 00000102 31F6                    xor esi,esi         ;обнуление регистра для хранения промежуточного и итогового результата
   180 00000104 4831C0                  xor rax,rax         ;обнуление регистра
   181 00000107 31D2                    xor edx,edx         ;обнуление регистра
   182 00000109 BF[00000000]            mov edi,value1      ;поместить адрес, т.е. указатель в регистр
   183 0000010E 66BB0A00                mov bx,10         ;для хранения чисел со степенями 10
   184 00000112 678A07                  mov al,byte[edi]        ;поместить значение в ax
   185                                  ;проверка на число
   186 00000115 3C30                    cmp al,48
   187 00000117 7D02                    jge next
   188 00000119 7C55                    jl exit
   189                                  next:
   190 0000011B 3C39                    cmp al,57
   191 0000011D 7E02                    jle multi
   192 0000011F 7F4F                    jg exit
   193                                  multi:
   194 00000121 2C30                    sub al,'0'              ;получить числовое значение символа
   195 00000123 0FB6F0                  movzx esi,al           ;поместить 1-байтное значение из al в 4-байтный регистр esi
   196 00000126 FFC7                    inc edi                 ;увеличить адрес памяти на 1
   197 00000128 B903000000              mov ecx,3            ;счетчик по количеству символов
   198                                  mult:
   199 0000012D 678A07                  mov al,byte[edi]       ;поместить значение в ax
   200                                  ;проверка на число
   201 00000130 3C30                    cmp al,48
   202 00000132 7D02                    jge next1
   203 00000134 7C3A                    jl exit
   204                                  next1:
   205 00000136 3C39                    cmp al,57
   206 00000138 7E02                    jle multi1
   207 0000013A 7F34                    jg exit
   208                                  multi1:
   209 0000013C 2C30                    sub al,'0'          ;получить числовое значение символа
   210 0000013E 66F7E3                  mul bx            ;умножить ax*bx=dx ax
   211 00000141 6689C5                  mov bp,ax          ;внесение результата степени
   212 00000144 01EE                    add esi,ebp            ;добавить число к промежуточному значению
   213 00000146 B80A000000              mov eax,10            ;поместить 10 в eax
   214 0000014B 66F7E3                  mul bx               ;умножить ax*bx=dx ax, dx и ax 100.000 4 байта
   215 0000014E 6689C3                  mov bx,ax            ;поместить в bx = 100
   216 00000151 31C0                    xor eax,eax             ;обнулить eax
   217 00000153 FFC7                    inc edi              ;увеличить адрес памяти на 1
   218 00000155 E2D6                    loop mult
   219 00000157 678A07                  mov al,byte[edi]   ;поместить значение в ax
   220                                  ;проверка на число
   221 0000015A 3C30                    cmp al,48
   222 0000015C 7D02                    jge next2
   223 0000015E 7C10                    jl exit
   224                                  next2:
   225 00000160 3C39                    cmp al,57
   226 00000162 7E02                    jle multi2
   227 00000164 7F0A                    jg exit
   228                                  multi2:
   229 00000166 2C30                    sub al,'0'           ;получить числовое значение символа
   230 00000168 66F7E3                  mul bx            ;умножить ax*bx=dx ax  3*10000
   231 0000016B 6689C5                  mov bp,ax         ;внесение результата степени = 30000
   232 0000016E 01EE                    add esi,ebp         ;добавить число к промежуточному значению
   233                                  exit:
   234                                  ;;;;;;;;;;;;;;;;;;;;;;;;;
   235                                  ;проверка вводимого числа в регистре si, оно должно быть
   236                                  ;не меньше 0 и не больше 65535, которое помещается в 2-х байтном регистре
   237 00000170 81FEFFFF0000            cmp esi,65535
   238 00000176 0F8F81020000            jg incorrectvalue
   239                                  ;sub si,65536
   240                                  ;js incorrectvalue       ;если флаг знака SF=1
   241                                  ;по идее отрицательный результат операции можно проверить по флагу SF,
   242                                  ;но иногда проще проверить наличие знака '-' при вводе
   243                                  ;числа, номер символа 'минус' в ASCII №45
   244                                  
   245                                  
   246                                  ;;;;;;;;;;;;;;;;;;;;;;;
   247 0000017C C1E610                  shl esi,16      ;в связи с отсутствием свободных регистров
   248                                                  ;переносим результат для хранения в старшие 3 и 4 биты регистра esi
   249                                                  ;и тогда можно снова использовать регистр si
   250 0000017F 56                      push rsi   ;поместить значение из регистра rsi в стек
   251                                  
   252                                  ;;;;;;;;;;;
   253                                  ;проверка на символ '-' №45 в начале строки (ввод отрицательного числа)
   254 00000180 803C25[06000000]2D      cmp byte[value2],45
   255 00000188 0F846F020000            je incorrectvalue
   256                                  
   257                                  ;поместить второе число в регистр esi, проверить его на корректность
   258                                  ;перенести его в si, затем скопировать из si в di,
   259                                  ;обнулить rsi, взять данные из стека,
   260                                  ;поместить в rsi и сложить с di
   261                                  
   262 0000018E 31F6                    xor esi,esi         ;обнуление регистра для хранения промежуточного и итогового результата
   263 00000190 4831C0                  xor rax,rax         ;обнуление регистра
   264 00000193 31D2                    xor edx,edx         ;обнуление регистра
   265 00000195 BF[06000000]            mov edi,value2    ;поместить адрес, т.е. указатель в регистр
   266 0000019A 66BB0A00                mov bx,10         ;для хранения чисел со степенями 10
   267 0000019E 678A07                  mov al,byte[edi]        ;поместить значение в ax
   268                                  ;проверка на число
   269 000001A1 3C30                    cmp al,48
   270 000001A3 7D02                    jge next3
   271 000001A5 7C55                    jl exit1
   272                                  next3:
   273 000001A7 3C39                    cmp al,57
   274 000001A9 7E02                    jle multi3
   275 000001AB 7F4F                    jg exit1
   276                                  multi3:
   277 000001AD 2C30                    sub al,'0'              ;получить числовое значение символа
   278 000001AF 0FB6F0                  movzx esi,al           ;поместить 2-байтное значение из al в 2-байтный регистр si
   279 000001B2 FFC7                    inc edi                 ;увеличить адрес памяти на 1
   280 000001B4 B903000000              mov ecx,3            ;счетчик по количеству символов
   281                                  mult1:
   282 000001B9 678A07                  mov al,byte[edi]  ;поместить значение в ax
   283                                  ;проверка на число
   284 000001BC 3C30                    cmp al,48
   285 000001BE 7D02                    jge next4
   286 000001C0 7C3A                    jl exit1
   287                                  next4:
   288 000001C2 3C39                    cmp al,57
   289 000001C4 7E02                    jle multi4
   290 000001C6 7F34                    jg exit1
   291                                  multi4:
   292 000001C8 2C30                    sub al,'0'        ;получить числовое значение символа
   293 000001CA 66F7E3                  mul bx            ;умножить ax*bx=dx ax
   294 000001CD 6689C5                  mov bp,ax         ;внесение результата степени
   295 000001D0 01EE                    add esi,ebp         ;добавить число к промежуточному значению
   296 000001D2 B80A000000              mov eax,10        ;поместить 10 в eax
   297 000001D7 66F7E3                  mul bx            ;умножить ax*bx=dx ax, dx и ax 100.000 4 байта
   298 000001DA 6689C3                  mov bx,ax         ;поместить в bx = 100
   299 000001DD 31C0                    xor eax,eax       ;обнулить eax
   300 000001DF FFC7                    inc edi           ;увеличить адрес памяти на 1
   301 000001E1 E2D6                    loop mult1
   302 000001E3 678A07                  mov al,byte[edi]  ;поместить значение в ax
   303                                  ;проверка на число
   304 000001E6 3C30                    cmp al,48
   305 000001E8 7D02                    jge next5
   306 000001EA 7C10                    jl exit1
   307                                  next5:
   308 000001EC 3C39                    cmp al,57
   309 000001EE 7E02                    jle multi5
   310 000001F0 7F0A                    jg exit1
   311                                  multi5:
   312 000001F2 2C30                    sub al,'0'        ;получить числовое значение символа
   313 000001F4 66F7E3                  mul bx            ;умножить ax*bx=dx ax  3*10000
   314 000001F7 6689C5                  mov bp,ax         ;внесение результата степени = 30000
   315 000001FA 01EE                    add esi,ebp         ;добавить число к промежуточному значению
   316                                  exit1:
   317                                  
   318                                  ;поместить второе число в регистр esi, скопировать из esi в edi,
   319                                  ;проверить его на корректность
   320                                  
   321                                  ;обнулить rsi, взять данные из стека,
   322                                  ;поместить в rsi и сложить с di
   323                                  
   324                                  ;копируем для сохранения из esi в edi
   325 000001FC 89F7                    mov edi,esi
   326                                  
   327                                  ;проверка вводимого числа в регистре si, оно должно быть
   328                                  ;не меньше 0 и не больше 65535, которое помещается в 2-х байтном регистре
   329                                  ;esi указан, так как в si большее число не поместится
   330 000001FE 81FEFFFF0000            cmp esi,65535
   331 00000204 0F8FF3010000            jg incorrectvalue
   332                                  
   333 0000020A 4831F6                  xor rsi,rsi
   334 0000020D 5E                      pop rsi
   335 0000020E 6601FE                  add si,di
   336                                  
   337                                  
   338 00000211 31C0                    xor eax,eax  ;обнуление
   339 00000213 31D2                    xor edx,edx  ;обнуление
   340                                  ;;;;;;;;;;;;;;;
   341                                  
   342                                  ;содержит значение:
   343                                  ;1 байт не больше 255
   344                                  ;2 байта не больше 65535
   345                                  ;4 байта не больше 4.294.967.295
   346                                  ;8 байт не больше 1,844674407×10¹⁹
   347                                  
   348                                  ;поместить одно значение в регистр ax
   349                                  ;а второе поместить в регистр si
   350 00000215 6689F0                  mov ax,si          ;получить второе! значение
   351 00000218 C1EE10                  shr esi,16         ;передвинуть первое! значение в регистр si
   352                                  ;;;;;;;;;;;;;;;;;;;;;
   353                                  ;eax и edx- обнулены
   354                                  ;данные введены
   355                                  ;si - первое! число
   356                                  ;ax - второе! число
   357                                  ;byte[sign] - символ знака
   358 0000021B 6696                    xchg si,ax  ;меняем их местами, так как надо ax - первое , а si - второе число!!!
   359                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
   360                                  ;умножение работает
   361 0000021D 8A0C25[0C000000]        mov cl,byte[sign]   ;перевести числовое значение из byte[sign] в cl
   362 00000224 B52A                    mov ch,'*'        ;номер в регистре обычно обозначает номер символа в ASCII
   363 00000226 F6D5                    not ch              ;а затем в обратную двоичную форму
   364 00000228 84E9                    test cl,ch     ;сравнение символа и инвертированной маски
   365 0000022A 7419                    jz yesmul      ;если значения обратно сопоставимы и установился ZF=1
   366                                  
   367                                  ;деление работает
   368 0000022C 8A0C25[0C000000]        mov cl,byte[sign]   ;перевести числовое значение из byte[sign] в cl
   369 00000233 B52F                    mov ch,'/'        ;номер в регистре обычно обозначает номер символа в ASCII
   370 00000235 F6D5                    not ch              ;а затем в обратную двоичную форму
   371 00000237 84E9                    test cl,ch     ;сравнение символа и инвертированной маски
   372 00000239 0F848C000000            jz yesdiv            ;если значения обратно сопоставимы и установился ZF=1
   373                                  
   374                                  ;сложение и вычитание пока не работает
   375                                  ;test cl,'+'     ;+
   376                                  ;jz             ;если значения обратно сопоставимы и установился ZF=1
   377                                  ;test cl,'-'     ;-
   378                                  ;jz             ;если значения обратно сопоставимы и установился ZF=1
   379                                  
   380 0000023F 0F85C9010000            jnz tonosign   ;если значения обратно НЕ сопоставимы и установился ZF=0
   381                                  
   382                                  ;;;;;;;;;;;;;;;;;;
   383                                  ;операция умножения
   384                                  yesmul:
   385                                  ;выполнить операцию умножения
   386 00000245 66F7E6                  mul si             ;умножаем ax на si и результат в dx и ax
   387                                  
   388                                  ;вывод результата умножения из регистров dx ax в память output
   389                                  ;перенести результат из dx ax в память  output
   390 00000248 BF[0E000000]            mov edi,output   ;получить адрес output
   391                                  ;add edi,loutput-1  ;адрес последнего символа
   392                                  ;деление 8-и байтных значений
   393                                  ;div 4-х байтный регистр
   394                                  ;edx eax/4-х байтный регистр = eax (результат) и edx (остаток)
   395                                  ;4 байта - число не более 4.294.967.295
   396 0000024D B90A000000              mov ecx,10  ;счетчик
   397 00000252 BE0A000000              mov esi,10  ;для вывода в 10-м формате
   398                                  ;edx 0000fffe и eax 00000001 не работает деление!!!
   399                                  ;пробуем перенести значение из (e)dx в начало регистра eax
   400 00000257 C1E210                  shl edx,16     ;сдвинуть значение влево из 2-х байного dx в начало 4-х байтного регистра edx
   401 0000025A 6689C2                  mov dx,ax      ;перенести значение из ax в dx
   402 0000025D 89D0                    mov eax,edx    ;перенести полное значение из edx в eax для деления
   403 0000025F 31D2                    xor edx,edx    ;обнулить edx для деления, так как значение оттуда убрали
   404                                  again:
   405 00000261 F7F6                    div esi      ;делим на 4-х байтный регистр, так как делимое в 4-х байтном регистре
   406                                               ;eax (результат, так как делим на 4-х байтный регистр)
   407                                               ;edx (остаток, так как делим на 4-х байтный регистр)
   408                                               ;так как делим на 10, то остаток, который меньше 10 поместится в dl
   409                                  
   410 00000263 678817                  mov byte[edi],dl
   411 00000266 67800730                add byte[edi],'0'
   412 0000026A 31D2                    xor edx,edx     ;обнуляем edx, так как там есть остаток, участвующий в следующем делении
   413 0000026C FFC7                    inc edi
   414                                  
   415 0000026E 83F80A                  cmp eax,10
   416 00000271 7C04                    jl no   ;если результат <10
   417 00000273 7D00                    Jge nextend
   418                                  nextend:
   419                                  
   420 00000275 E2EA                    loop again
   421                                  no:            ;далее
   422 00000277 678807                  mov byte[edi],al
   423 0000027A 67800730                add byte[edi],'0'
   424                                  
   425                                  ;переставить числа в памяти в обратном порядке
   426 0000027E BF[0E000000]            mov edi,output    ;поместить адрес, т.е. указатель в регистр
   427 00000283 6631D2                  xor dx,dx            ;для счета значений
   428 00000286 66B90A00                mov cx,10              ; счетчик
   429                                  
   430                                  inputout:
   431 0000028A 678A07                  mov al,byte[edi]       ;поместить значение в al
   432                                  
   433                                  ;проверка на число
   434 0000028D 3C30                    cmp al,48
   435 0000028F 7D02                    jge nexttoout
   436 00000291 7C0E                    jl exittoout
   437                                  nexttoout:
   438 00000293 3C39                    cmp al,57
   439 00000295 7E02                    jle inputokout
   440 00000297 7F08                    jg exittoout
   441                                  
   442                                  inputokout:
   443 00000299 66FFC2                  inc dx
   444 0000029C FFC7                    inc edi
   445 0000029E 50                      push rax
   446 0000029F E2E9                    loop inputout
   447                                  
   448                                  exittoout:  ;выход из цикла
   449                                  
   450 000002A1 89D1                    mov ecx,edx        ;счетчик
   451 000002A3 BF[0E000000]            mov edi,output     ;поместить адрес, т.е. указатель в регистр
   452                                  
   453                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   454 000002A8 83FA00                  cmp edx,0
   455 000002AB 7E08                    jle novalue3
   456                                  opoout:
   457 000002AD 58                      pop rax
   458 000002AE 678807                  mov byte[edi],al
   459 000002B1 FFC7                    inc edi
   460 000002B3 E2F8                    loop opoout
   461                                  novalue3:
   462 000002B5 EB00                    jmp tofinish
   463                                  
   464                                  tofinish:
   465                                  ;вывод результата
   466 000002B7 B9[0E000000]            mov ecx,output       ;ввод адреса
   467 000002BC BA0A000000              mov edx,loutput     ;ввод количества символов
   468 000002C1 E83AFDFFFF              call PRINT
   469 000002C6 E954010000              jmp tomainfinish
   470                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   471                                  
   472                                  
   473                                  
   474                                  
   475                                  
   476                                  
   477                                  
   478                                  
   479                                  
   480                                  
   481                                  
   482                                  
   483                                  
   484                                  yesdiv:
   485                                  
   486                                  ;операция деления
   487                                  
   488                                  ;делимое - 1 или 2 байта
   489                                  ;делитель - 1 или 2 байта
   490                                  ;поэтому используем операцию div 2-байтный регистр
   491                                  ;DX AX / 2-байта = целое AX + остаток DX
   492                                  
   493                                  ;число si не должно равняться 0!
   494 000002CB 6683FE00                cmp si,0
   495 000002CF 0F8428010000            je incorrectvalue
   496                                  
   497 000002D5 66F7F6                  div si            ;делим dx ax на si, целое в ax остаток в dx
   498 000002D8 6689D5                  mov bp,dx        ;сдвигаем остаток в регистр bp
   499                                  ;вывод результата деления из регистра ax в память output
   500 000002DB BF[0E000000]            mov edi,output   ;получить адрес output
   501 000002E0 B905000000              mov ecx,5  ;счетчик, так как если максим число 65535/1 получится целое из 5 знаков
   502 000002E5 66BE0A00                mov si,10  ;для вывода в 10-м формате
   503 000002E9 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   504                                  
   505                                  againdiv:
   506 000002EC 66F7F6                  div si
   507 000002EF 678817                  mov byte[edi],dl   ;остаток
   508 000002F2 67800730                add byte[edi],'0'
   509 000002F6 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   510 000002F9 FFC7                    inc edi
   511 000002FB 6683F80A                cmp ax,10
   512 000002FF 7C02                    jl no1   ;если результат <10
   513 00000301 E2E9                    loop againdiv
   514                                  no1:            ;далее
   515 00000303 678807                  mov byte[edi],al
   516 00000306 67800730                add byte[edi],'0'
   517                                  
   518                                  ;переставить числа в памяти в обратном порядке
   519 0000030A BF[0E000000]            mov edi,output    ;поместить адрес, т.е. указатель в регистр
   520 0000030F 6631D2                  xor dx,dx            ;для счета значений и так пустой регистр после деления
   521 00000312 66B90500                mov cx,5             ;счетчик
   522                                  inputoutdiv:
   523 00000316 678A07                  mov al,byte[edi]
   524                                  
   525                                  ;проверка на число
   526 00000319 3C30                    cmp al,48
   527 0000031B 7D02                    jge nexttooutdiv
   528 0000031D 7C0E                    jl exittooutdiv
   529                                  nexttooutdiv:
   530 0000031F 3C39                    cmp al,57
   531 00000321 7E02                    jle inputokoutdiv
   532 00000323 7F08                    jg exittooutdiv
   533                                  
   534                                  inputokoutdiv:
   535 00000325 66FFC2                  inc dx
   536 00000328 FFC7                    inc edi
   537 0000032A 50                      push rax
   538 0000032B E2E9                    loop inputoutdiv
   539                                  exittooutdiv:  ;выход из цикла
   540                                  
   541 0000032D 6689D1                  mov cx,dx        ;счетчик
   542 00000330 BF[0E000000]            mov edi,output     ;поместить адрес, т.е. указатель в регистр 1
   543                                  
   544                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   545 00000335 6683FA00                cmp dx,0
   546 00000339 7E08                    jle novalue2
   547                                  
   548                                  opooutdiv:
   549 0000033B 58                      pop rax
   550 0000033C 678807                  mov byte[edi],al
   551 0000033F FFC7                    inc edi
   552 00000341 E2F8                    loop opooutdiv
   553                                  novalue2:
   554                                  
   555                                  ;вывод целого значения от результата
   556 00000343 B9[0E000000]            mov ecx,output       ;ввод адреса
   557 00000348 BA0A000000              mov edx,loutput     ;ввод количества символов
   558 0000034D E8AEFCFFFF              call PRINT
   559                                  
   560                                  ;переход на новую строку
   561 00000352 B9[51010000]            mov ecx,n
   562 00000357 BA01000000              mov edx,ln
   563 0000035C E89FFCFFFF              call PRINT
   564                                  
   565                                  
   566                                  ;вывод остатка от деления из регистра bx в память output1
   567 00000361 6689E8                  mov ax,bp         ;остаток от основного деления
   568 00000364 BF[18000000]            mov edi,output1   ;получить адрес output1
   569 00000369 66B90500                mov cx,5  ;счетчик, так как если максим число 65535/65534 получится целое из 5 знаков
   570 0000036D 66BE0A00                mov si,10  ;для вывода в 10-м формате
   571 00000371 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   572                                  
   573                                  againdiv1:
   574 00000374 66F7F6                  div si
   575 00000377 678817                  mov byte[edi],dl  ;остаток как и положено помещен из dl в память
   576 0000037A 67800730                add byte[edi],'0'
   577 0000037E 6631D2                  xor dx,dx    ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   578 00000381 FFC7                    inc edi
   579 00000383 6683F80A                cmp ax,10
   580 00000387 7C02                    jl no2   ;если результат <10
   581 00000389 E2E9                    loop againdiv1
   582                                  no2:            ;далее
   583 0000038B 678807                  mov byte[edi],al
   584 0000038E 67800730                add byte[edi],'0'
   585                                  
   586                                  
   587                                  
   588                                  
   589                                  
   590                                  
   591                                  ;переставить числа в памяти в обратном порядке
   592 00000392 BF[18000000]            mov edi,output1   ;поместить адрес, т.е. указатель в регистр
   593 00000397 6631D2                  xor dx,dx          ;для счета значений и так пустой регистр после деления
   594 0000039A 4831C9                  xor rcx,rcx       ;в регистре rcx остался адрес памяти
   595 0000039D 66B90500                mov cx,5             ;счетчик
   596                                  
   597                                  inputoutdiv2:
   598 000003A1 678A07                  mov al,byte[edi]
   599                                  ;проверка на число
   600 000003A4 3C30                    cmp al,48
   601 000003A6 7D02                    jge nexttooutdiv2
   602 000003A8 7C0E                    jl exittooutdiv2
   603                                  nexttooutdiv2:
   604 000003AA 3C39                    cmp al,57
   605 000003AC 7E02                    jle inputokoutdiv2
   606 000003AE 7F08                    jg exittooutdiv2
   607                                  inputokoutdiv2:
   608 000003B0 66FFC2                  inc dx
   609 000003B3 FFC7                    inc edi
   610 000003B5 50                      push rax
   611 000003B6 E2E9                    loop inputoutdiv2
   612                                  
   613                                  exittooutdiv2:  ;выход из цикла
   614                                  
   615 000003B8 6689D1                  mov cx,dx       ;счетчик
   616 000003BB BF[18000000]            mov edi,output1     ;поместить адрес, т.е. указатель в регистр 1
   617                                  
   618                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   619 000003C0 6683FA00                cmp dx,0
   620 000003C4 7E08                    jle novalue4
   621                                  
   622                                  
   623                                  opooutdiv2:
   624 000003C6 58                      pop rax
   625 000003C7 678807                  mov byte[edi],al
   626 000003CA FFC7                    inc edi
   627 000003CC E2F8                    loop opooutdiv2
   628                                  novalue4:
   629                                  
   630                                  ;вывод остатка результата
   631 000003CE B9[E8000000]            mov ecx,invite4       ;ввод адреса
   632 000003D3 BA11000000              mov edx,linvite4     ;ввод количества символов
   633 000003D8 E823FCFFFF              call PRINT
   634                                  
   635                                  ;вывод целого значения от результата
   636 000003DD B9[18000000]            mov ecx,output1       ;ввод адреса
   637 000003E2 BA0A000000              mov edx,loutput1     ;ввод количества символов
   638 000003E7 E814FCFFFF              call PRINT
   639                                  
   640                                  ;переход на новую строку
   641 000003EC B9[51010000]            mov ecx,n
   642 000003F1 BA01000000              mov edx,ln
   643 000003F6 E805FCFFFF              call PRINT
   644                                  
   645                                  ;проверить   655/  650 = ост 5
   646 000003FB EB22                    jmp tomainfinish
   647                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   648                                  ;операция сложения
   649                                  
   650                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   651                                  ;операция вычитания
   652                                  
   653                                  ;;;;;;;;;;;;;;;;;;;;;;;;;
   654                                  incorrectvalue:
   655                                  ;введено некорректное значение
   656 000003FD B9[16010000]            mov ecx,nocorrectvalue       ;ввод адреса
   657 00000402 BA3B000000              mov edx,lnocorrectvalue      ;ввод количества символов
   658 00000407 E8F4FBFFFF              call PRINT
   659 0000040C EB11                    jmp tomainfinish
   660                                  
   661                                  tonosign:
   662                                  ;знак не введен
   663 0000040E B9[F9000000]            mov ecx,nosign       ;ввод адреса
   664 00000413 BA1D000000              mov edx,lnosign      ;ввод количества символов
   665 00000418 E8E3FBFFFF              call PRINT
   666 0000041D EB00                    jmp tomainfinish
   667                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   668                                  tomainfinish:
   669                                  ;перенос строки
   670 0000041F B9[51010000]            mov ecx,n       ;ввод адреса
   671 00000424 BA01000000              mov edx,ln     ;ввод количества символов
   672 00000429 E8D2FBFFFF              call PRINT                                      ;6 выход из программы
   673                                  
   674 0000042E B801000000              mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
   675 00000433 BB00000000              mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
   676 00000438 CD80                    int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
