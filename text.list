     1                                  SECTION .data        ;для инициализированных данных
     2                                  
     3 00000000 D092D0B2D0B5D0B4D0-     invite db "Введите первое число от 0 до 65535 включительно:",0xa,0
     3 00000009 B8D182D0B520D0BFD0-
     3 00000012 B5D180D0B2D0BED0B5-
     3 0000001B 20D187D0B8D181D0BB-
     3 00000024 D0BE20D0BED1822030-
     3 0000002D 20D0B4D0BE20363535-
     3 00000036 333520D0B2D0BAD0BB-
     3 0000003F D18ED187D0B8D182D0-
     3 00000048 B5D0BBD18CD0BDD0BE-
     3 00000051 3A0A00             
     4                                  linvite equ $-invite
     5                                  
     6 00000054 D092D0B2D0B5D0B4D0-     invite1 db "Введите второе число от 0 до 65535 включительно:",0xa,0
     6 0000005D B8D182D0B520D0B2D1-
     6 00000066 82D0BED180D0BED0B5-
     6 0000006F 20D187D0B8D181D0BB-
     6 00000078 D0BE20D0BED1822030-
     6 00000081 20D0B4D0BE20363535-
     6 0000008A 333520D0B2D0BAD0BB-
     6 00000093 D18ED187D0B8D182D0-
     6 0000009C B5D0BBD18CD0BDD0BE-
     6 000000A5 3A0A00             
     7                                  linvite1 equ $-invite1
     8                                  
     9 000000A8 D092D0B2D0B5D0B4D0-     invite2 db "Введите знак операции:",0xa,0
     9 000000B1 B8D182D0B520D0B7D0-
     9 000000BA BDD0B0D0BA20D0BED0-
     9 000000C3 BFD0B5D180D0B0D186-
     9 000000CC D0B8D0B83A0A00     
    10                                  linvite2 equ $-invite2
    11                                  
    12 000000D3 D0A0D0B5D0B7D183D0-     invite3 db "Результат:",0xa,0
    12 000000DC BBD18CD182D0B0D182-
    12 000000E5 3A0A00             
    13                                  linvite3 equ $-invite3
    14                                  
    15 000000E8 D09ED181D182D0B0D1-     invite4 db "Остаток:",0xa,0
    15 000000F1 82D0BED0BA3A0A00   
    16                                  linvite4 equ $-invite4
    17                                  
    18 000000F9 D097D0BDD0B0D0BA20-     nosign db "Знак не введен!",0xa,0
    18 00000102 D0BDD0B520D0B2D0B2-
    18 0000010B D0B5D0B4D0B5D0BD21-
    18 00000114 0A00               
    19                                  lnosign equ $-nosign
    20                                  
    21 00000116 2D                      minus1 db "-"
    22                                  lminus1 equ $-minus1
    23                                  
    24 00000117 D092D0B2D0B5D0B4D0-     nocorrectvalue db "Введено некорректное значение!",0xa,0
    24 00000120 B5D0BDD0BE20D0BDD0-
    24 00000129 B5D0BAD0BED180D180-
    24 00000132 D0B5D0BAD182D0BDD0-
    24 0000013B BED0B520D0B7D0BDD0-
    24 00000144 B0D187D0B5D0BDD0B8-
    24 0000014D D0B5210A00         
    25                                  lnocorrectvalue equ $-nocorrectvalue
    26                                  
    27                                  
    28 00000152 0A                      n db 0xa                   ;переменная для переноса строки
    29                                  ln equ $-n
    30                                  
    31                                  
    32                                  SECTION .bss         ;для НЕинициализированных данных
    33                                  ;при выделении памяти лучше выделить больше чем надо, хотя бы на 1 байт
    34                                  
    35                                  ;ввод символов
    36 00000000 ????????????            value1: resb 6                              ;выделение памяти в 5 байт, где value1 - адрес первого символа
    37                                  lvalue1 equ $-value1                        ;адрес с длиной сообщения
    38                                  
    39                                  ;ввод символов
    40 00000006 ????????????            value2: resb 6                              ;выделение памяти в 5 байт, где value2 - адрес первого символа
    41                                  lvalue2 equ $-value2
    42                                  
    43                                  ;ввод знака
    44 0000000C ????                    sign: resb 2                                ;выделение памяти в 1 байт, где sign - адрес первого символа
    45                                  lsign equ $-sign
    46                                  
    47                                  ;вывод целого результата
    48 0000000E <res Ah>                output: resb 10                             ;выделение памяти в 10 байт
    49                                  loutput equ $-output                        ;адрес с длиной сообщения
    50                                  
    51                                  ;вывод остатка от деления
    52 00000018 <res Ah>                output1: resb 10                             ;выделение памяти в 10 байт
    53                                  loutput1 equ $-output1                        ;адрес с длиной сообщения
    54                                  
    55                                  SECTION .text     ;начало кода самой программы
    56                                  
    57                                  ;инструкция ret подпрограммы использует стек и регистр RSP/ESP, поэтому его не трогать!
    58                                  ;вывод записи, использование стандартных обязательных данных
    59                                  PRINT:
    60 00000000 B804000000              mov eax,4
    61 00000005 BB01000000              mov ebx,1
    62 0000000A CD80                    int 80h       ;данные из rdx копируются в rax
    63 0000000C C3                      ret
    64                                  
    65                                  ;ввод записи
    66                                  WRITE:
    67 0000000D B803000000              mov eax,3
    68 00000012 BB00000000              mov ebx,0
    69 00000017 CD80                    int 80h      ;в rax помещается 0
    70 00000019 C3                      ret
    71                                  
    72                                  GLOBAL _start
    73                                      _start:
    74                                  ;вывод приглашения ввести символы
    75 0000001A B9[00000000]            mov ecx,invite       ;ввод адреса
    76 0000001F BA54000000              mov edx,linvite      ;ввод количества символов
    77 00000024 E8D7FFFFFF              call PRINT
    78                                  
    79                                  ;ввод первого значения
    80 00000029 B9[00000000]            mov ecx,value1       ;ввод адреса
    81 0000002E BA06000000              mov edx,lvalue1    ;ввод количества символов
    82 00000033 E8D5FFFFFF              call WRITE
    83                                  
    84 00000038 B9[A8000000]            mov ecx,invite2       ;ввод адреса
    85 0000003D BA2B000000              mov edx,linvite2    ;ввод количества символов
    86 00000042 E8B9FFFFFF              call PRINT
    87                                  
    88                                  ;ввод арифметического знака
    89 00000047 B9[0C000000]            mov ecx,sign       ;ввод адреса
    90 0000004C BA02000000              mov edx,lsign    ;ввод количества символов
    91 00000051 E8B7FFFFFF              call WRITE
    92                                  
    93                                  ;вывод приглашения ввести символы
    94 00000056 B9[54000000]            mov ecx,invite1       ;ввод адреса
    95 0000005B BA54000000              mov edx,linvite1      ;ввод количества символов
    96 00000060 E89BFFFFFF              call PRINT
    97                                  
    98                                  ;ввод второго значения
    99 00000065 B9[06000000]            mov ecx,value2       ;ввод адреса
   100 0000006A BA06000000              mov edx,lvalue2    ;ввод количества символов
   101 0000006F E899FFFFFF              call WRITE
   102                                  
   103                                  ;вывод результата
   104 00000074 B9[D3000000]            mov ecx,invite3       ;ввод адреса
   105 00000079 BA15000000              mov edx,linvite3      ;ввод количества символов
   106 0000007E E87DFFFFFF              call PRINT
   107                                  
   108                                  ;переставить первое число в памяти в обратном порядке
   109                                  ;проверка на символ '-' №45 в начале строки
   110 00000083 803C25[00000000]2D      cmp byte[value1],45
   111 0000008B 0F844F050000            je incorrectvalue
   112                                  
   113 00000091 BF[00000000]            mov edi,value1   ;поместить адрес, т.е. указатель в регистр
   114 00000096 4831D2                  xor rdx,rdx        ;для счета значений
   115 00000099 4831C0                  xor rax,rax
   116 0000009C 66B90500                mov cx,5           ; счетчик
   117                                  input:
   118 000000A0 678A07                  mov al,byte[edi]    ;поместить значение в al
   119                                  ;проверка на число
   120 000000A3 3C30                    cmp al,48
   121 000000A5 7D02                    jge nextto
   122 000000A7 7C0E                    jl exitto
   123                                  nextto:
   124 000000A9 3C39                    cmp al,57
   125 000000AB 7E02                    jle inputok
   126 000000AD 7F08                    jg exitto
   127                                  inputok:
   128 000000AF 66FFC2                  inc dx
   129 000000B2 FFC7                    inc edi
   130 000000B4 50                      push rax
   131 000000B5 E2E9                    loop input
   132                                  exitto:  ;выход из цикла
   133 000000B7 89D1                    mov ecx,edx        ;счетчик
   134 000000B9 BF[00000000]            mov edi,value1     ;поместить адрес, т.е. указатель в регистр
   135                                  
   136                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   137 000000BE 83FA00                  cmp edx,0
   138 000000C1 7E08                    jle novalue
   139                                  opo:
   140 000000C3 58                      pop rax
   141 000000C4 678807                  mov byte[edi],al
   142 000000C7 FFC7                    inc edi
   143 000000C9 E2F8                    loop opo
   144                                  novalue:
   145                                  
   146                                  ;переставить второе число в памяти в обратном порядке
   147 000000CB BF[06000000]            mov edi,value2    ;поместить адрес, т.е. указатель в регистр
   148 000000D0 6631D2                  xor dx,dx            ;для счета значений
   149 000000D3 66B90500                mov cx,5              ; счетчик
   150                                  input1:
   151 000000D7 678A07                  mov al,byte[edi]       ;поместить значение в al
   152                                  ;проверка на число
   153 000000DA 3C30                    cmp al,48
   154 000000DC 7D02                    jge nextto1
   155 000000DE 7C0E                    jl exitto1
   156                                  nextto1:
   157 000000E0 3C39                    cmp al,57
   158 000000E2 7E02                    jle inputok1
   159 000000E4 7F08                    jg exitto1
   160                                  inputok1:
   161 000000E6 66FFC2                  inc dx
   162 000000E9 FFC7                    inc edi
   163 000000EB 50                      push rax
   164 000000EC E2E9                    loop input1
   165                                  exitto1:  ;выход из цикла
   166 000000EE 89D1                    mov ecx,edx        ;счетчик
   167 000000F0 BF[06000000]            mov edi,value2     ;поместить адрес, т.е. указатель в регистр
   168                                  
   169                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   170 000000F5 83FA00                  cmp edx,0
   171 000000F8 7E08                    jle novalue1
   172                                  opo1:
   173 000000FA 58                      pop rax
   174 000000FB 678807                  mov byte[edi],al
   175 000000FE FFC7                    inc edi
   176 00000100 E2F8                    loop opo1
   177                                  novalue1:
   178                                  
   179                                  ;;;;;;;;;;;
   180                                  ;поместить первое число в регистр esi, проверить его на корректность
   181                                  ;перенести его в si, сдвинуть вправо и поместить в стек
   182 00000102 31F6                    xor esi,esi         ;обнуление регистра для хранения промежуточного и итогового результата
   183 00000104 4831C0                  xor rax,rax         ;обнуление регистра
   184 00000107 31D2                    xor edx,edx         ;обнуление регистра
   185 00000109 BF[00000000]            mov edi,value1      ;поместить адрес, т.е. указатель в регистр
   186 0000010E 66BB0A00                mov bx,10         ;для хранения чисел со степенями 10
   187 00000112 678A07                  mov al,byte[edi]        ;поместить значение в ax
   188                                  ;проверка на число
   189 00000115 3C30                    cmp al,48
   190 00000117 7D02                    jge next
   191 00000119 7C55                    jl exit
   192                                  next:
   193 0000011B 3C39                    cmp al,57
   194 0000011D 7E02                    jle multi
   195 0000011F 7F4F                    jg exit
   196                                  multi:
   197 00000121 2C30                    sub al,'0'              ;получить числовое значение символа
   198 00000123 0FB6F0                  movzx esi,al           ;поместить 1-байтное значение из al в 4-байтный регистр esi
   199 00000126 FFC7                    inc edi                 ;увеличить адрес памяти на 1
   200 00000128 B903000000              mov ecx,3            ;счетчик по количеству символов
   201                                  mult:
   202 0000012D 678A07                  mov al,byte[edi]       ;поместить значение в ax
   203                                  ;проверка на число
   204 00000130 3C30                    cmp al,48
   205 00000132 7D02                    jge next1
   206 00000134 7C3A                    jl exit
   207                                  next1:
   208 00000136 3C39                    cmp al,57
   209 00000138 7E02                    jle multi1
   210 0000013A 7F34                    jg exit
   211                                  multi1:
   212 0000013C 2C30                    sub al,'0'          ;получить числовое значение символа
   213 0000013E 66F7E3                  mul bx            ;умножить ax*bx=dx ax
   214 00000141 6689C5                  mov bp,ax          ;внесение результата степени
   215 00000144 01EE                    add esi,ebp            ;добавить число к промежуточному значению
   216 00000146 B80A000000              mov eax,10            ;поместить 10 в eax
   217 0000014B 66F7E3                  mul bx               ;умножить ax*bx=dx ax, dx и ax 100.000 4 байта
   218 0000014E 6689C3                  mov bx,ax            ;поместить в bx = 100
   219 00000151 31C0                    xor eax,eax             ;обнулить eax
   220 00000153 FFC7                    inc edi              ;увеличить адрес памяти на 1
   221 00000155 E2D6                    loop mult
   222 00000157 678A07                  mov al,byte[edi]   ;поместить значение в ax
   223                                  ;проверка на число
   224 0000015A 3C30                    cmp al,48
   225 0000015C 7D02                    jge next2
   226 0000015E 7C10                    jl exit
   227                                  next2:
   228 00000160 3C39                    cmp al,57
   229 00000162 7E02                    jle multi2
   230 00000164 7F0A                    jg exit
   231                                  multi2:
   232 00000166 2C30                    sub al,'0'           ;получить числовое значение символа
   233 00000168 66F7E3                  mul bx            ;умножить ax*bx=dx ax  3*10000
   234 0000016B 6689C5                  mov bp,ax         ;внесение результата степени = 30000
   235 0000016E 01EE                    add esi,ebp         ;добавить число к промежуточному значению
   236                                  exit:
   237                                  ;;;;;;;;;;;;;;;;;;;;;;;;;
   238                                  ;проверка вводимого числа в регистре si, оно должно быть
   239                                  ;не меньше 0 и не больше 65535, которое помещается в 2-х байтном регистре
   240 00000170 81FEFFFF0000            cmp esi,65535
   241 00000176 0F8F64040000            jg incorrectvalue
   242                                  ;sub si,65536
   243                                  ;js incorrectvalue       ;если флаг знака SF=1
   244                                  ;по идее отрицательный результат операции можно проверить по флагу SF,
   245                                  ;но иногда проще проверить наличие знака '-' при вводе
   246                                  ;числа, номер символа 'минус' в ASCII №45
   247                                  
   248                                  ;;;;;;;;;;;;;;;;;;;;;;;
   249 0000017C C1E610                  shl esi,16      ;в связи с отсутствием свободных регистров
   250                                                  ;переносим результат для хранения в старшие 3 и 4 биты регистра esi
   251                                                  ;и тогда можно снова использовать регистр si
   252 0000017F 56                      push rsi   ;поместить значение из регистра rsi в стек
   253                                  
   254                                  ;;;;;;;;;;;
   255                                  ;проверка на символ '-' №45 в начале строки (ввод отрицательного числа)
   256 00000180 803C25[06000000]2D      cmp byte[value2],45
   257 00000188 0F8452040000            je incorrectvalue
   258                                  
   259                                  ;поместить второе число в регистр esi, проверить его на корректность
   260                                  ;перенести его в si, затем скопировать из si в di,
   261                                  ;обнулить rsi, взять данные из стека,
   262                                  ;поместить в rsi и сложить с di
   263                                  
   264 0000018E 31F6                    xor esi,esi         ;обнуление регистра для хранения промежуточного и итогового результата
   265 00000190 4831C0                  xor rax,rax         ;обнуление регистра
   266 00000193 31D2                    xor edx,edx         ;обнуление регистра
   267 00000195 BF[06000000]            mov edi,value2    ;поместить адрес, т.е. указатель в регистр
   268 0000019A 66BB0A00                mov bx,10         ;для хранения чисел со степенями 10
   269 0000019E 678A07                  mov al,byte[edi]        ;поместить значение в ax
   270                                  ;проверка на число
   271 000001A1 3C30                    cmp al,48
   272 000001A3 7D02                    jge next3
   273 000001A5 7C55                    jl exit1
   274                                  next3:
   275 000001A7 3C39                    cmp al,57
   276 000001A9 7E02                    jle multi3
   277 000001AB 7F4F                    jg exit1
   278                                  multi3:
   279 000001AD 2C30                    sub al,'0'              ;получить числовое значение символа
   280 000001AF 0FB6F0                  movzx esi,al           ;поместить 2-байтное значение из al в 2-байтный регистр si
   281 000001B2 FFC7                    inc edi                 ;увеличить адрес памяти на 1
   282 000001B4 B903000000              mov ecx,3            ;счетчик по количеству символов
   283                                  mult1:
   284 000001B9 678A07                  mov al,byte[edi]  ;поместить значение в ax
   285                                  ;проверка на число
   286 000001BC 3C30                    cmp al,48
   287 000001BE 7D02                    jge next4
   288 000001C0 7C3A                    jl exit1
   289                                  next4:
   290 000001C2 3C39                    cmp al,57
   291 000001C4 7E02                    jle multi4
   292 000001C6 7F34                    jg exit1
   293                                  multi4:
   294 000001C8 2C30                    sub al,'0'        ;получить числовое значение символа
   295 000001CA 66F7E3                  mul bx            ;умножить ax*bx=dx ax
   296 000001CD 6689C5                  mov bp,ax         ;внесение результата степени
   297 000001D0 01EE                    add esi,ebp         ;добавить число к промежуточному значению
   298 000001D2 B80A000000              mov eax,10        ;поместить 10 в eax
   299 000001D7 66F7E3                  mul bx            ;умножить ax*bx=dx ax, dx и ax 100.000 4 байта
   300 000001DA 6689C3                  mov bx,ax         ;поместить в bx = 100
   301 000001DD 31C0                    xor eax,eax       ;обнулить eax
   302 000001DF FFC7                    inc edi           ;увеличить адрес памяти на 1
   303 000001E1 E2D6                    loop mult1
   304 000001E3 678A07                  mov al,byte[edi]  ;поместить значение в ax
   305                                  ;проверка на число
   306 000001E6 3C30                    cmp al,48
   307 000001E8 7D02                    jge next5
   308 000001EA 7C10                    jl exit1
   309                                  next5:
   310 000001EC 3C39                    cmp al,57
   311 000001EE 7E02                    jle multi5
   312 000001F0 7F0A                    jg exit1
   313                                  multi5:
   314 000001F2 2C30                    sub al,'0'        ;получить числовое значение символа
   315 000001F4 66F7E3                  mul bx            ;умножить ax*bx=dx ax  3*10000
   316 000001F7 6689C5                  mov bp,ax         ;внесение результата степени = 30000
   317 000001FA 01EE                    add esi,ebp         ;добавить число к промежуточному значению
   318                                  exit1:
   319                                  
   320                                  ;поместить второе число в регистр esi, скопировать из esi в edi,
   321                                  ;проверить его на корректность
   322                                  
   323                                  ;обнулить rsi, взять данные из стека,
   324                                  ;поместить в rsi и сложить с di
   325                                  
   326                                  ;копируем для сохранения из esi в edi
   327 000001FC 89F7                    mov edi,esi
   328                                  
   329                                  ;проверка вводимого числа в регистре si, оно должно быть
   330                                  ;не меньше 0 и не больше 65535, которое помещается в 2-х байтном регистре
   331                                  ;esi указан, так как в si большее число не поместится
   332 000001FE 81FEFFFF0000            cmp esi,65535
   333 00000204 0F8FD6030000            jg incorrectvalue
   334                                  
   335 0000020A 4831F6                  xor rsi,rsi
   336 0000020D 5E                      pop rsi
   337 0000020E 6601FE                  add si,di
   338                                  
   339 00000211 31C0                    xor eax,eax  ;обнуление
   340 00000213 31D2                    xor edx,edx  ;обнуление
   341                                  ;;;;;;;;;;;;;;;
   342                                  
   343                                  ;содержит значение:
   344                                  ;1 байт не больше 255
   345                                  ;2 байта не больше 65535
   346                                  ;4 байта не больше 4.294.967.295
   347                                  ;8 байт не больше 1,844674407×10¹⁹
   348                                  
   349                                  ;поместить одно значение в регистр ax
   350                                  ;а второе поместить в регистр si
   351 00000215 6689F0                  mov ax,si          ;получить второе! значение
   352 00000218 C1EE10                  shr esi,16         ;передвинуть первое! значение в регистр si
   353                                  ;;;;;;;;;;;;;;;;;;;;;
   354                                  ;eax и edx- обнулены
   355                                  ;данные введены
   356                                  ;si - первое! число
   357                                  ;ax - второе! число
   358                                  ;byte[sign] - символ знака
   359 0000021B 6696                    xchg si,ax  ;меняем их местами, так как надо ax - первое , а si - второе число!!!
   360                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
   361                                  ;умножение работает
   362 0000021D 8A0C25[0C000000]        mov cl,byte[sign]   ;перевести числовое значение из byte[sign] в cl
   363 00000224 B52A                    mov ch,42 ;*        ;номер в регистре обычно обозначает номер символа в ASCII
   364 00000226 38E9                    cmp cl,ch
   365 00000228 7438                    je yesmul            ;а затем в обратную двоичную форму
   366                                  
   367                                  ;деление работает
   368 0000022A 8A0C25[0C000000]        mov cl,byte[sign]   ;перевести числовое значение из byte[sign] в cl
   369 00000231 B52F                    mov ch,47  ;/        ;номер в регистре обычно обозначает номер символа в ASCII
   370 00000233 38E9                    cmp cl,ch
   371 00000235 0F84AD000000            je yesdiv          ;а затем в обратную двоичную форму
   372                                  
   373                                  ;сложение работает
   374 0000023B 8A0C25[0C000000]        mov cl,byte[sign]   ;перевести числовое значение из byte[sign] в cl
   375 00000242 B52B                    mov ch,43   ;+        ;номер в регистре обычно обозначает номер символа в ASCII
   376 00000244 38E9                    cmp cl,ch
   377 00000246 0F84D1010000            je yesadd            ;а затем в обратную двоичную форму
   378                                  
   379                                  ;вычитание пока не работает
   380 0000024C 8A0C25[0C000000]        mov cl,byte[sign]   ;перевести числовое значение из byte[sign] в cl
   381 00000253 B52D                    mov ch,45  ;-        ;номер в регистре обычно обозначает номер символа в ASCII
   382 00000255 38E9                    cmp cl,ch
   383 00000257 0F8452020000            je yessub            ;а затем в обратную двоичную форму
   384                                  
   385 0000025D E98F030000              jmp tonosign   ;если не найдено
   386                                  
   387                                  ;;;;;;;;;;;;;;;;;;
   388                                  ;операция умножения
   389                                  yesmul:
   390                                  ;выполнить операцию умножения
   391 00000262 66F7E6                  mul si             ;умножаем ax на si и результат в dx и ax
   392                                  
   393                                  ;вывод результата умножения из регистров dx ax в память output
   394                                  ;перенести результат из dx ax в память  output
   395 00000265 BF[0E000000]            mov edi,output   ;получить адрес output
   396                                  ;add edi,loutput-1  ;адрес последнего символа
   397                                  ;деление 8-и байтных значений
   398                                  ;div 4-х байтный регистр
   399                                  ;edx eax/4-х байтный регистр = eax (результат) и edx (остаток)
   400                                  ;4 байта - число не более 4.294.967.295
   401 0000026A B90A000000              mov ecx,10  ;счетчик
   402 0000026F BE0A000000              mov esi,10  ;для вывода в 10-м формате
   403                                  ;edx 0000fffe и eax 00000001 не работает деление!!!
   404                                  ;пробуем перенести значение из (e)dx в начало регистра eax
   405 00000274 C1E210                  shl edx,16     ;сдвинуть значение влево из 2-х байного dx в начало 4-х байтного регистра edx
   406 00000277 6689C2                  mov dx,ax      ;перенести значение из ax в dx
   407 0000027A 89D0                    mov eax,edx    ;перенести полное значение из edx в eax для деления
   408 0000027C 31D2                    xor edx,edx    ;обнулить edx для деления, так как значение оттуда убрали
   409                                  again:
   410 0000027E F7F6                    div esi      ;делим на 4-х байтный регистр, так как делимое в 4-х байтном регистре
   411                                               ;eax (результат, так как делим на 4-х байтный регистр)
   412                                               ;edx (остаток, так как делим на 4-х байтный регистр)
   413                                               ;так как делим на 10, то остаток, который меньше 10 поместится в dl
   414                                  
   415 00000280 678817                  mov byte[edi],dl
   416 00000283 67800730                add byte[edi],'0'
   417 00000287 31D2                    xor edx,edx     ;обнуляем edx, так как там есть остаток, участвующий в следующем делении
   418 00000289 FFC7                    inc edi
   419                                  
   420 0000028B 83F80A                  cmp eax,10
   421 0000028E 7C04                    jl no   ;если результат <10
   422 00000290 7D00                    Jge nextend
   423                                  nextend:
   424                                  
   425 00000292 E2EA                    loop again
   426                                  no:            ;далее
   427 00000294 678807                  mov byte[edi],al
   428 00000297 67800730                add byte[edi],'0'
   429                                  
   430                                  ;переставить числа в памяти в обратном порядке
   431 0000029B BF[0E000000]            mov edi,output    ;поместить адрес, т.е. указатель в регистр
   432 000002A0 6631D2                  xor dx,dx            ;для счета значений
   433 000002A3 66B90A00                mov cx,10              ; счетчик
   434                                  
   435                                  inputout:
   436 000002A7 678A07                  mov al,byte[edi]       ;поместить значение в al
   437                                  
   438                                  ;проверка на число
   439 000002AA 3C30                    cmp al,48
   440 000002AC 7D02                    jge nexttoout
   441 000002AE 7C0E                    jl exittoout
   442                                  nexttoout:
   443 000002B0 3C39                    cmp al,57
   444 000002B2 7E02                    jle inputokout
   445 000002B4 7F08                    jg exittoout
   446                                  
   447                                  inputokout:
   448 000002B6 66FFC2                  inc dx
   449 000002B9 FFC7                    inc edi
   450 000002BB 50                      push rax
   451 000002BC E2E9                    loop inputout
   452                                  
   453                                  exittoout:  ;выход из цикла
   454                                  
   455 000002BE 89D1                    mov ecx,edx        ;счетчик
   456 000002C0 BF[0E000000]            mov edi,output     ;поместить адрес, т.е. указатель в регистр
   457                                  
   458                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   459 000002C5 83FA00                  cmp edx,0
   460 000002C8 7E08                    jle novalue3
   461                                  opoout:
   462 000002CA 58                      pop rax
   463 000002CB 678807                  mov byte[edi],al
   464 000002CE FFC7                    inc edi
   465 000002D0 E2F8                    loop opoout
   466                                  novalue3:
   467 000002D2 EB00                    jmp tofinish
   468                                  
   469                                  tofinish:
   470                                  ;вывод результата
   471 000002D4 B9[0E000000]            mov ecx,output       ;ввод адреса
   472 000002D9 BA0A000000              mov edx,loutput     ;ввод количества символов
   473 000002DE E81DFDFFFF              call PRINT
   474 000002E3 E91A030000              jmp tomainfinish
   475                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   476                                  
   477                                  yesdiv:
   478                                  
   479                                  ;операция деления
   480                                  
   481                                  ;делимое - 1 или 2 байта
   482                                  ;делитель - 1 или 2 байта
   483                                  ;поэтому используем операцию div 2-байтный регистр
   484                                  ;DX AX / 2-байта = целое AX + остаток DX
   485                                  
   486                                  ;число si не должно равняться 0!
   487 000002E8 6683FE00                cmp si,0
   488 000002EC 0F84EE020000            je incorrectvalue
   489                                  
   490 000002F2 66F7F6                  div si            ;делим dx ax на si, целое в ax остаток в dx
   491 000002F5 6689D5                  mov bp,dx        ;сдвигаем остаток в регистр bp
   492                                  ;вывод результата деления из регистра ax в память output
   493 000002F8 BF[0E000000]            mov edi,output   ;получить адрес output
   494 000002FD B905000000              mov ecx,5  ;счетчик, так как если максим число 65535/1 получится целое из 5 знаков
   495 00000302 66BE0A00                mov si,10  ;для вывода в 10-м формате
   496 00000306 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   497                                  
   498                                  againdiv:
   499 00000309 66F7F6                  div si
   500 0000030C 678817                  mov byte[edi],dl   ;остаток
   501 0000030F 67800730                add byte[edi],'0'
   502 00000313 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   503 00000316 FFC7                    inc edi
   504 00000318 6683F80A                cmp ax,10
   505 0000031C 7C02                    jl no1   ;если результат <10
   506 0000031E E2E9                    loop againdiv
   507                                  no1:            ;далее
   508 00000320 678807                  mov byte[edi],al
   509 00000323 67800730                add byte[edi],'0'
   510                                  
   511                                  ;переставить числа в памяти в обратном порядке
   512 00000327 BF[0E000000]            mov edi,output    ;поместить адрес, т.е. указатель в регистр
   513 0000032C 6631D2                  xor dx,dx            ;для счета значений и так пустой регистр после деления
   514 0000032F 66B90500                mov cx,5             ;счетчик
   515                                  inputoutdiv:
   516 00000333 678A07                  mov al,byte[edi]
   517                                  
   518                                  ;проверка на число
   519 00000336 3C30                    cmp al,48
   520 00000338 7D02                    jge nexttooutdiv
   521 0000033A 7C0E                    jl exittooutdiv
   522                                  nexttooutdiv:
   523 0000033C 3C39                    cmp al,57
   524 0000033E 7E02                    jle inputokoutdiv
   525 00000340 7F08                    jg exittooutdiv
   526                                  
   527                                  inputokoutdiv:
   528 00000342 66FFC2                  inc dx
   529 00000345 FFC7                    inc edi
   530 00000347 50                      push rax
   531 00000348 E2E9                    loop inputoutdiv
   532                                  exittooutdiv:  ;выход из цикла
   533                                  
   534 0000034A 6689D1                  mov cx,dx        ;счетчик
   535 0000034D BF[0E000000]            mov edi,output     ;поместить адрес, т.е. указатель в регистр 1
   536                                  
   537                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   538 00000352 6683FA00                cmp dx,0
   539 00000356 7E08                    jle novalue2
   540                                  
   541                                  opooutdiv:
   542 00000358 58                      pop rax
   543 00000359 678807                  mov byte[edi],al
   544 0000035C FFC7                    inc edi
   545 0000035E E2F8                    loop opooutdiv
   546                                  novalue2:
   547                                  
   548                                  ;вывод целого значения от результата
   549 00000360 B9[0E000000]            mov ecx,output       ;ввод адреса
   550 00000365 BA0A000000              mov edx,loutput     ;ввод количества символов
   551 0000036A E891FCFFFF              call PRINT
   552                                  
   553                                  ;переход на новую строку
   554 0000036F B9[52010000]            mov ecx,n
   555 00000374 BA01000000              mov edx,ln
   556 00000379 E882FCFFFF              call PRINT
   557                                  
   558                                  
   559                                  ;вывод остатка от деления из регистра bx в память output1
   560 0000037E 6689E8                  mov ax,bp         ;остаток от основного деления
   561 00000381 BF[18000000]            mov edi,output1   ;получить адрес output1
   562 00000386 66B90500                mov cx,5  ;счетчик, так как если максим число 65535/65534 получится целое из 5 знаков
   563 0000038A 66BE0A00                mov si,10  ;для вывода в 10-м формате
   564 0000038E 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   565                                  
   566                                  againdiv1:
   567 00000391 66F7F6                  div si
   568 00000394 678817                  mov byte[edi],dl  ;остаток как и положено помещен из dl в память
   569 00000397 67800730                add byte[edi],'0'
   570 0000039B 6631D2                  xor dx,dx    ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   571 0000039E FFC7                    inc edi
   572 000003A0 6683F80A                cmp ax,10
   573 000003A4 7C02                    jl no2   ;если результат <10
   574 000003A6 E2E9                    loop againdiv1
   575                                  no2:            ;далее
   576 000003A8 678807                  mov byte[edi],al
   577 000003AB 67800730                add byte[edi],'0'
   578                                  
   579                                  ;переставить числа в памяти в обратном порядке
   580 000003AF BF[18000000]            mov edi,output1   ;поместить адрес, т.е. указатель в регистр
   581 000003B4 6631D2                  xor dx,dx          ;для счета значений и так пустой регистр после деления
   582 000003B7 4831C9                  xor rcx,rcx       ;в регистре rcx остался адрес памяти
   583 000003BA 66B90500                mov cx,5             ;счетчик
   584                                  
   585                                  inputoutdiv2:
   586 000003BE 678A07                  mov al,byte[edi]
   587                                  ;проверка на число
   588 000003C1 3C30                    cmp al,48
   589 000003C3 7D02                    jge nexttooutdiv2
   590 000003C5 7C0E                    jl exittooutdiv2
   591                                  nexttooutdiv2:
   592 000003C7 3C39                    cmp al,57
   593 000003C9 7E02                    jle inputokoutdiv2
   594 000003CB 7F08                    jg exittooutdiv2
   595                                  inputokoutdiv2:
   596 000003CD 66FFC2                  inc dx
   597 000003D0 FFC7                    inc edi
   598 000003D2 50                      push rax
   599 000003D3 E2E9                    loop inputoutdiv2
   600                                  
   601                                  exittooutdiv2:  ;выход из цикла
   602                                  
   603 000003D5 6689D1                  mov cx,dx       ;счетчик
   604 000003D8 BF[18000000]            mov edi,output1     ;поместить адрес, т.е. указатель в регистр 1
   605                                  
   606                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   607 000003DD 6683FA00                cmp dx,0
   608 000003E1 7E08                    jle novalue4
   609                                  
   610                                  
   611                                  opooutdiv2:
   612 000003E3 58                      pop rax
   613 000003E4 678807                  mov byte[edi],al
   614 000003E7 FFC7                    inc edi
   615 000003E9 E2F8                    loop opooutdiv2
   616                                  novalue4:
   617                                  
   618                                  ;вывод остатка результата
   619 000003EB B9[E8000000]            mov ecx,invite4       ;ввод адреса
   620 000003F0 BA11000000              mov edx,linvite4     ;ввод количества символов
   621 000003F5 E806FCFFFF              call PRINT
   622                                  
   623                                  ;вывод целого значения от результата
   624 000003FA B9[18000000]            mov ecx,output1       ;ввод адреса
   625 000003FF BA0A000000              mov edx,loutput1     ;ввод количества символов
   626 00000404 E8F7FBFFFF              call PRINT
   627                                  
   628                                  ;переход на новую строку
   629 00000409 B9[52010000]            mov ecx,n
   630 0000040E BA01000000              mov edx,ln
   631 00000413 E8E8FBFFFF              call PRINT
   632                                  
   633 00000418 E9E5010000              jmp tomainfinish
   634                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   635                                  ;операция сложения
   636                                  yesadd:
   637 0000041D 01C6                    add esi,eax    ;сложить регистры, а результат в esi
   638 0000041F 6689F0                  mov ax,si      ;меньшие 2 байта поместить в ax
   639 00000422 C1EE10                  shr esi,16     ;сдвинуть значение в esi на 16 битов
   640 00000425 6689F2                  mov dx,si      ;старшие 2 бита от суммы esi поместить в dx
   641                                  
   642                                  ;вывод результата деления из регистра ax в память output
   643 00000428 BF[0E000000]            mov edi,output   ;получить адрес output
   644 0000042D 66B90600                mov cx,6  ;счетчик, так как если максим сумма для чисел 65535 поместится в 6 знаков
   645 00000431 66BE0A00                mov si,10  ;для вывода в 10-м формате
   646                                  
   647                                  againdiv13:
   648 00000435 66F7F6                  div si
   649 00000438 678817                  mov byte[edi],dl   ;остаток
   650 0000043B 67800730                add byte[edi],'0'
   651 0000043F 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   652 00000442 FFC7                    inc edi
   653 00000444 6683F80A                cmp ax,10
   654 00000448 7C02                    jl no13   ;если результат <10
   655 0000044A E2E9                    loop againdiv13
   656                                  no13:            ;далее
   657 0000044C 678807                  mov byte[edi],al
   658 0000044F 67800730                add byte[edi],'0'
   659                                  
   660                                  ;переставить числа в памяти в обратном порядке
   661 00000453 BF[0E000000]            mov edi,output    ;поместить адрес, т.е. указатель в регистр
   662 00000458 6631D2                  xor dx,dx            ;для счета значений и так пустой регистр после деления
   663 0000045B 66B90600                mov cx,6             ;счетчик
   664                                  inputoutdiv13:
   665 0000045F 678A07                  mov al,byte[edi]
   666                                  
   667                                  ;проверка на число
   668 00000462 3C30                    cmp al,48
   669 00000464 7D02                    jge nexttooutdiv13
   670 00000466 7C0E                    jl exittooutdiv13
   671                                  nexttooutdiv13:
   672 00000468 3C39                    cmp al,57
   673 0000046A 7E02                    jle inputokoutdiv13
   674 0000046C 7F08                    jg exittooutdiv13
   675                                  
   676                                  inputokoutdiv13:
   677 0000046E 66FFC2                  inc dx
   678 00000471 FFC7                    inc edi
   679 00000473 50                      push rax
   680 00000474 E2E9                    loop inputoutdiv13
   681                                  exittooutdiv13:  ;выход из цикла
   682                                  
   683 00000476 6689D1                  mov cx,dx        ;счетчик
   684 00000479 BF[0E000000]            mov edi,output     ;поместить адрес, т.е. указатель в регистр 1
   685                                  
   686                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   687 0000047E 6683FA00                cmp dx,0
   688 00000482 7E08                    jle novalue13
   689                                  
   690                                  opooutdiv13:
   691 00000484 58                      pop rax
   692 00000485 678807                  mov byte[edi],al
   693 00000488 FFC7                    inc edi
   694 0000048A E2F8                    loop opooutdiv13
   695                                  novalue13:
   696                                  
   697                                  
   698                                  ;вывод результата
   699 0000048C B9[0E000000]            mov ecx,output       ;ввод адреса
   700 00000491 BA0A000000              mov edx,loutput     ;ввод количества символов
   701 00000496 E865FBFFFF              call PRINT
   702                                  
   703                                  ;переход на новую строку
   704 0000049B B9[52010000]            mov ecx,n
   705 000004A0 BA01000000              mov edx,ln
   706 000004A5 E856FBFFFF              call PRINT
   707 000004AA E953010000              jmp tomainfinish
   708                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   709                                  
   710                                  
   711                                  
   712                                  
   713                                  ;операция вычитания
   714                                  yessub:
   715 000004AF 6629F0                  sub ax,si   ;высчитать из ax значение si, а результат в ax
   716 000004B2 0F83A4000000            jnc nominus    ;если нет переноса
   717 000004B8 7200                    jc minus       ;если есть перенос
   718                                  
   719                                  
   720                                  ;;;;;;;; ;;;;;;;;
   721                                  minus:
   722                                  ;перевод из положительного числа в отрицательное
   723 000004BA 6689C3                  mov bx,ax
   724 000004BD 66F7D3                  not bx
   725 000004C0 66FFC3                  inc bx
   726 000004C3 6689D8                  mov ax,bx
   727                                  ;и надо добавить в ответ знак 'минус'
   728                                  ;так как вывод идет с последнего символа, знак надо
   729                                  
   730                                  
   731                                  
   732                                  ;Вычитание выполняется с помощью команды SUB. Результат также
   733                                  ;помещается на место первого операнда и опять же выставляются флаги.
   734                                   ;Единственная разница в том, что происходит вычитание, а не сложение.
   735                                  ;На самом деле вычитание в процессоре реализовано с помощью сложения.
   736                                   ;Процессор меняет знак второго операнда на противоположный, а
   737                                   ;затем складывает два числа. Если вам необходимо в программе
   738                                   ;поменять знак числа на противоположный, можно использовать
   739                                   ;команду NEG. У этой команды всего один операнд.
   740                                  ;при вычитании и получении минусового значения
   741                                  ;флаг знака не выставляется
   742                                  ;а выставляется флаг переполнения
   743                                  ;потому что процессор складывает эти числа, а не высчитывает
   744                                  ;и если в ответе получается отрицательное число,
   745                                  ;то изменится флаг переноса CF, а не флаг знака SF!
   746                                  ;но если число сравнительно небольшое, то сработает флаг знака SF,
   747                                  ;поэтому надо ориентироваться на один из этих флагов, т.е. SF или CF
   748                                  
   749                                  ;вывод результата деления из регистра ax в память output
   750 000004C6 BF[0E000000]            mov edi,output   ;получить адрес output
   751 000004CB 66B90600                mov cx,6  ;счетчик, так как если максим сумма для чисел 65535 поместится в 6 знаков
   752 000004CF 66BE0A00                mov si,10  ;для вывода в 10-м формате
   753                                  
   754                                  againdiv15:
   755 000004D3 66F7F6                  div si
   756 000004D6 678817                  mov byte[edi],dl   ;остаток
   757 000004D9 67800730                add byte[edi],'0'
   758 000004DD 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   759 000004E0 FFC7                    inc edi
   760 000004E2 6683F80A                cmp ax,10
   761 000004E6 7C02                    jl no15   ;если результат <10
   762 000004E8 E2E9                    loop againdiv15
   763                                  no15:            ;далее
   764 000004EA 678807                  mov byte[edi],al
   765 000004ED 67800730                add byte[edi],'0'
   766                                  
   767                                  ;переставить числа в памяти в обратном порядке
   768 000004F1 BF[0E000000]            mov edi,output    ;поместить адрес, т.е. указатель в регистр
   769 000004F6 6631D2                  xor dx,dx            ;для счета значений и так пустой регистр после деления
   770 000004F9 66B90600                mov cx,6             ;счетчик
   771                                  inputoutdiv15:
   772 000004FD 678A07                  mov al,byte[edi]
   773                                  
   774                                  ;проверка на число
   775 00000500 3C30                    cmp al,48
   776 00000502 7D02                    jge nexttooutdiv15
   777 00000504 7C0E                    jl exittooutdiv15
   778                                  nexttooutdiv15:
   779 00000506 3C39                    cmp al,57
   780 00000508 7E02                    jle inputokoutdiv15
   781 0000050A 7F08                    jg exittooutdiv15
   782                                  
   783                                  inputokoutdiv15:
   784 0000050C 66FFC2                  inc dx
   785 0000050F FFC7                    inc edi
   786 00000511 50                      push rax
   787 00000512 E2E9                    loop inputoutdiv15
   788                                  exittooutdiv15:  ;выход из цикла
   789                                  
   790 00000514 6689D1                  mov cx,dx        ;счетчик
   791 00000517 BF[0E000000]            mov edi,output     ;поместить адрес, т.е. указатель в регистр 1
   792                                  
   793                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   794 0000051C 6683FA00                cmp dx,0
   795 00000520 7E08                    jle novalue15
   796                                  
   797                                  opooutdiv15:
   798 00000522 58                      pop rax
   799 00000523 678807                  mov byte[edi],al
   800 00000526 FFC7                    inc edi
   801 00000528 E2F8                    loop opooutdiv15
   802                                  novalue15:
   803                                  
   804                                  ;вывод знака '-'
   805 0000052A B9[16010000]            mov ecx,minus1       ;ввод адреса
   806 0000052F BA01000000              mov edx,lminus1     ;ввод количества символов
   807 00000534 E8C7FAFFFF              call PRINT
   808                                  
   809                                  ;вывод результата
   810 00000539 B9[0E000000]            mov ecx,output       ;ввод адреса
   811 0000053E BA0A000000              mov edx,loutput     ;ввод количества символов
   812 00000543 E8B8FAFFFF              call PRINT
   813                                  
   814                                  ;переход на новую строку
   815 00000548 B9[52010000]            mov ecx,n
   816 0000054D BA01000000              mov edx,ln
   817 00000552 E8A9FAFFFF              call PRINT
   818 00000557 E9A6000000              jmp tomainfinish
   819                                  
   820                                  
   821                                  
   822                                  
   823                                  
   824                                  
   825                                  
   826                                  
   827                                  
   828                                  
   829                                  
   830                                  
   831                                  
   832                                  
   833                                  
   834                                  
   835                                  
   836                                  
   837                                  
   838                                  
   839                                  
   840                                  
   841                                  
   842                                  
   843                                  
   844                                  
   845                                  
   846                                  
   847                                  
   848                                  
   849                                  
   850                                  
   851                                  ;;;;;;;;;;;;;;;;
   852                                  nominus:
   853                                  
   854                                  ;вывод результата деления из регистра ax в память output
   855 0000055C BF[0E000000]            mov edi,output   ;получить адрес output
   856 00000561 66B90600                mov cx,6  ;счетчик, так как если максим сумма для чисел 65535 поместится в 6 знаков
   857 00000565 66BE0A00                mov si,10  ;для вывода в 10-м формате
   858                                  
   859                                  againdiv14:
   860 00000569 66F7F6                  div si
   861 0000056C 678817                  mov byte[edi],dl   ;остаток
   862 0000056F 67800730                add byte[edi],'0'
   863 00000573 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   864 00000576 FFC7                    inc edi
   865 00000578 6683F80A                cmp ax,10
   866 0000057C 7C02                    jl no14   ;если результат <10
   867 0000057E E2E9                    loop againdiv14
   868                                  no14:            ;далее
   869 00000580 678807                  mov byte[edi],al
   870 00000583 67800730                add byte[edi],'0'
   871                                  
   872                                  ;переставить числа в памяти в обратном порядке
   873 00000587 BF[0E000000]            mov edi,output    ;поместить адрес, т.е. указатель в регистр
   874 0000058C 6631D2                  xor dx,dx            ;для счета значений и так пустой регистр после деления
   875 0000058F 66B90600                mov cx,6             ;счетчик
   876                                  inputoutdiv14:
   877 00000593 678A07                  mov al,byte[edi]
   878                                  
   879                                  ;проверка на число
   880 00000596 3C30                    cmp al,48
   881 00000598 7D02                    jge nexttooutdiv14
   882 0000059A 7C0E                    jl exittooutdiv14
   883                                  nexttooutdiv14:
   884 0000059C 3C39                    cmp al,57
   885 0000059E 7E02                    jle inputokoutdiv14
   886 000005A0 7F08                    jg exittooutdiv14
   887                                  
   888                                  inputokoutdiv14:
   889 000005A2 66FFC2                  inc dx
   890 000005A5 FFC7                    inc edi
   891 000005A7 50                      push rax
   892 000005A8 E2E9                    loop inputoutdiv14
   893                                  exittooutdiv14:  ;выход из цикла
   894                                  
   895 000005AA 6689D1                  mov cx,dx        ;счетчик
   896 000005AD BF[0E000000]            mov edi,output     ;поместить адрес, т.е. указатель в регистр 1
   897                                  
   898                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   899 000005B2 6683FA00                cmp dx,0
   900 000005B6 7E08                    jle novalue14
   901                                  
   902                                  opooutdiv14:
   903 000005B8 58                      pop rax
   904 000005B9 678807                  mov byte[edi],al
   905 000005BC FFC7                    inc edi
   906 000005BE E2F8                    loop opooutdiv14
   907                                  novalue14:
   908                                  
   909                                  
   910                                  ;вывод результата
   911 000005C0 B9[0E000000]            mov ecx,output       ;ввод адреса
   912 000005C5 BA0A000000              mov edx,loutput     ;ввод количества символов
   913 000005CA E831FAFFFF              call PRINT
   914                                  
   915                                  ;переход на новую строку
   916 000005CF B9[52010000]            mov ecx,n
   917 000005D4 BA01000000              mov edx,ln
   918 000005D9 E822FAFFFF              call PRINT
   919 000005DE EB22                    jmp tomainfinish
   920                                  
   921                                  
   922                                  
   923                                  ;;;;;;;;;;;;;;;;;;;;;;;;;
   924                                  incorrectvalue:
   925                                  ;введено некорректное значение
   926 000005E0 B9[17010000]            mov ecx,nocorrectvalue       ;ввод адреса
   927 000005E5 BA3B000000              mov edx,lnocorrectvalue      ;ввод количества символов
   928 000005EA E811FAFFFF              call PRINT
   929 000005EF EB11                    jmp tomainfinish
   930                                  
   931                                  tonosign:
   932                                  ;знак не введен
   933 000005F1 B9[F9000000]            mov ecx,nosign       ;ввод адреса
   934 000005F6 BA1D000000              mov edx,lnosign      ;ввод количества символов
   935 000005FB E800FAFFFF              call PRINT
   936 00000600 EB00                    jmp tomainfinish
   937                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   938                                  tomainfinish:
   939                                  ;перенос строки
   940 00000602 B9[52010000]            mov ecx,n       ;ввод адреса
   941 00000607 BA01000000              mov edx,ln     ;ввод количества символов
   942 0000060C E8EFF9FFFF              call PRINT                                      ;6 выход из программы
   943                                  
   944 00000611 B801000000              mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
   945 00000616 BB00000000              mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
   946 0000061B CD80                    int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
