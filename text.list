     1                                  SECTION .data        ;для инициализированных данных
     2                                  
     3 00000000 D092D0B2D0B5D0B4D0-     invite db "Введите первое число от 0 до 65535 включительно:",0xa,0
     3 00000009 B8D182D0B520D0BFD0-
     3 00000012 B5D180D0B2D0BED0B5-
     3 0000001B 20D187D0B8D181D0BB-
     3 00000024 D0BE20D0BED1822030-
     3 0000002D 20D0B4D0BE20363535-
     3 00000036 333520D0B2D0BAD0BB-
     3 0000003F D18ED187D0B8D182D0-
     3 00000048 B5D0BBD18CD0BDD0BE-
     3 00000051 3A0A00             
     4                                  linvite equ $-invite
     5                                  
     6 00000054 D092D0B2D0B5D0B4D0-     invite1 db "Введите второе число от 0 до 65535 включительно:",0xa,0
     6 0000005D B8D182D0B520D0B2D1-
     6 00000066 82D0BED180D0BED0B5-
     6 0000006F 20D187D0B8D181D0BB-
     6 00000078 D0BE20D0BED1822030-
     6 00000081 20D0B4D0BE20363535-
     6 0000008A 333520D0B2D0BAD0BB-
     6 00000093 D18ED187D0B8D182D0-
     6 0000009C B5D0BBD18CD0BDD0BE-
     6 000000A5 3A0A00             
     7                                  linvite1 equ $-invite1
     8                                  
     9 000000A8 D092D0B2D0B5D0B4D0-     invite2 db "Введите знак операции:",0xa,0
     9 000000B1 B8D182D0B520D0B7D0-
     9 000000BA BDD0B0D0BA20D0BED0-
     9 000000C3 BFD0B5D180D0B0D186-
     9 000000CC D0B8D0B83A0A00     
    10                                  linvite2 equ $-invite2
    11                                  
    12 000000D3 D0A0D0B5D0B7D183D0-     invite3 db "Результат:",0xa,0
    12 000000DC BBD18CD182D0B0D182-
    12 000000E5 3A0A00             
    13                                  linvite3 equ $-invite3
    14                                  
    15 000000E8 D09ED181D182D0B0D1-     invite4 db "Остаток:",0xa,0
    15 000000F1 82D0BED0BA3A0A00   
    16                                  linvite4 equ $-invite4
    17                                  
    18 000000F9 D097D0BDD0B0D0BA20-     nosign db "Знак не введен!",0xa,0
    18 00000102 D0BDD0B520D0B2D0B2-
    18 0000010B D0B5D0B4D0B5D0BD21-
    18 00000114 0A00               
    19                                  lnosign equ $-nosign
    20                                  
    21 00000116 2D                      minus1 db "-"
    22                                  lminus1 equ $-minus1
    23                                  
    24 00000117 D092D0B2D0B5D0B4D0-     nocorrectvalue db "Введено некорректное значение!",0xa,0
    24 00000120 B5D0BDD0BE20D0BDD0-
    24 00000129 B5D0BAD0BED180D180-
    24 00000132 D0B5D0BAD182D0BDD0-
    24 0000013B BED0B520D0B7D0BDD0-
    24 00000144 B0D187D0B5D0BDD0B8-
    24 0000014D D0B5210A00         
    25                                  lnocorrectvalue equ $-nocorrectvalue
    26                                  
    27                                  
    28 00000152 0A                      n db 0xa                   ;переменная для переноса строки
    29                                  ln equ $-n
    30                                  
    31                                  
    32                                  SECTION .bss         ;для НЕинициализированных данных
    33                                  ;при выделении памяти лучше выделить больше чем надо, хотя бы на 1 байт
    34                                  
    35                                  ;ввод символов
    36 00000000 ????????????            value1: resb 6                              ;выделение памяти в 5 байт, где value1 - адрес первого символа
    37                                  lvalue1 equ $-value1                        ;адрес с длиной сообщения
    38                                  
    39                                  ;ввод символов
    40 00000006 ????????????            value2: resb 6                              ;выделение памяти в 5 байт, где value2 - адрес первого символа
    41                                  lvalue2 equ $-value2
    42                                  
    43                                  ;ввод знака
    44 0000000C ????                    sign: resb 2                                ;выделение памяти в 1 байт, где sign - адрес первого символа
    45                                  lsign equ $-sign
    46                                  
    47                                  ;вывод целого результата
    48 0000000E <res Ah>                output: resb 10                             ;выделение памяти в 10 байт
    49                                  loutput equ $-output                        ;адрес с длиной сообщения
    50                                  
    51                                  ;вывод остатка от деления
    52 00000018 <res Ah>                output1: resb 10                             ;выделение памяти в 10 байт
    53                                  loutput1 equ $-output1                        ;адрес с длиной сообщения
    54                                  
    55                                  SECTION .text     ;начало кода самой программы
    56                                  
    57                                  ;инструкция ret подпрограммы использует стек и регистр RSP/ESP, поэтому его не трогать!
    58                                  ;вывод записи, использование стандартных обязательных данных
    59                                  PRINT:
    60 00000000 B804000000              mov eax,4
    61 00000005 BB01000000              mov ebx,1
    62 0000000A CD80                    int 80h       ;данные из rdx копируются в rax
    63 0000000C C3                      ret
    64                                  
    65                                  ;ввод записи
    66                                  WRITE:
    67 0000000D B803000000              mov eax,3
    68 00000012 BB00000000              mov ebx,0
    69 00000017 CD80                    int 80h      ;в rax помещается 0
    70 00000019 C3                      ret
    71                                  
    72                                  GLOBAL _start
    73                                      _start:
    74                                  ;вывод приглашения ввести символы
    75 0000001A B9[00000000]            mov ecx,invite       ;ввод адреса
    76 0000001F BA54000000              mov edx,linvite      ;ввод количества символов
    77 00000024 E8D7FFFFFF              call PRINT
    78                                  
    79                                  ;ввод первого значения
    80 00000029 B9[00000000]            mov ecx,value1       ;ввод адреса
    81 0000002E BA06000000              mov edx,lvalue1    ;ввод количества символов
    82 00000033 E8D5FFFFFF              call WRITE
    83                                  
    84 00000038 B9[A8000000]            mov ecx,invite2       ;ввод адреса
    85 0000003D BA2B000000              mov edx,linvite2    ;ввод количества символов
    86 00000042 E8B9FFFFFF              call PRINT
    87                                  
    88                                  ;ввод арифметического знака
    89 00000047 B9[0C000000]            mov ecx,sign       ;ввод адреса
    90 0000004C BA02000000              mov edx,lsign    ;ввод количества символов
    91 00000051 E8B7FFFFFF              call WRITE
    92                                  
    93                                  ;вывод приглашения ввести символы
    94 00000056 B9[54000000]            mov ecx,invite1       ;ввод адреса
    95 0000005B BA54000000              mov edx,linvite1      ;ввод количества символов
    96 00000060 E89BFFFFFF              call PRINT
    97                                  
    98                                  ;ввод второго значения
    99 00000065 B9[06000000]            mov ecx,value2       ;ввод адреса
   100 0000006A BA06000000              mov edx,lvalue2    ;ввод количества символов
   101 0000006F E899FFFFFF              call WRITE
   102                                  
   103                                  ;вывод результата
   104 00000074 B9[D3000000]            mov ecx,invite3       ;ввод адреса
   105 00000079 BA15000000              mov edx,linvite3      ;ввод количества символов
   106 0000007E E87DFFFFFF              call PRINT
   107                                  
   108                                  ;переставить первое число в памяти в обратном порядке
   109                                  ;проверка на символ '-' №45 в начале строки
   110 00000083 803C25[00000000]2D      cmp byte[value1],45
   111 0000008B 0F8423050000            je incorrectvalue
   112                                  
   113 00000091 BF[00000000]            mov edi,value1   ;поместить адрес, т.е. указатель в регистр
   114 00000096 4831D2                  xor rdx,rdx        ;для счета значений
   115 00000099 4831C0                  xor rax,rax
   116 0000009C 66B90500                mov cx,5           ; счетчик
   117                                  input:
   118 000000A0 678A07                  mov al,byte[edi]    ;поместить значение в al
   119                                  ;проверка на число
   120 000000A3 3C30                    cmp al,48
   121 000000A5 7D02                    jge nextto
   122 000000A7 7C0E                    jl exitto
   123                                  nextto:
   124 000000A9 3C39                    cmp al,57
   125 000000AB 7E02                    jle inputok
   126 000000AD 7F08                    jg exitto
   127                                  inputok:
   128 000000AF 66FFC2                  inc dx
   129 000000B2 FFC7                    inc edi
   130 000000B4 50                      push rax
   131 000000B5 E2E9                    loop input
   132                                  exitto:  ;выход из цикла
   133 000000B7 89D1                    mov ecx,edx        ;счетчик
   134 000000B9 BF[00000000]            mov edi,value1     ;поместить адрес, т.е. указатель в регистр
   135                                  
   136                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   137 000000BE 83FA00                  cmp edx,0
   138 000000C1 7E08                    jle novalue
   139                                  opo:
   140 000000C3 58                      pop rax
   141 000000C4 678807                  mov byte[edi],al
   142 000000C7 FFC7                    inc edi
   143 000000C9 E2F8                    loop opo
   144                                  novalue:
   145                                  
   146                                  ;переставить второе число в памяти в обратном порядке
   147 000000CB BF[06000000]            mov edi,value2    ;поместить адрес, т.е. указатель в регистр
   148 000000D0 6631D2                  xor dx,dx            ;для счета значений
   149 000000D3 66B90500                mov cx,5              ; счетчик
   150                                  input1:
   151 000000D7 678A07                  mov al,byte[edi]       ;поместить значение в al
   152                                  ;проверка на число
   153 000000DA 3C30                    cmp al,48
   154 000000DC 7D02                    jge nextto1
   155 000000DE 7C0E                    jl exitto1
   156                                  nextto1:
   157 000000E0 3C39                    cmp al,57
   158 000000E2 7E02                    jle inputok1
   159 000000E4 7F08                    jg exitto1
   160                                  inputok1:
   161 000000E6 66FFC2                  inc dx
   162 000000E9 FFC7                    inc edi
   163 000000EB 50                      push rax
   164 000000EC E2E9                    loop input1
   165                                  exitto1:  ;выход из цикла
   166 000000EE 89D1                    mov ecx,edx        ;счетчик
   167 000000F0 BF[06000000]            mov edi,value2     ;поместить адрес, т.е. указатель в регистр
   168                                  
   169                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   170 000000F5 83FA00                  cmp edx,0
   171 000000F8 7E08                    jle novalue1
   172                                  opo1:
   173 000000FA 58                      pop rax
   174 000000FB 678807                  mov byte[edi],al
   175 000000FE FFC7                    inc edi
   176 00000100 E2F8                    loop opo1
   177                                  novalue1:
   178                                  
   179                                  ;;;;;;;;;;;
   180                                  ;поместить первое число в регистр esi, проверить его на корректность
   181                                  ;перенести его в si, сдвинуть вправо и поместить в стек
   182 00000102 31F6                    xor esi,esi         ;обнуление регистра для хранения промежуточного и итогового результата
   183 00000104 4831C0                  xor rax,rax         ;обнуление регистра
   184 00000107 31D2                    xor edx,edx         ;обнуление регистра
   185 00000109 BF[00000000]            mov edi,value1      ;поместить адрес, т.е. указатель в регистр
   186 0000010E 66BB0A00                mov bx,10         ;для хранения чисел со степенями 10
   187 00000112 678A07                  mov al,byte[edi]        ;поместить значение в ax
   188                                  ;проверка на число
   189 00000115 3C30                    cmp al,48
   190 00000117 7D02                    jge next
   191 00000119 7C55                    jl exit
   192                                  next:
   193 0000011B 3C39                    cmp al,57
   194 0000011D 7E02                    jle multi
   195 0000011F 7F4F                    jg exit
   196                                  multi:
   197 00000121 2C30                    sub al,'0'              ;получить числовое значение символа
   198 00000123 0FB6F0                  movzx esi,al           ;поместить 1-байтное значение из al в 4-байтный регистр esi
   199 00000126 FFC7                    inc edi                 ;увеличить адрес памяти на 1
   200 00000128 B903000000              mov ecx,3            ;счетчик по количеству символов
   201                                  mult:
   202 0000012D 678A07                  mov al,byte[edi]       ;поместить значение в ax
   203                                  ;проверка на число
   204 00000130 3C30                    cmp al,48
   205 00000132 7D02                    jge next1
   206 00000134 7C3A                    jl exit
   207                                  next1:
   208 00000136 3C39                    cmp al,57
   209 00000138 7E02                    jle multi1
   210 0000013A 7F34                    jg exit
   211                                  multi1:
   212 0000013C 2C30                    sub al,'0'          ;получить числовое значение символа
   213 0000013E 66F7E3                  mul bx            ;умножить ax*bx=dx ax
   214 00000141 6689C5                  mov bp,ax          ;внесение результата степени
   215 00000144 01EE                    add esi,ebp            ;добавить число к промежуточному значению
   216 00000146 B80A000000              mov eax,10            ;поместить 10 в eax
   217 0000014B 66F7E3                  mul bx               ;умножить ax*bx=dx ax, dx и ax 100.000 4 байта
   218 0000014E 6689C3                  mov bx,ax            ;поместить в bx = 100
   219 00000151 31C0                    xor eax,eax             ;обнулить eax
   220 00000153 FFC7                    inc edi              ;увеличить адрес памяти на 1
   221 00000155 E2D6                    loop mult
   222 00000157 678A07                  mov al,byte[edi]   ;поместить значение в ax
   223                                  ;проверка на число
   224 0000015A 3C30                    cmp al,48
   225 0000015C 7D02                    jge next2
   226 0000015E 7C10                    jl exit
   227                                  next2:
   228 00000160 3C39                    cmp al,57
   229 00000162 7E02                    jle multi2
   230 00000164 7F0A                    jg exit
   231                                  multi2:
   232 00000166 2C30                    sub al,'0'           ;получить числовое значение символа
   233 00000168 66F7E3                  mul bx            ;умножить ax*bx=dx ax  3*10000
   234 0000016B 6689C5                  mov bp,ax         ;внесение результата степени = 30000
   235 0000016E 01EE                    add esi,ebp         ;добавить число к промежуточному значению
   236                                  exit:
   237                                  ;;;;;;;;;;;;;;;;;;;;;;;;;
   238                                  ;проверка вводимого числа в регистре si, оно должно быть
   239                                  ;не меньше 0 и не больше 65535, которое помещается в 2-х байтном регистре
   240 00000170 81FEFFFF0000            cmp esi,65535
   241 00000176 0F8F38040000            jg incorrectvalue
   242                                  ;sub si,65536
   243                                  ;js incorrectvalue       ;если флаг знака SF=1
   244                                  ;по идее отрицательный результат операции можно проверить по флагу SF,
   245                                  ;но иногда проще проверить наличие знака '-' при вводе
   246                                  ;числа, номер символа 'минус' в ASCII №45
   247                                  
   248                                  ;;;;;;;;;;;;;;;;;;;;;;;
   249 0000017C C1E610                  shl esi,16      ;в связи с отсутствием свободных регистров
   250                                                  ;переносим результат для хранения в старшие 3 и 4 биты регистра esi
   251                                                  ;и тогда можно снова использовать регистр si
   252 0000017F 56                      push rsi   ;поместить значение из регистра rsi в стек
   253                                  
   254                                  ;;;;;;;;;;;
   255                                  ;проверка на символ '-' №45 в начале строки (ввод отрицательного числа)
   256 00000180 803C25[06000000]2D      cmp byte[value2],45
   257 00000188 0F8426040000            je incorrectvalue
   258                                  
   259                                  ;поместить второе число в регистр esi, проверить его на корректность
   260                                  ;перенести его в si, затем скопировать из si в di,
   261                                  ;обнулить rsi, взять данные из стека,
   262                                  ;поместить в rsi и сложить с di
   263                                  
   264 0000018E 31F6                    xor esi,esi         ;обнуление регистра для хранения промежуточного и итогового результата
   265 00000190 4831C0                  xor rax,rax         ;обнуление регистра
   266 00000193 31D2                    xor edx,edx         ;обнуление регистра
   267 00000195 BF[06000000]            mov edi,value2    ;поместить адрес, т.е. указатель в регистр
   268 0000019A 66BB0A00                mov bx,10         ;для хранения чисел со степенями 10
   269 0000019E 678A07                  mov al,byte[edi]        ;поместить значение в ax
   270                                  ;проверка на число
   271 000001A1 3C30                    cmp al,48
   272 000001A3 7D02                    jge next3
   273 000001A5 7C55                    jl exit1
   274                                  next3:
   275 000001A7 3C39                    cmp al,57
   276 000001A9 7E02                    jle multi3
   277 000001AB 7F4F                    jg exit1
   278                                  multi3:
   279 000001AD 2C30                    sub al,'0'              ;получить числовое значение символа
   280 000001AF 0FB6F0                  movzx esi,al           ;поместить 2-байтное значение из al в 2-байтный регистр si
   281 000001B2 FFC7                    inc edi                 ;увеличить адрес памяти на 1
   282 000001B4 B903000000              mov ecx,3            ;счетчик по количеству символов
   283                                  mult1:
   284 000001B9 678A07                  mov al,byte[edi]  ;поместить значение в ax
   285                                  ;проверка на число
   286 000001BC 3C30                    cmp al,48
   287 000001BE 7D02                    jge next4
   288 000001C0 7C3A                    jl exit1
   289                                  next4:
   290 000001C2 3C39                    cmp al,57
   291 000001C4 7E02                    jle multi4
   292 000001C6 7F34                    jg exit1
   293                                  multi4:
   294 000001C8 2C30                    sub al,'0'        ;получить числовое значение символа
   295 000001CA 66F7E3                  mul bx            ;умножить ax*bx=dx ax
   296 000001CD 6689C5                  mov bp,ax         ;внесение результата степени
   297 000001D0 01EE                    add esi,ebp         ;добавить число к промежуточному значению
   298 000001D2 B80A000000              mov eax,10        ;поместить 10 в eax
   299 000001D7 66F7E3                  mul bx            ;умножить ax*bx=dx ax, dx и ax 100.000 4 байта
   300 000001DA 6689C3                  mov bx,ax         ;поместить в bx = 100
   301 000001DD 31C0                    xor eax,eax       ;обнулить eax
   302 000001DF FFC7                    inc edi           ;увеличить адрес памяти на 1
   303 000001E1 E2D6                    loop mult1
   304 000001E3 678A07                  mov al,byte[edi]  ;поместить значение в ax
   305                                  ;проверка на число
   306 000001E6 3C30                    cmp al,48
   307 000001E8 7D02                    jge next5
   308 000001EA 7C10                    jl exit1
   309                                  next5:
   310 000001EC 3C39                    cmp al,57
   311 000001EE 7E02                    jle multi5
   312 000001F0 7F0A                    jg exit1
   313                                  multi5:
   314 000001F2 2C30                    sub al,'0'        ;получить числовое значение символа
   315 000001F4 66F7E3                  mul bx            ;умножить ax*bx=dx ax  3*10000
   316 000001F7 6689C5                  mov bp,ax         ;внесение результата степени = 30000
   317 000001FA 01EE                    add esi,ebp         ;добавить число к промежуточному значению
   318                                  exit1:
   319                                  
   320                                  ;поместить второе число в регистр esi, скопировать из esi в edi,
   321                                  ;проверить его на корректность
   322                                  
   323                                  ;обнулить rsi, взять данные из стека,
   324                                  ;поместить в rsi и сложить с di
   325                                  
   326                                  ;копируем для сохранения из esi в edi
   327 000001FC 89F7                    mov edi,esi
   328                                  
   329                                  ;проверка вводимого числа в регистре si, оно должно быть
   330                                  ;не меньше 0 и не больше 65535, которое помещается в 2-х байтном регистре
   331                                  ;esi указан, так как в si большее число не поместится
   332 000001FE 81FEFFFF0000            cmp esi,65535
   333 00000204 0F8FAA030000            jg incorrectvalue
   334                                  
   335 0000020A 4831F6                  xor rsi,rsi
   336 0000020D 5E                      pop rsi
   337 0000020E 6601FE                  add si,di
   338                                  
   339 00000211 31C0                    xor eax,eax  ;обнуление
   340 00000213 31D2                    xor edx,edx  ;обнуление
   341                                  ;;;;;;;;;;;;;;;
   342                                  
   343                                  ;содержит значение:
   344                                  ;1 байт не больше 255
   345                                  ;2 байта не больше 65535
   346                                  ;4 байта не больше 4.294.967.295
   347                                  ;8 байт не больше 1,844674407×10¹⁹
   348                                  
   349                                  ;поместить одно значение в регистр ax
   350                                  ;а второе поместить в регистр si
   351 00000215 6689F0                  mov ax,si          ;получить второе! значение
   352 00000218 C1EE10                  shr esi,16         ;передвинуть первое! значение в регистр si
   353                                  ;;;;;;;;;;;;;;;;;;;;;
   354                                  ;eax и edx- обнулены
   355                                  ;данные введены
   356                                  ;si - первое! число
   357                                  ;ax - второе! число
   358                                  ;byte[sign] - символ знака
   359 0000021B 6696                    xchg si,ax  ;меняем их местами, так как надо ax - первое , а si - второе число!!!
   360                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
   361                                  ;умножение работает
   362                                  ;mov cl,byte[sign]   ;перевести числовое значение из byte[sign] в cl
   363                                  ;mov ch,'*'        ;номер в регистре обычно обозначает номер символа в ASCII
   364                                  ;not ch              ;а затем в обратную двоичную форму
   365                                  ;test cl,ch     ;сравнение символа и инвертированной маски
   366                                  ;jz yesmul      ;если значения обратно сопоставимы и установился ZF=1
   367                                  
   368                                  ;деление работает
   369                                  ;mov cl,byte[sign]   ;перевести числовое значение из byte[sign] в cl
   370                                  ;mov ch,'/'        ;номер в регистре обычно обозначает номер символа в ASCII
   371                                  ;not ch              ;а затем в обратную двоичную форму
   372                                  ;test cl,ch     ;сравнение символа и инвертированной маски
   373                                  ;jz yesdiv            ;если значения обратно сопоставимы и установился ZF=1
   374                                  
   375                                  ;сложение работает
   376                                  ;mov cl,byte[sign]   ;перевести числовое значение из byte[sign] в cl
   377                                  ;mov ch,'+'        ;номер в регистре обычно обозначает номер символа в ASCII
   378                                  ;not ch              ;а затем в обратную двоичную форму
   379                                  ;test cl,ch     ;сравнение символа и инвертированной маски
   380                                  ;jz yesadd            ;если значения обратно сопоставимы и установился ZF=1
   381                                  
   382                                  ;вычитание пока не работает
   383 0000021D 8A0C25[0C000000]        mov cl,byte[sign]   ;перевести числовое значение из byte[sign] в cl
   384 00000224 B52D                    mov ch,'-'        ;номер в регистре обычно обозначает номер символа в ASCII
   385 00000226 F6D5                    not ch              ;а затем в обратную двоичную форму
   386 00000228 84E9                    test cl,ch     ;сравнение символа и инвертированной маски
   387 0000022A 0F8453020000            jz yessub            ;если значения обратно сопоставимы и установился ZF=1
   388                                  
   389 00000230 0F858F030000            jnz tonosign   ;если значения обратно НЕ сопоставимы и установился ZF=0
   390                                  
   391                                  ;;;;;;;;;;;;;;;;;;
   392                                  ;операция умножения
   393                                  yesmul:
   394                                  ;выполнить операцию умножения
   395 00000236 66F7E6                  mul si             ;умножаем ax на si и результат в dx и ax
   396                                  
   397                                  ;вывод результата умножения из регистров dx ax в память output
   398                                  ;перенести результат из dx ax в память  output
   399 00000239 BF[0E000000]            mov edi,output   ;получить адрес output
   400                                  ;add edi,loutput-1  ;адрес последнего символа
   401                                  ;деление 8-и байтных значений
   402                                  ;div 4-х байтный регистр
   403                                  ;edx eax/4-х байтный регистр = eax (результат) и edx (остаток)
   404                                  ;4 байта - число не более 4.294.967.295
   405 0000023E B90A000000              mov ecx,10  ;счетчик
   406 00000243 BE0A000000              mov esi,10  ;для вывода в 10-м формате
   407                                  ;edx 0000fffe и eax 00000001 не работает деление!!!
   408                                  ;пробуем перенести значение из (e)dx в начало регистра eax
   409 00000248 C1E210                  shl edx,16     ;сдвинуть значение влево из 2-х байного dx в начало 4-х байтного регистра edx
   410 0000024B 6689C2                  mov dx,ax      ;перенести значение из ax в dx
   411 0000024E 89D0                    mov eax,edx    ;перенести полное значение из edx в eax для деления
   412 00000250 31D2                    xor edx,edx    ;обнулить edx для деления, так как значение оттуда убрали
   413                                  again:
   414 00000252 F7F6                    div esi      ;делим на 4-х байтный регистр, так как делимое в 4-х байтном регистре
   415                                               ;eax (результат, так как делим на 4-х байтный регистр)
   416                                               ;edx (остаток, так как делим на 4-х байтный регистр)
   417                                               ;так как делим на 10, то остаток, который меньше 10 поместится в dl
   418                                  
   419 00000254 678817                  mov byte[edi],dl
   420 00000257 67800730                add byte[edi],'0'
   421 0000025B 31D2                    xor edx,edx     ;обнуляем edx, так как там есть остаток, участвующий в следующем делении
   422 0000025D FFC7                    inc edi
   423                                  
   424 0000025F 83F80A                  cmp eax,10
   425 00000262 7C04                    jl no   ;если результат <10
   426 00000264 7D00                    Jge nextend
   427                                  nextend:
   428                                  
   429 00000266 E2EA                    loop again
   430                                  no:            ;далее
   431 00000268 678807                  mov byte[edi],al
   432 0000026B 67800730                add byte[edi],'0'
   433                                  
   434                                  ;переставить числа в памяти в обратном порядке
   435 0000026F BF[0E000000]            mov edi,output    ;поместить адрес, т.е. указатель в регистр
   436 00000274 6631D2                  xor dx,dx            ;для счета значений
   437 00000277 66B90A00                mov cx,10              ; счетчик
   438                                  
   439                                  inputout:
   440 0000027B 678A07                  mov al,byte[edi]       ;поместить значение в al
   441                                  
   442                                  ;проверка на число
   443 0000027E 3C30                    cmp al,48
   444 00000280 7D02                    jge nexttoout
   445 00000282 7C0E                    jl exittoout
   446                                  nexttoout:
   447 00000284 3C39                    cmp al,57
   448 00000286 7E02                    jle inputokout
   449 00000288 7F08                    jg exittoout
   450                                  
   451                                  inputokout:
   452 0000028A 66FFC2                  inc dx
   453 0000028D FFC7                    inc edi
   454 0000028F 50                      push rax
   455 00000290 E2E9                    loop inputout
   456                                  
   457                                  exittoout:  ;выход из цикла
   458                                  
   459 00000292 89D1                    mov ecx,edx        ;счетчик
   460 00000294 BF[0E000000]            mov edi,output     ;поместить адрес, т.е. указатель в регистр
   461                                  
   462                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   463 00000299 83FA00                  cmp edx,0
   464 0000029C 7E08                    jle novalue3
   465                                  opoout:
   466 0000029E 58                      pop rax
   467 0000029F 678807                  mov byte[edi],al
   468 000002A2 FFC7                    inc edi
   469 000002A4 E2F8                    loop opoout
   470                                  novalue3:
   471 000002A6 EB00                    jmp tofinish
   472                                  
   473                                  tofinish:
   474                                  ;вывод результата
   475 000002A8 B9[0E000000]            mov ecx,output       ;ввод адреса
   476 000002AD BA0A000000              mov edx,loutput     ;ввод количества символов
   477 000002B2 E849FDFFFF              call PRINT
   478 000002B7 E91A030000              jmp tomainfinish
   479                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   480                                  
   481                                  yesdiv:
   482                                  
   483                                  ;операция деления
   484                                  
   485                                  ;делимое - 1 или 2 байта
   486                                  ;делитель - 1 или 2 байта
   487                                  ;поэтому используем операцию div 2-байтный регистр
   488                                  ;DX AX / 2-байта = целое AX + остаток DX
   489                                  
   490                                  ;число si не должно равняться 0!
   491 000002BC 6683FE00                cmp si,0
   492 000002C0 0F84EE020000            je incorrectvalue
   493                                  
   494 000002C6 66F7F6                  div si            ;делим dx ax на si, целое в ax остаток в dx
   495 000002C9 6689D5                  mov bp,dx        ;сдвигаем остаток в регистр bp
   496                                  ;вывод результата деления из регистра ax в память output
   497 000002CC BF[0E000000]            mov edi,output   ;получить адрес output
   498 000002D1 B905000000              mov ecx,5  ;счетчик, так как если максим число 65535/1 получится целое из 5 знаков
   499 000002D6 66BE0A00                mov si,10  ;для вывода в 10-м формате
   500 000002DA 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   501                                  
   502                                  againdiv:
   503 000002DD 66F7F6                  div si
   504 000002E0 678817                  mov byte[edi],dl   ;остаток
   505 000002E3 67800730                add byte[edi],'0'
   506 000002E7 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   507 000002EA FFC7                    inc edi
   508 000002EC 6683F80A                cmp ax,10
   509 000002F0 7C02                    jl no1   ;если результат <10
   510 000002F2 E2E9                    loop againdiv
   511                                  no1:            ;далее
   512 000002F4 678807                  mov byte[edi],al
   513 000002F7 67800730                add byte[edi],'0'
   514                                  
   515                                  ;переставить числа в памяти в обратном порядке
   516 000002FB BF[0E000000]            mov edi,output    ;поместить адрес, т.е. указатель в регистр
   517 00000300 6631D2                  xor dx,dx            ;для счета значений и так пустой регистр после деления
   518 00000303 66B90500                mov cx,5             ;счетчик
   519                                  inputoutdiv:
   520 00000307 678A07                  mov al,byte[edi]
   521                                  
   522                                  ;проверка на число
   523 0000030A 3C30                    cmp al,48
   524 0000030C 7D02                    jge nexttooutdiv
   525 0000030E 7C0E                    jl exittooutdiv
   526                                  nexttooutdiv:
   527 00000310 3C39                    cmp al,57
   528 00000312 7E02                    jle inputokoutdiv
   529 00000314 7F08                    jg exittooutdiv
   530                                  
   531                                  inputokoutdiv:
   532 00000316 66FFC2                  inc dx
   533 00000319 FFC7                    inc edi
   534 0000031B 50                      push rax
   535 0000031C E2E9                    loop inputoutdiv
   536                                  exittooutdiv:  ;выход из цикла
   537                                  
   538 0000031E 6689D1                  mov cx,dx        ;счетчик
   539 00000321 BF[0E000000]            mov edi,output     ;поместить адрес, т.е. указатель в регистр 1
   540                                  
   541                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   542 00000326 6683FA00                cmp dx,0
   543 0000032A 7E08                    jle novalue2
   544                                  
   545                                  opooutdiv:
   546 0000032C 58                      pop rax
   547 0000032D 678807                  mov byte[edi],al
   548 00000330 FFC7                    inc edi
   549 00000332 E2F8                    loop opooutdiv
   550                                  novalue2:
   551                                  
   552                                  ;вывод целого значения от результата
   553 00000334 B9[0E000000]            mov ecx,output       ;ввод адреса
   554 00000339 BA0A000000              mov edx,loutput     ;ввод количества символов
   555 0000033E E8BDFCFFFF              call PRINT
   556                                  
   557                                  ;переход на новую строку
   558 00000343 B9[52010000]            mov ecx,n
   559 00000348 BA01000000              mov edx,ln
   560 0000034D E8AEFCFFFF              call PRINT
   561                                  
   562                                  
   563                                  ;вывод остатка от деления из регистра bx в память output1
   564 00000352 6689E8                  mov ax,bp         ;остаток от основного деления
   565 00000355 BF[18000000]            mov edi,output1   ;получить адрес output1
   566 0000035A 66B90500                mov cx,5  ;счетчик, так как если максим число 65535/65534 получится целое из 5 знаков
   567 0000035E 66BE0A00                mov si,10  ;для вывода в 10-м формате
   568 00000362 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   569                                  
   570                                  againdiv1:
   571 00000365 66F7F6                  div si
   572 00000368 678817                  mov byte[edi],dl  ;остаток как и положено помещен из dl в память
   573 0000036B 67800730                add byte[edi],'0'
   574 0000036F 6631D2                  xor dx,dx    ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   575 00000372 FFC7                    inc edi
   576 00000374 6683F80A                cmp ax,10
   577 00000378 7C02                    jl no2   ;если результат <10
   578 0000037A E2E9                    loop againdiv1
   579                                  no2:            ;далее
   580 0000037C 678807                  mov byte[edi],al
   581 0000037F 67800730                add byte[edi],'0'
   582                                  
   583                                  ;переставить числа в памяти в обратном порядке
   584 00000383 BF[18000000]            mov edi,output1   ;поместить адрес, т.е. указатель в регистр
   585 00000388 6631D2                  xor dx,dx          ;для счета значений и так пустой регистр после деления
   586 0000038B 4831C9                  xor rcx,rcx       ;в регистре rcx остался адрес памяти
   587 0000038E 66B90500                mov cx,5             ;счетчик
   588                                  
   589                                  inputoutdiv2:
   590 00000392 678A07                  mov al,byte[edi]
   591                                  ;проверка на число
   592 00000395 3C30                    cmp al,48
   593 00000397 7D02                    jge nexttooutdiv2
   594 00000399 7C0E                    jl exittooutdiv2
   595                                  nexttooutdiv2:
   596 0000039B 3C39                    cmp al,57
   597 0000039D 7E02                    jle inputokoutdiv2
   598 0000039F 7F08                    jg exittooutdiv2
   599                                  inputokoutdiv2:
   600 000003A1 66FFC2                  inc dx
   601 000003A4 FFC7                    inc edi
   602 000003A6 50                      push rax
   603 000003A7 E2E9                    loop inputoutdiv2
   604                                  
   605                                  exittooutdiv2:  ;выход из цикла
   606                                  
   607 000003A9 6689D1                  mov cx,dx       ;счетчик
   608 000003AC BF[18000000]            mov edi,output1     ;поместить адрес, т.е. указатель в регистр 1
   609                                  
   610                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   611 000003B1 6683FA00                cmp dx,0
   612 000003B5 7E08                    jle novalue4
   613                                  
   614                                  
   615                                  opooutdiv2:
   616 000003B7 58                      pop rax
   617 000003B8 678807                  mov byte[edi],al
   618 000003BB FFC7                    inc edi
   619 000003BD E2F8                    loop opooutdiv2
   620                                  novalue4:
   621                                  
   622                                  ;вывод остатка результата
   623 000003BF B9[E8000000]            mov ecx,invite4       ;ввод адреса
   624 000003C4 BA11000000              mov edx,linvite4     ;ввод количества символов
   625 000003C9 E832FCFFFF              call PRINT
   626                                  
   627                                  ;вывод целого значения от результата
   628 000003CE B9[18000000]            mov ecx,output1       ;ввод адреса
   629 000003D3 BA0A000000              mov edx,loutput1     ;ввод количества символов
   630 000003D8 E823FCFFFF              call PRINT
   631                                  
   632                                  ;переход на новую строку
   633 000003DD B9[52010000]            mov ecx,n
   634 000003E2 BA01000000              mov edx,ln
   635 000003E7 E814FCFFFF              call PRINT
   636                                  
   637 000003EC E9E5010000              jmp tomainfinish
   638                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   639                                  ;операция сложения
   640                                  yesadd:
   641 000003F1 01C6                    add esi,eax    ;сложить регистры, а результат в esi
   642 000003F3 6689F0                  mov ax,si      ;меньшие 2 байта поместить в ax
   643 000003F6 C1EE10                  shr esi,16     ;сдвинуть значение в esi на 16 битов
   644 000003F9 6689F2                  mov dx,si      ;старшие 2 бита от суммы esi поместить в dx
   645                                  
   646                                  ;вывод результата деления из регистра ax в память output
   647 000003FC BF[0E000000]            mov edi,output   ;получить адрес output
   648 00000401 66B90600                mov cx,6  ;счетчик, так как если максим сумма для чисел 65535 поместится в 6 знаков
   649 00000405 66BE0A00                mov si,10  ;для вывода в 10-м формате
   650                                  
   651                                  againdiv13:
   652 00000409 66F7F6                  div si
   653 0000040C 678817                  mov byte[edi],dl   ;остаток
   654 0000040F 67800730                add byte[edi],'0'
   655 00000413 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   656 00000416 FFC7                    inc edi
   657 00000418 6683F80A                cmp ax,10
   658 0000041C 7C02                    jl no13   ;если результат <10
   659 0000041E E2E9                    loop againdiv13
   660                                  no13:            ;далее
   661 00000420 678807                  mov byte[edi],al
   662 00000423 67800730                add byte[edi],'0'
   663                                  
   664                                  ;переставить числа в памяти в обратном порядке
   665 00000427 BF[0E000000]            mov edi,output    ;поместить адрес, т.е. указатель в регистр
   666 0000042C 6631D2                  xor dx,dx            ;для счета значений и так пустой регистр после деления
   667 0000042F 66B90600                mov cx,6             ;счетчик
   668                                  inputoutdiv13:
   669 00000433 678A07                  mov al,byte[edi]
   670                                  
   671                                  ;проверка на число
   672 00000436 3C30                    cmp al,48
   673 00000438 7D02                    jge nexttooutdiv13
   674 0000043A 7C0E                    jl exittooutdiv13
   675                                  nexttooutdiv13:
   676 0000043C 3C39                    cmp al,57
   677 0000043E 7E02                    jle inputokoutdiv13
   678 00000440 7F08                    jg exittooutdiv13
   679                                  
   680                                  inputokoutdiv13:
   681 00000442 66FFC2                  inc dx
   682 00000445 FFC7                    inc edi
   683 00000447 50                      push rax
   684 00000448 E2E9                    loop inputoutdiv13
   685                                  exittooutdiv13:  ;выход из цикла
   686                                  
   687 0000044A 6689D1                  mov cx,dx        ;счетчик
   688 0000044D BF[0E000000]            mov edi,output     ;поместить адрес, т.е. указатель в регистр 1
   689                                  
   690                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   691 00000452 6683FA00                cmp dx,0
   692 00000456 7E08                    jle novalue13
   693                                  
   694                                  opooutdiv13:
   695 00000458 58                      pop rax
   696 00000459 678807                  mov byte[edi],al
   697 0000045C FFC7                    inc edi
   698 0000045E E2F8                    loop opooutdiv13
   699                                  novalue13:
   700                                  
   701                                  
   702                                  ;вывод результата
   703 00000460 B9[0E000000]            mov ecx,output       ;ввод адреса
   704 00000465 BA0A000000              mov edx,loutput     ;ввод количества символов
   705 0000046A E891FBFFFF              call PRINT
   706                                  
   707                                  ;переход на новую строку
   708 0000046F B9[52010000]            mov ecx,n
   709 00000474 BA01000000              mov edx,ln
   710 00000479 E882FBFFFF              call PRINT
   711 0000047E E953010000              jmp tomainfinish
   712                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   713                                  
   714                                  
   715                                  
   716                                  
   717                                  ;операция вычитания
   718                                  yessub:
   719 00000483 6629F0                  sub ax,si   ;высчитать из ax значение si, а результат в ax
   720 00000486 0F83A4000000            jnc nominus    ;если нет переноса
   721 0000048C 7200                    jc minus       ;если есть перенос
   722                                  
   723                                  
   724                                  ;;;;;;;; ;;;;;;;;
   725                                  minus:
   726                                  ;перевод из положительного числа в отрицательное
   727 0000048E 6689C3                  mov bx,ax
   728 00000491 66F7D3                  not bx
   729 00000494 66FFC3                  inc bx
   730 00000497 6689D8                  mov ax,bx
   731                                  ;и надо добавить в ответ знак 'минус'
   732                                  ;так как вывод идет с последнего символа, знак надо
   733                                  
   734                                  
   735                                  
   736                                  ;Вычитание выполняется с помощью команды SUB. Результат также
   737                                  ;помещается на место первого операнда и опять же выставляются флаги.
   738                                   ;Единственная разница в том, что происходит вычитание, а не сложение.
   739                                  ;На самом деле вычитание в процессоре реализовано с помощью сложения.
   740                                   ;Процессор меняет знак второго операнда на противоположный, а
   741                                   ;затем складывает два числа. Если вам необходимо в программе
   742                                   ;поменять знак числа на противоположный, можно использовать
   743                                   ;команду NEG. У этой команды всего один операнд.
   744                                  ;при вычитании и получении минусового значения
   745                                  ;флаг знака не выставляется
   746                                  ;а выставляется флаг переполнения
   747                                  ;потому что процессор складывает эти числа, а не высчитывает
   748                                  ;и если в ответе получается отрицательное число,
   749                                  ;то изменится флаг переноса CF, а не флаг знака SF!
   750                                  ;но если число сравнительно небольшое, то сработает флаг знака SF,
   751                                  ;поэтому надо ориентироваться на один из этих флагов, т.е. SF или CF
   752                                  
   753                                  ;вывод результата деления из регистра ax в память output
   754 0000049A BF[0E000000]            mov edi,output   ;получить адрес output
   755 0000049F 66B90600                mov cx,6  ;счетчик, так как если максим сумма для чисел 65535 поместится в 6 знаков
   756 000004A3 66BE0A00                mov si,10  ;для вывода в 10-м формате
   757                                  
   758                                  againdiv15:
   759 000004A7 66F7F6                  div si
   760 000004AA 678817                  mov byte[edi],dl   ;остаток
   761 000004AD 67800730                add byte[edi],'0'
   762 000004B1 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   763 000004B4 FFC7                    inc edi
   764 000004B6 6683F80A                cmp ax,10
   765 000004BA 7C02                    jl no15   ;если результат <10
   766 000004BC E2E9                    loop againdiv15
   767                                  no15:            ;далее
   768 000004BE 678807                  mov byte[edi],al
   769 000004C1 67800730                add byte[edi],'0'
   770                                  
   771                                  ;переставить числа в памяти в обратном порядке
   772 000004C5 BF[0E000000]            mov edi,output    ;поместить адрес, т.е. указатель в регистр
   773 000004CA 6631D2                  xor dx,dx            ;для счета значений и так пустой регистр после деления
   774 000004CD 66B90600                mov cx,6             ;счетчик
   775                                  inputoutdiv15:
   776 000004D1 678A07                  mov al,byte[edi]
   777                                  
   778                                  ;проверка на число
   779 000004D4 3C30                    cmp al,48
   780 000004D6 7D02                    jge nexttooutdiv15
   781 000004D8 7C0E                    jl exittooutdiv15
   782                                  nexttooutdiv15:
   783 000004DA 3C39                    cmp al,57
   784 000004DC 7E02                    jle inputokoutdiv15
   785 000004DE 7F08                    jg exittooutdiv15
   786                                  
   787                                  inputokoutdiv15:
   788 000004E0 66FFC2                  inc dx
   789 000004E3 FFC7                    inc edi
   790 000004E5 50                      push rax
   791 000004E6 E2E9                    loop inputoutdiv15
   792                                  exittooutdiv15:  ;выход из цикла
   793                                  
   794 000004E8 6689D1                  mov cx,dx        ;счетчик
   795 000004EB BF[0E000000]            mov edi,output     ;поместить адрес, т.е. указатель в регистр 1
   796                                  
   797                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   798 000004F0 6683FA00                cmp dx,0
   799 000004F4 7E08                    jle novalue15
   800                                  
   801                                  opooutdiv15:
   802 000004F6 58                      pop rax
   803 000004F7 678807                  mov byte[edi],al
   804 000004FA FFC7                    inc edi
   805 000004FC E2F8                    loop opooutdiv15
   806                                  novalue15:
   807                                  
   808                                  ;вывод знака '-'
   809 000004FE B9[16010000]            mov ecx,minus1       ;ввод адреса
   810 00000503 BA01000000              mov edx,lminus1     ;ввод количества символов
   811 00000508 E8F3FAFFFF              call PRINT
   812                                  
   813                                  ;вывод результата
   814 0000050D B9[0E000000]            mov ecx,output       ;ввод адреса
   815 00000512 BA0A000000              mov edx,loutput     ;ввод количества символов
   816 00000517 E8E4FAFFFF              call PRINT
   817                                  
   818                                  ;переход на новую строку
   819 0000051C B9[52010000]            mov ecx,n
   820 00000521 BA01000000              mov edx,ln
   821 00000526 E8D5FAFFFF              call PRINT
   822 0000052B E9A6000000              jmp tomainfinish
   823                                  
   824                                  
   825                                  
   826                                  
   827                                  
   828                                  
   829                                  
   830                                  
   831                                  
   832                                  
   833                                  
   834                                  
   835                                  
   836                                  
   837                                  
   838                                  
   839                                  
   840                                  
   841                                  
   842                                  
   843                                  
   844                                  
   845                                  
   846                                  
   847                                  
   848                                  
   849                                  
   850                                  
   851                                  
   852                                  
   853                                  
   854                                  
   855                                  ;;;;;;;;;;;;;;;;
   856                                  nominus:
   857                                  
   858                                  ;вывод результата деления из регистра ax в память output
   859 00000530 BF[0E000000]            mov edi,output   ;получить адрес output
   860 00000535 66B90600                mov cx,6  ;счетчик, так как если максим сумма для чисел 65535 поместится в 6 знаков
   861 00000539 66BE0A00                mov si,10  ;для вывода в 10-м формате
   862                                  
   863                                  againdiv14:
   864 0000053D 66F7F6                  div si
   865 00000540 678817                  mov byte[edi],dl   ;остаток
   866 00000543 67800730                add byte[edi],'0'
   867 00000547 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   868 0000054A FFC7                    inc edi
   869 0000054C 6683F80A                cmp ax,10
   870 00000550 7C02                    jl no14   ;если результат <10
   871 00000552 E2E9                    loop againdiv14
   872                                  no14:            ;далее
   873 00000554 678807                  mov byte[edi],al
   874 00000557 67800730                add byte[edi],'0'
   875                                  
   876                                  ;переставить числа в памяти в обратном порядке
   877 0000055B BF[0E000000]            mov edi,output    ;поместить адрес, т.е. указатель в регистр
   878 00000560 6631D2                  xor dx,dx            ;для счета значений и так пустой регистр после деления
   879 00000563 66B90600                mov cx,6             ;счетчик
   880                                  inputoutdiv14:
   881 00000567 678A07                  mov al,byte[edi]
   882                                  
   883                                  ;проверка на число
   884 0000056A 3C30                    cmp al,48
   885 0000056C 7D02                    jge nexttooutdiv14
   886 0000056E 7C0E                    jl exittooutdiv14
   887                                  nexttooutdiv14:
   888 00000570 3C39                    cmp al,57
   889 00000572 7E02                    jle inputokoutdiv14
   890 00000574 7F08                    jg exittooutdiv14
   891                                  
   892                                  inputokoutdiv14:
   893 00000576 66FFC2                  inc dx
   894 00000579 FFC7                    inc edi
   895 0000057B 50                      push rax
   896 0000057C E2E9                    loop inputoutdiv14
   897                                  exittooutdiv14:  ;выход из цикла
   898                                  
   899 0000057E 6689D1                  mov cx,dx        ;счетчик
   900 00000581 BF[0E000000]            mov edi,output     ;поместить адрес, т.е. указатель в регистр 1
   901                                  
   902                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   903 00000586 6683FA00                cmp dx,0
   904 0000058A 7E08                    jle novalue14
   905                                  
   906                                  opooutdiv14:
   907 0000058C 58                      pop rax
   908 0000058D 678807                  mov byte[edi],al
   909 00000590 FFC7                    inc edi
   910 00000592 E2F8                    loop opooutdiv14
   911                                  novalue14:
   912                                  
   913                                  
   914                                  ;вывод результата
   915 00000594 B9[0E000000]            mov ecx,output       ;ввод адреса
   916 00000599 BA0A000000              mov edx,loutput     ;ввод количества символов
   917 0000059E E85DFAFFFF              call PRINT
   918                                  
   919                                  ;переход на новую строку
   920 000005A3 B9[52010000]            mov ecx,n
   921 000005A8 BA01000000              mov edx,ln
   922 000005AD E84EFAFFFF              call PRINT
   923 000005B2 EB22                    jmp tomainfinish
   924                                  
   925                                  
   926                                  
   927                                  ;;;;;;;;;;;;;;;;;;;;;;;;;
   928                                  incorrectvalue:
   929                                  ;введено некорректное значение
   930 000005B4 B9[17010000]            mov ecx,nocorrectvalue       ;ввод адреса
   931 000005B9 BA3B000000              mov edx,lnocorrectvalue      ;ввод количества символов
   932 000005BE E83DFAFFFF              call PRINT
   933 000005C3 EB11                    jmp tomainfinish
   934                                  
   935                                  tonosign:
   936                                  ;знак не введен
   937 000005C5 B9[F9000000]            mov ecx,nosign       ;ввод адреса
   938 000005CA BA1D000000              mov edx,lnosign      ;ввод количества символов
   939 000005CF E82CFAFFFF              call PRINT
   940 000005D4 EB00                    jmp tomainfinish
   941                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   942                                  tomainfinish:
   943                                  ;перенос строки
   944 000005D6 B9[52010000]            mov ecx,n       ;ввод адреса
   945 000005DB BA01000000              mov edx,ln     ;ввод количества символов
   946 000005E0 E81BFAFFFF              call PRINT                                      ;6 выход из программы
   947                                  
   948 000005E5 B801000000              mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
   949 000005EA BB00000000              mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
   950 000005EF CD80                    int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
