     1                                  SECTION .data        ;для инициализированных данных
     2                                  
     3 00000000 D092D0B2D0B5D0B4D0-     invite db "Введите несколько букв и цифр:",0xa,0
     3 00000009 B8D182D0B520D0BDD0-
     3 00000012 B5D181D0BAD0BED0BB-
     3 0000001B D18CD0BAD0BE20D0B1-
     3 00000024 D183D0BAD0B220D0B8-
     3 0000002D 20D186D0B8D184D180-
     3 00000036 3A0A00             
     4                                  linvite equ $-invite
     5                                  
     6 00000039 0A                      n db 0xa                   ;переменная для переноса строки
     7                                  ln equ $-n
     8                                  
     9                                  
    10                                  SECTION .bss         ;для НЕинициализированных данных
    11                                  ;ввод символов
    12 00000000 <res 64h>               input: resb 100                               ;выделение памяти в 100 байт, где input- адрес первого символа
    13                                  linput equ $-input                           ;адрес с длиной сообщения
    14                                  
    15                                  ;вывод повторяющихся символов
    16 00000064 <res 64h>               output: resb 100                              ;выделение памяти в 100 байт
    17                                  loutput equ $-output                            ;адрес с длиной сообщения
    18                                  
    19                                  ;вывод неповторяющихся символов
    20 000000C8 <res Ah>                nodub: resb 10                              ;выделение памяти в 10 байт
    21                                  lnodub equ $-nodub                            ;адрес с длиной сообщения
    22                                  
    23                                  ;вывод байтов
    24 000000D2 <res 10h>               byteout: resb 16                             ;выделение памяти в 16 байт
    25                                  lbyteout equ $-byteout                            ;адрес с длиной сообщения
    26                                  
    27                                  SECTION .text     ;начало кода самой программы
    28                                  
    29                                  ;инструкция ret подпрограммы использует стек и регистр RSP/ESP
    30                                  ;вывод записи, использование стандартных обязательных данных
    31                                  PRINT:
    32 00000000 B804000000              mov eax,4
    33 00000005 BB01000000              mov ebx,1
    34 0000000A CD80                    int 80h
    35 0000000C C3                      ret
    36                                  
    37                                  ;ввод записи
    38                                  WRITE:
    39 0000000D B803000000              mov eax,3
    40 00000012 BB00000000              mov ebx,0
    41 00000017 CD80                    int 80h
    42 00000019 C3                      ret
    43                                  
    44                                  GLOBAL _start
    45                                      _start:
    46                                                                                ;1 ввод символов в input:
    47                                  
    48                                  ;вывод приглашения ввести символы
    49 0000001A B9[00000000]            mov ecx,invite       ;ввод адреса
    50 0000001F BA39000000              mov edx,linvite      ;ввод количества символов
    51 00000024 E8D7FFFFFF              call PRINT
    52                                  
    53                                  ;ввод символов
    54 00000029 B9[00000000]            mov ecx,input       ;ввод адреса
    55 0000002E BA64000000              mov edx,linput     ;ввод количества символов
    56 00000033 E8D5FFFFFF              call WRITE
    57                                                                      ;2 проверка символов из input на цифры и ввод цифр в память output:
    58                                  
    59                                  ;поместить адрес из памяти в регистр
    60 00000038 BB[00000000]            mov ebx,input
    61 0000003D BA[64000000]            mov edx,output
    62                                  
    63                                  ;кол-во циклов для ввода найденных чисел в память output
    64 00000042 B964000000              mov ecx,linput
    65                                  
    66                                  ;следующий символ
    67                                  next:
    68                                  ;перенос значений из input в output через 1-байтный регистр al для сравнения
    69 00000047 678A03                  mov al,byte[ebx]
    70                                  ;проверяем каждый символ на совпадение с цифрой от от 0 до 9
    71                                  ;в ASCII с 48 по 57 номера цифр
    72 0000004A 3C30                    cmp al,48
    73 0000004C 7D02                    jge continue1
    74 0000004E 7C06                    jl no
    75                                  continue1:
    76 00000050 3C39                    cmp al,57
    77 00000052 7E08                    jle yes
    78 00000054 7F00                    jg no
    79                                  ;если не найдена цифра
    80                                  no:
    81                                  ;увеличение адресов на 1, т.е. получение следующей ячейки памяти
    82 00000056 FFC3                    inc ebx          ;только для адреса ввода, для вывода не надо!!! иначе память вывода расходуется впустую!!!
    83                                  ;на проверку следующего символа
    84 00000058 E2ED                    loop next
    85                                  ;при завершении цикла - на выход
    86 0000005A EB0B                    jmp exit
    87                                  ;ввод цифры в память out
    88                                  yes:
    89                                  ;перенос значений в output через 1-байтный регистр al
    90 0000005C 678802                  mov byte[edx],al
    91                                  
    92                                  ;увеличение адресов на 1, т.е. получение следующей ячейки памяти
    93 0000005F FFC3                    inc ebx
    94 00000061 FFC2                    inc edx
    95                                  
    96                                  ;на проверку следующего символа
    97 00000063 E2E2                    loop next
    98                                  ;при завершении цикла - на выход
    99 00000065 EB00                    jmp exit
   100                                  
   101                                  exit:
   102                                  ;вывод введенных символов
   103 00000067 B9[64000000]            mov ecx,output       ;ввод адреса
   104 0000006C BA64000000              mov edx,loutput      ;ввод количества символов
   105 00000071 E88AFFFFFF              call PRINT
   106                                  
   107                                  ;переход на новую строку
   108 00000076 B9[39000000]            mov ecx,n
   109 0000007B BA01000000              mov edx,ln
   110 00000080 E87BFFFFFF              call PRINT
   111                                  
   112                                              ;3 символы цифр из output сравнить и дублированные заменить любым одинаковым символом
   113                                  
   114                                  ;замена значений в памяти
   115 00000085 BF64000000              mov edi,loutput
   116 0000008A BB64000000              mov ebx,loutput
   117 0000008F BE[64000000]            mov esi,output
   118 00000094 89F5                    mov ebp,esi
   119                                  
   120 00000096 FFCF                    dec edi
   121 00000098 89F9                    mov ecx,edi
   122                                  
   123                                  two:
   124 0000009A 678A36                  mov dh,byte[esi]
   125 0000009D FFC6                    inc esi
   126                                  
   127                                  one:
   128 0000009F 673A36                  cmp dh,byte[esi]
   129 000000A2 7F04                    jg greater
   130 000000A4 7C14                    jl less
   131 000000A6 7414                    je equal
   132                                  greater:
   133                                  ;если символы кончились, то выходим
   134                                  
   135 000000A8 678A16                  mov dl,byte[esi]
   136 000000AB 67885500                mov byte[ebp],dl
   137 000000AF 678836                  mov byte[esi],dh
   138 000000B2 88D6                    mov dh,dl
   139                                  
   140                                  nextto:
   141 000000B4 FFC6                    inc esi
   142 000000B6 E2E7                    loop one
   143 000000B8 EB08                    jmp toend
   144                                  
   145                                  less:
   146 000000BA EBF8                    jmp nextto
   147                                  equal:
   148                                  
   149                                  ;при одинаковых значениях символ меняется на больший по размеру
   150                                  ;и соответственно сдвигается вправо!
   151                                  ;потом их можно отрезать и все, вместо того, чтобы циклом сдвигать все следующие значения!
   152                                  
   153 000000BC 67C6063A                mov byte[esi],58          ;замена символа на символ с номером 58
   154 000000C0 EBF2                    jmp nextto
   155                                  
   156                                  toend:
   157 000000C2 89D9                    mov ecx,ebx
   158 000000C4 FFCB                    dec ebx
   159 000000C6 FFC5                    inc ebp
   160 000000C8 89EE                    mov esi,ebp
   161 000000CA E2CE                    loop two
   162                                  
   163                                  toexit:
   164                                  
   165 000000CC B9[64000000]            mov ecx, output
   166 000000D1 BA64000000              mov edx,loutput
   167 000000D6 E825FFFFFF              call PRINT
   168                                  
   169                                  ;переход на новую строку
   170 000000DB B9[39000000]            mov ecx,n
   171 000000E0 BA01000000              mov edx,ln
   172 000000E5 E816FFFFFF              call PRINT
   173                                  
   174                                  ;Обычно ошибка сегментации segmentation fault происходит потому, что:
   175                                  ;указатель/адрес нулевой,
   176                                  ;указатель указывает на произвольный участок памяти (возможно потому, что не был инициализирован),
   177                                  ;указатель указывает на удалённый участок памяти.
   178                                  ;в качестве размера массива указана неинициализированная переменная
   179                                  
   180                                                                    ;4 выбрать только отсортированные цифры
   181                                  
   182                                  ;выбрать только цифры из output
   183                                  ;ecx - счетчик
   184 000000EA B964000000              mov ecx,loutput
   185                                  ;адрес первого символа для ввода
   186 000000EF BB[64000000]            mov ebx,output
   187                                  
   188                                  ;адрес первого символа для вывода
   189 000000F4 BA[C8000000]            mov edx,nodub
   190                                  
   191                                  again1:
   192                                  ;ввод первого символа в регистр
   193 000000F9 678A03                  mov al,byte[ebx]
   194                                  
   195                                  ;проверка на число
   196                                  ;проверяем каждый символ на совпадение с цифрой от от 0 до 9
   197                                  ;в ASCII с 48 по 57 номера цифр
   198 000000FC 3C30                    cmp al,48
   199 000000FE 7D02                    jge continue11
   200 00000100 7C06                    jl nomatch
   201                                  continue11:
   202 00000102 3C39                    cmp al,57
   203 00000104 7E08                    jle match
   204 00000106 7F00                    jg nomatch
   205                                  ;если не найдена цифра
   206                                  
   207                                  nomatch:
   208 00000108 FFC3                    inc ebx
   209 0000010A E2ED                    loop again1
   210 0000010C EB0B                    jmp away
   211                                  
   212                                  match:
   213 0000010E 678802                  mov byte[edx],al
   214 00000111 FFC3                    inc ebx      ;увеличить номер ячейки памяти ввода
   215 00000113 FFC2                    inc edx      ;увеличить номер ячейки памяти для вывода
   216 00000115 E2E2                    loop again1
   217 00000117 EB00                    jmp away
   218                                  
   219                                  away:
   220                                  
   221 00000119 B9[C8000000]            mov ecx,nodub
   222 0000011E BA0A000000              mov edx,lnodub
   223 00000123 E8D8FEFFFF              call PRINT
   224                                  
   225                                  ;переход на новую строку
   226 00000128 B9[39000000]            mov ecx,n
   227 0000012D BA01000000              mov edx,ln
   228 00000132 E8C9FEFFFF              call PRINT
   229                                  
   230                                                                           ;4 убрать дублирование и установить биты в 1
   231                                  
   232                                  ;0 - 48 или 00110000b, для поиска ставим 11001111b
   233                                  ;1 - 49 или 00110001b, для поиска ставим 11001110b и т.д.
   234                                  ;проверим каждое значение методом test
   235                                  ;сравнение символа через его номер в ASCII в 2-м формате с инвертированной маской этого номера в том же виде
   236                                  ;при замене 0 на 1 и наоборот - при операции И или TEST во флаг ZF помещается 1,  и можно осуществить переход по условию
   237                                  ;например ,если для поиска 001100b использовать 110011b, то искомый результат будет 0, а при любом другом значении - 1
   238                                  ;если совпадает
   239                                  ;jnz yes  ;ZF = 0    1 и 1 = 1, а остальные комбинации = 0
   240                                  ;если не совпадает
   241                                  ;jz   ZF = 1
   242                                  
   243                                  ;xor ax,ax                          ;задать нулевое значение для регистра ax
   244                                  ;mov rsi,0                            ;задать нулевое значение для регистра rsi, а потом перенести его в rax
   245 00000137 6631F6                  xor si,si                            ;обнулить регистр
   246 0000013A BB[C8000000]            mov ebx,nodub        ;адрес первой ячейки nodub
   247 0000013F B90A000000              mov ecx,lnodub      ;счетчик по количеству символов в строке (10)
   248                                  
   249                                  ;попробовать ввести в память символы, какие-либо символы, не числа! может тогда '0' не будет в памяти
   250                                  toshift:
   251                                  
   252 00000144 678A13                  mov dl,byte[ebx]   ;значение по адресу ebx
   253                                  
   254 00000147 B630                    mov dh,'0'        ;номер в регистре обычно обозначает номер символа в ASCII
   255 00000149 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   256 0000014B 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   257 0000014D 7448                    jz match0
   258                                  
   259 0000014F B631                    mov dh,'1'        ;номер в регистре обычно обозначает номер символа в ASCII
   260 00000151 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   261 00000153 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   262 00000155 7446                    jz match1
   263                                  
   264 00000157 B632                    mov dh,'2'        ;номер в регистре обычно обозначает номер символа в ASCII
   265 00000159 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   266 0000015B 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   267 0000015D 7444                    jz match2
   268                                  
   269 0000015F B633                    mov dh,'3'        ;номер в регистре обычно обозначает номер символа в ASCII
   270 00000161 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   271 00000163 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   272 00000165 7442                    jz match3
   273                                  
   274 00000167 B634                    mov dh,'4'        ;номер в регистре обычно обозначает номер символа в ASCII
   275 00000169 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   276 0000016B 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   277 0000016D 7440                    jz match4
   278                                  
   279 0000016F B635                    mov dh,'5'        ;номер в регистре обычно обозначает номер символа в ASCII
   280 00000171 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   281 00000173 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   282 00000175 743E                    jz match5
   283                                  
   284 00000177 B636                    mov dh,'6'        ;номер в регистре обычно обозначает номер символа в ASCII
   285 00000179 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   286 0000017B 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   287 0000017D 743C                    jz match6
   288                                  
   289 0000017F B637                    mov dh,'7'        ;номер в регистре обычно обозначает номер символа в ASCII
   290 00000181 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   291 00000183 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   292 00000185 743A                    jz match7
   293                                  
   294 00000187 B638                    mov dh,'8'        ;номер в регистре обычно обозначает номер символа в ASCII
   295 00000189 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   296 0000018B 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   297 0000018D 7439                    jz match8
   298                                  
   299 0000018F B639                    mov dh,'9'        ;номер в регистре обычно обозначает номер символа в ASCII
   300 00000191 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   301 00000193 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   302 00000195 7438                    jz match9
   303                                  
   304                                  
   305                                  
   306                                  
   307                                  ;or si,1 - это не срабатывает никогда
   308                                  match0:    ;это срабатывает при любых условиях, т.е. символ 0 всегда есть в dl,byte[ebx] или dh
   309                                            ;если в памяти остаются свободные ячейки они автоматически заполняются символом '0'
   310                                            ;поэтому этот символ программа находит в памяти!!!
   311                                  ;or ax,0000000000000001b
   312 00000197 6683CE01                or si,1
   313 0000019B EB39                    jmp again3
   314                                  
   315                                  match1:
   316                                  ;or ax,0000000000000010b
   317 0000019D 6683CE02                or si,2
   318 000001A1 EB33                    jmp again3
   319                                  
   320                                  match2:
   321                                  ;or ax,0000000000000100b
   322 000001A3 6683CE04                or si,4
   323 000001A7 EB2D                    jmp again3
   324                                  
   325                                  match3:
   326                                  ;or ax,0000000000001000b
   327 000001A9 6683CE08                or si,8
   328 000001AD EB27                    jmp again3
   329                                  
   330                                  match4:
   331                                  ;or ax,0000000000010000b
   332 000001AF 6683CE10                or si,16
   333 000001B3 EB21                    jmp again3
   334                                  
   335                                  match5:
   336                                  ;or ax,0000000000100000b
   337 000001B5 6683CE20                or si,32
   338 000001B9 EB1B                    jmp again3
   339                                  
   340                                  match6:
   341                                  ;or ax,0000000001000000b
   342 000001BB 6683CE40                or si,64
   343 000001BF EB15                    jmp again3
   344                                  
   345                                  match7:
   346                                  ;or ax,0000000001000000b
   347 000001C1 6681CE8000              or si,128
   348 000001C6 EB0E                    jmp again3
   349                                  
   350                                  match8:
   351                                  ;or ax,0000000100000000b
   352 000001C8 6681CE0001              or si,256
   353 000001CD EB07                    jmp again3
   354                                  
   355                                  match9:
   356                                  ;or ax,0000001000000000b
   357 000001CF 6681CE0002              or si,512 ;512 - не работает Floating point exception (core dumped) 511- работает,а 512 уже нет
   358                                  
   359                                                                                  ;510 и 511 = 0000000111111111
   360                                                          ;возможно проблема с делением
   361                                                          ;результат помещается в ah и al - по 8 байтов
   362                                                          ;макс.значение каждого до 255 или 11111111
   363                                                          ;и если 512/2 получится 256, а оно не помещается в регистр al
   364 000001D4 EB00                    jmp again3
   365                                  
   366                                  
   367                                  again3:
   368 000001D6 FFC3                    inc ebx            ;увеличить номер ячейки
   369                                  ;если loop toshift не срабатывает из-за длинного кода
   370                                  ;можно использовать следующий код:
   371 000001D8 FFC9                    dec ecx
   372 000001DA 0F8564FFFFFF            jnz toshift
   373                                  
   374                                  
   375 000001E0 BF[D2000000]            mov edi,byteout     ;указать адрес первого элемента
   376 000001E5 83C70F                  add edi,lbyteout-1   ;увеличить номер ячейки памяти на lbyteout-1
   377                                  ;номера памяти 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
   378                                  ;первый номер 0+16-1=15
   379                                  
   380                                  ;всегда в бите №0 выходит значение 1
   381                                  ;и по умолчанию и по указанию
   382                                  ;причина- не все ячейки памяти заполнены значениями
   383                                  ;и если в памяти остается хоть одна пустая ячейка, то в нее автоматически помещается символ '0'
   384                                  ;на который и срабатывает программа
   385                                  
   386                                  ;в памяти надо разместить 16 цифр 0 и 1,
   387 000001E8 B910000000              mov ecx,16    ;счетчик
   388                                  
   389                                  ;если делимое не больше 65.535, а результат деления или остаток не больше 255, то используется
   390                                  ;алгоритм деления: ax(делимое 16 бит)/любой 8-битный регистр=al(целое 8 бит) и ah(остаток 8 бит)
   391                                  
   392                                  ;если же делимое не больше 4.294.967.295  , а результат деления или остаток не больше 65.536, то используется
   393                                  ;dx и ax(2 регистра по 16 бит = делимое 32 бит)/ любой 16-битный регистр=ax(целое 16 бит) и dx(остаток 16 бит)
   394                                  ;где dx - старшая часть, а ax - младшая часть делимого
   395                                  ;получить какое число поместить в dx, а какое в ax можно по формуле:
   396                                  ;делимое перевести в 16-ричную форму и 2 младших байта в ax, а 2 старших байта в dx,
   397                                  ;например число 65536 (10-я форма) это 10000 (16-я форма), где
   398                                  ;4 младших знака 0000 помещаются - в ax, а старший знак 1 - в dx
   399                                  
   400                                  ;работающий код для деления 2 байтного числа на 1 байтное с результатом 1 байт
   401                                  ;mov ax,si               ;перенос значения из si в ax, т.к. в ax может добавляться ответ от какой-либо функции
   402                                  ;mov bl,2                ;делитель для степени 2
   403                                  ;metka1:
   404                                  ;div bl
   405                                                           ;div делит значение из ax на bl
   406                                                           ;целый результат - al
   407                                                           ;остаток - ah
   408                                  ;mov byte[edi],ah        ;ввод остатка
   409                                  ;add byte[edi],'0'       ;чтобы вывести число из регистра, его надо перевести в символ путем добавления '0'
   410                                                           ;так как №0 в таблице=48 и в итоге получается, что число, например 2 складываем
   411                                                           ;с 48 и получаем 50, т.е. № числа 2 в таблице и поэтому оно выводится на экран!
   412                                  ;movzx ax,al             ;перенос целого в ax
   413                                  ;dec edi                 ;уменьшить номер ячейки памяти
   414                                  ;loop metka1             ;повторение цикла 16 раз и вывод только остатка
   415                                  
   416                                  
   417                                  
   418                                  
   419                                  
   420                                  
   421                                  ;работающий код для деления 4 байтного числа на 2 байтное с результатом 2 байта
   422 000001ED 0FB7D6                  movzx edx,si             ;перенос значения из si в edx с расширением нулями до большего размера
   423                                  
   424                                    ;разделить число по частям в регистры ax и dx для операции деления
   425                                    ;dx и ax(16 + 16 бит = делимое 32 бит)/ любой 16-битный регистр=ax(целое 16 бит) и dx(остаток 16 бит)
   426 000001F0 6689D0                  mov ax,dx                ;младшую часть перенести в регистр ax
   427 000001F3 C1EA10                  shr edx, 16             ;сдвинуть значение регистра вправо на 2 байта или 16 символов/битов
   428 000001F6 66BB0200                mov bx,2                ;делитель для степени 2
   429                                  metka2:
   430 000001FA 66F7F3                  div bx
   431 000001FD 678817                  mov byte[edi],dl        ;ввод остатка
   432 00000200 67800730                add byte[edi],'0'       ;чтобы вывести число из регистра, его надо перевести в символ путем добавления '0'
   433 00000204 FFCF                    dec edi                 ;уменьшить номер ячейки памяти
   434                                                         ;уменьшить номер ячейки памяти
   435                                  ;xor dx,dx               ;обнулить регистр dx
   436                                  ;mov ax,dx               ;перенос остатка в целое значение для деления
   437 00000206 E2F2                    loop metka2             ;повторение цикла 16 раз и вывод только остатка
   438                                  
   439                                  ;вывод битов
   440 00000208 B9[D2000000]            mov ecx, byteout
   441 0000020D BA10000000              mov edx, lbyteout
   442 00000212 E8E9FDFFFF              call PRINT
   443                                  
   444                                  ;переход на новую строку
   445 00000217 B9[39000000]            mov ecx,n
   446 0000021C BA01000000              mov edx,ln
   447 00000221 E8DAFDFFFF              call PRINT
   448                                  
   449                                  
   450                                                                               ;6 выход из программы
   451                                  
   452 00000226 B801000000              mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
   453 0000022B BB00000000              mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
   454 00000230 CD80                    int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
