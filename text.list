     1                                  SECTION .data        ;для инициализированных данных
     2                                  
     3 00000000 D092D0B2D0B5D0B4D0-     invite db "Введите первое число от 0 до 65535 включительно:",0xa,0
     3 00000009 B8D182D0B520D0BFD0-
     3 00000012 B5D180D0B2D0BED0B5-
     3 0000001B 20D187D0B8D181D0BB-
     3 00000024 D0BE20D0BED1822030-
     3 0000002D 20D0B4D0BE20363535-
     3 00000036 333520D0B2D0BAD0BB-
     3 0000003F D18ED187D0B8D182D0-
     3 00000048 B5D0BBD18CD0BDD0BE-
     3 00000051 3A0A00             
     4                                  linvite equ $-invite
     5                                  
     6 00000054 D092D0B2D0B5D0B4D0-     invite1 db "Введите второе число от 0 до 65535 включительно:",0xa,0
     6 0000005D B8D182D0B520D0B2D1-
     6 00000066 82D0BED180D0BED0B5-
     6 0000006F 20D187D0B8D181D0BB-
     6 00000078 D0BE20D0BED1822030-
     6 00000081 20D0B4D0BE20363535-
     6 0000008A 333520D0B2D0BAD0BB-
     6 00000093 D18ED187D0B8D182D0-
     6 0000009C B5D0BBD18CD0BDD0BE-
     6 000000A5 3A0A00             
     7                                  linvite1 equ $-invite1
     8                                  
     9 000000A8 D092D0B2D0B5D0B4D0-     invite2 db "Введите знак умножения:",0xa,0
     9 000000B1 B8D182D0B520D0B7D0-
     9 000000BA BDD0B0D0BA20D183D0-
     9 000000C3 BCD0BDD0BED0B6D0B5-
     9 000000CC D0BDD0B8D18F3A0A00 
    10                                  linvite2 equ $-invite2
    11                                  
    12 000000D5 D0A0D0B5D0B7D183D0-     invite3 db "Результат:",0xa,0
    12 000000DE BBD18CD182D0B0D182-
    12 000000E7 3A0A00             
    13                                  linvite3 equ $-invite3
    14                                  
    15 000000EA D097D0BDD0B0D0BA20-     nosign db "Знак не введен!",0xa,0
    15 000000F3 D0BDD0B520D0B2D0B2-
    15 000000FC D0B5D0B4D0B5D0BD21-
    15 00000105 0A00               
    16                                  lnosign equ $-nosign
    17                                  
    18 00000107 D092D0B2D0B5D0B4D0-     nocorrectvalue db "Введено число вне предела от 0 до 65535!",0xa,0
    18 00000110 B5D0BDD0BE20D187D0-
    18 00000119 B8D181D0BBD0BE20D0-
    18 00000122 B2D0BDD0B520D0BFD1-
    18 0000012B 80D0B5D0B4D0B5D0BB-
    18 00000134 D0B020D0BED1822030-
    18 0000013D 20D0B4D0BE20363535-
    18 00000146 3335210A00         
    19                                  lnocorrectvalue equ $-nocorrectvalue
    20                                  
    21                                  
    22 0000014B 0A                      n db 0xa                   ;переменная для переноса строки
    23                                  ln equ $-n
    24                                  
    25                                  
    26                                  SECTION .bss         ;для НЕинициализированных данных
    27                                  ;при выделении памяти лучше выделить больше чем надо, хотя бы на 1 байт
    28                                  ;ввод символов
    29 00000000 ????????????            value1: resb 6                              ;выделение памяти в 5 байт, где value1 - адрес первого символа
    30                                  lvalue1 equ $-value1                        ;адрес с длиной сообщения
    31                                  
    32                                  ;ввод символов
    33 00000006 ????????????            value2: resb 6                              ;выделение памяти в 5 байт, где value2 - адрес первого символа
    34                                  lvalue2 equ $-value2
    35                                  
    36                                  ;ввод знака
    37 0000000C ????                    sign: resb 2                                ;выделение памяти в 1 байт, где sign - адрес первого символа
    38                                  lsign equ $-sign
    39                                  
    40                                  ;вывод ответа
    41 0000000E <res Ah>                output: resb 10                             ;выделение памяти в 10 байт
    42                                  loutput equ $-output                        ;адрес с длиной сообщения
    43                                  
    44                                  SECTION .text     ;начало кода самой программы
    45                                  
    46                                  ;инструкция ret подпрограммы использует стек и регистр RSP/ESP, поэтому его не трогать!
    47                                  ;вывод записи, использование стандартных обязательных данных
    48                                  PRINT:
    49 00000000 B804000000              mov eax,4
    50 00000005 BB01000000              mov ebx,1
    51 0000000A CD80                    int 80h       ;данные из rdx копируются в rax
    52 0000000C C3                      ret
    53                                  
    54                                  ;ввод записи
    55                                  WRITE:
    56 0000000D B803000000              mov eax,3
    57 00000012 BB00000000              mov ebx,0
    58 00000017 CD80                    int 80h      ;в rax помещается 0
    59 00000019 C3                      ret
    60                                  
    61                                  GLOBAL _start
    62                                      _start:
    63                                  ;вывод приглашения ввести символы
    64 0000001A B9[00000000]            mov ecx,invite       ;ввод адреса
    65 0000001F BA54000000              mov edx,linvite      ;ввод количества символов
    66 00000024 E8D7FFFFFF              call PRINT
    67                                  
    68                                  ;ввод первого значения
    69 00000029 B9[00000000]            mov ecx,value1       ;ввод адреса
    70 0000002E BA06000000              mov edx,lvalue1    ;ввод количества символов
    71 00000033 E8D5FFFFFF              call WRITE
    72                                  
    73 00000038 B9[A8000000]            mov ecx,invite2       ;ввод адреса
    74 0000003D BA2D000000              mov edx,linvite2    ;ввод количества символов
    75 00000042 E8B9FFFFFF              call PRINT
    76                                  
    77                                  ;ввод арифметического знака
    78 00000047 B9[0C000000]            mov ecx,sign       ;ввод адреса
    79 0000004C BA02000000              mov edx,lsign    ;ввод количества символов
    80 00000051 E8B7FFFFFF              call WRITE
    81                                  
    82                                  ;вывод приглашения ввести символы
    83 00000056 B9[54000000]            mov ecx,invite1       ;ввод адреса
    84 0000005B BA54000000              mov edx,linvite1      ;ввод количества символов
    85 00000060 E89BFFFFFF              call PRINT
    86                                  
    87                                  ;ввод второго значения
    88 00000065 B9[06000000]            mov ecx,value2       ;ввод адреса
    89 0000006A BA06000000              mov edx,lvalue2    ;ввод количества символов
    90 0000006F E899FFFFFF              call WRITE
    91                                  
    92                                  ;вывод результата
    93 00000074 B9[D5000000]            mov ecx,invite3       ;ввод адреса
    94 00000079 BA15000000              mov edx,linvite3      ;ввод количества символов
    95 0000007E E87DFFFFFF              call PRINT
    96                                  
    97                                  ;переставить первое число в памяти в обратном порядке
    98                                  ;проверка на символ '-' №45 в начале строки (ввод отрицательного числа)
    99 00000083 803C25[00000000]2D      cmp byte[value1],45
   100 0000008B 0F8421020000            je incorrectvalue
   101                                  
   102 00000091 BF[00000000]            mov edi,value1   ;поместить адрес, т.е. указатель в регистр
   103 00000096 4831D2                  xor rdx,rdx        ;для счета значений
   104 00000099 4831C0                  xor rax,rax
   105 0000009C 66B90500                mov cx,5           ; счетчик
   106                                  input:
   107 000000A0 678A07                  mov al,byte[edi]    ;поместить значение в al
   108                                  ;проверка на число
   109 000000A3 3C30                    cmp al,48
   110 000000A5 7D02                    jge nextto
   111 000000A7 7C0E                    jl exitto
   112                                  nextto:
   113 000000A9 3C39                    cmp al,57
   114 000000AB 7E02                    jle inputok
   115 000000AD 7F08                    jg exitto
   116                                  inputok:
   117 000000AF 66FFC2                  inc dx
   118 000000B2 FFC7                    inc edi
   119 000000B4 50                      push rax
   120 000000B5 E2E9                    loop input
   121                                  exitto:  ;выход из цикла
   122 000000B7 89D1                    mov ecx,edx        ;счетчик
   123 000000B9 BF[00000000]            mov edi,value1     ;поместить адрес, т.е. указатель в регистр
   124                                  
   125                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   126 000000BE 83FA00                  cmp edx,0
   127 000000C1 7E08                    jle novalue
   128                                  opo:
   129 000000C3 58                      pop rax
   130 000000C4 678807                  mov byte[edi],al
   131 000000C7 FFC7                    inc edi
   132 000000C9 E2F8                    loop opo
   133                                  novalue:
   134                                  
   135                                  ;переставить второе число в памяти в обратном порядке
   136 000000CB BF[06000000]            mov edi,value2    ;поместить адрес, т.е. указатель в регистр
   137 000000D0 6631D2                  xor dx,dx            ;для счета значений
   138 000000D3 66B90500                mov cx,5              ; счетчик
   139                                  input1:
   140 000000D7 678A07                  mov al,byte[edi]       ;поместить значение в al
   141                                  ;проверка на число
   142 000000DA 3C30                    cmp al,48
   143 000000DC 7D02                    jge nextto1
   144 000000DE 7C0E                    jl exitto1
   145                                  nextto1:
   146 000000E0 3C39                    cmp al,57
   147 000000E2 7E02                    jle inputok1
   148 000000E4 7F08                    jg exitto1
   149                                  inputok1:
   150 000000E6 66FFC2                  inc dx
   151 000000E9 FFC7                    inc edi
   152 000000EB 50                      push rax
   153 000000EC E2E9                    loop input1
   154                                  exitto1:  ;выход из цикла
   155 000000EE 89D1                    mov ecx,edx        ;счетчик
   156 000000F0 BF[06000000]            mov edi,value2     ;поместить адрес, т.е. указатель в регистр
   157                                  
   158                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   159 000000F5 83FA00                  cmp edx,0
   160 000000F8 7E08                    jle novalue1
   161                                  opo1:
   162 000000FA 58                      pop rax
   163 000000FB 678807                  mov byte[edi],al
   164 000000FE FFC7                    inc edi
   165 00000100 E2F8                    loop opo1
   166                                  novalue1:
   167                                  
   168                                  ;;;;;;;;;;;
   169                                  ;поместить первое число в регистр esi, проверить его на корректность
   170                                  ;перенести его в si, сдвинуть вправо и поместить в стек
   171 00000102 31F6                    xor esi,esi         ;обнуление регистра для хранения промежуточного и итогового результата
   172 00000104 4831C0                  xor rax,rax         ;обнуление регистра
   173 00000107 31D2                    xor edx,edx         ;обнуление регистра
   174 00000109 BF[00000000]            mov edi,value1      ;поместить адрес, т.е. указатель в регистр
   175 0000010E 66BB0A00                mov bx,10         ;для хранения чисел со степенями 10
   176 00000112 678A07                  mov al,byte[edi]        ;поместить значение в ax
   177                                  ;проверка на число
   178 00000115 3C30                    cmp al,48
   179 00000117 7D02                    jge next
   180 00000119 7C55                    jl exit
   181                                  next:
   182 0000011B 3C39                    cmp al,57
   183 0000011D 7E02                    jle multi
   184 0000011F 7F4F                    jg exit
   185                                  multi:
   186 00000121 2C30                    sub al,'0'              ;получить числовое значение символа
   187 00000123 0FB6F0                  movzx esi,al           ;поместить 1-байтное значение из al в 4-байтный регистр esi
   188 00000126 FFC7                    inc edi                 ;увеличить адрес памяти на 1
   189 00000128 B903000000              mov ecx,3            ;счетчик по количеству символов
   190                                  mult:
   191 0000012D 678A07                  mov al,byte[edi]       ;поместить значение в ax
   192                                  ;проверка на число
   193 00000130 3C30                    cmp al,48
   194 00000132 7D02                    jge next1
   195 00000134 7C3A                    jl exit
   196                                  next1:
   197 00000136 3C39                    cmp al,57
   198 00000138 7E02                    jle multi1
   199 0000013A 7F34                    jg exit
   200                                  multi1:
   201 0000013C 2C30                    sub al,'0'          ;получить числовое значение символа
   202 0000013E 66F7E3                  mul bx            ;умножить ax*bx=dx ax
   203 00000141 6689C5                  mov bp,ax          ;внесение результата степени
   204 00000144 01EE                    add esi,ebp            ;добавить число к промежуточному значению
   205 00000146 B80A000000              mov eax,10            ;поместить 10 в eax
   206 0000014B 66F7E3                  mul bx               ;умножить ax*bx=dx ax, dx и ax 100.000 4 байта
   207 0000014E 6689C3                  mov bx,ax            ;поместить в bx = 100
   208 00000151 31C0                    xor eax,eax             ;обнулить eax
   209 00000153 FFC7                    inc edi              ;увеличить адрес памяти на 1
   210 00000155 E2D6                    loop mult
   211 00000157 678A07                  mov al,byte[edi]   ;поместить значение в ax
   212                                  ;проверка на число
   213 0000015A 3C30                    cmp al,48
   214 0000015C 7D02                    jge next2
   215 0000015E 7C10                    jl exit
   216                                  next2:
   217 00000160 3C39                    cmp al,57
   218 00000162 7E02                    jle multi2
   219 00000164 7F0A                    jg exit
   220                                  multi2:
   221 00000166 2C30                    sub al,'0'           ;получить числовое значение символа
   222 00000168 66F7E3                  mul bx            ;умножить ax*bx=dx ax  3*10000
   223 0000016B 6689C5                  mov bp,ax         ;внесение результата степени = 30000
   224 0000016E 01EE                    add esi,ebp         ;добавить число к промежуточному значению
   225                                  exit:
   226                                  ;;;;;;;;;;;;;;;;;;;;;;;;;
   227                                  ;проверка вводимого числа в регистре si, оно должно быть
   228                                  ;не меньше 0 и не больше 65535, которое помещается в 2-х байтном регистре
   229 00000170 81FEFFFF0000            cmp esi,65535
   230 00000176 0F8F36010000            jg incorrectvalue
   231                                  ;sub si,65536
   232                                  ;js incorrectvalue       ;если флаг знака SF=1
   233                                  ;по идее отрицательный результат операции можно проверить по флагу SF,
   234                                  ;но иногда проще проверить наличие знака '-' при вводе
   235                                  ;числа, номер символа 'минус' в ASCII №45
   236                                  
   237                                  
   238                                  ;;;;;;;;;;;;;;;;;;;;;;;
   239 0000017C C1E610                  shl esi,16      ;в связи с отсутствием свободных регистров
   240                                                  ;переносим результат для хранения в старшие 3 и 4 биты регистра esi
   241                                                  ;и тогда можно снова использовать регистр si
   242 0000017F 56                      push rsi   ;поместить значение из регистра rsi в стек
   243                                  
   244                                  ;;;;;;;;;;;
   245                                  ;проверка на символ '-' №45 в начале строки (ввод отрицательного числа)
   246 00000180 803C25[06000000]2D      cmp byte[value2],45
   247 00000188 0F8424010000            je incorrectvalue
   248                                  
   249                                  ;поместить второе число в регистр esi, проверить его на корректность
   250                                  ;перенести его в si, затем скопировать из si в di,
   251                                  ;обнулить rsi, взять данные из стека,
   252                                  ;поместить в rsi и сложить с di
   253                                  
   254 0000018E 31F6                    xor esi,esi         ;обнуление регистра для хранения промежуточного и итогового результата
   255 00000190 4831C0                  xor rax,rax         ;обнуление регистра
   256 00000193 31D2                    xor edx,edx         ;обнуление регистра
   257 00000195 BF[06000000]            mov edi,value2    ;поместить адрес, т.е. указатель в регистр
   258 0000019A 66BB0A00                mov bx,10         ;для хранения чисел со степенями 10
   259 0000019E 678A07                  mov al,byte[edi]        ;поместить значение в ax
   260                                  ;проверка на число
   261 000001A1 3C30                    cmp al,48
   262 000001A3 7D02                    jge next3
   263 000001A5 7C55                    jl exit1
   264                                  next3:
   265 000001A7 3C39                    cmp al,57
   266 000001A9 7E02                    jle multi3
   267 000001AB 7F4F                    jg exit1
   268                                  multi3:
   269 000001AD 2C30                    sub al,'0'              ;получить числовое значение символа
   270 000001AF 0FB6F0                  movzx esi,al           ;поместить 2-байтное значение из al в 2-байтный регистр si
   271 000001B2 FFC7                    inc edi                 ;увеличить адрес памяти на 1
   272 000001B4 B903000000              mov ecx,3            ;счетчик по количеству символов
   273                                  mult1:
   274 000001B9 678A07                  mov al,byte[edi]  ;поместить значение в ax
   275                                  ;проверка на число
   276 000001BC 3C30                    cmp al,48
   277 000001BE 7D02                    jge next4
   278 000001C0 7C3A                    jl exit1
   279                                  next4:
   280 000001C2 3C39                    cmp al,57
   281 000001C4 7E02                    jle multi4
   282 000001C6 7F34                    jg exit1
   283                                  multi4:
   284 000001C8 2C30                    sub al,'0'        ;получить числовое значение символа
   285 000001CA 66F7E3                  mul bx            ;умножить ax*bx=dx ax
   286 000001CD 6689C5                  mov bp,ax         ;внесение результата степени
   287 000001D0 01EE                    add esi,ebp         ;добавить число к промежуточному значению
   288 000001D2 B80A000000              mov eax,10        ;поместить 10 в eax
   289 000001D7 66F7E3                  mul bx            ;умножить ax*bx=dx ax, dx и ax 100.000 4 байта
   290 000001DA 6689C3                  mov bx,ax         ;поместить в bx = 100
   291 000001DD 31C0                    xor eax,eax       ;обнулить eax
   292 000001DF FFC7                    inc edi           ;увеличить адрес памяти на 1
   293 000001E1 E2D6                    loop mult1
   294 000001E3 678A07                  mov al,byte[edi]  ;поместить значение в ax
   295                                  ;проверка на число
   296 000001E6 3C30                    cmp al,48
   297 000001E8 7D02                    jge next5
   298 000001EA 7C10                    jl exit1
   299                                  next5:
   300 000001EC 3C39                    cmp al,57
   301 000001EE 7E02                    jle multi5
   302 000001F0 7F0A                    jg exit1
   303                                  multi5:
   304 000001F2 2C30                    sub al,'0'        ;получить числовое значение символа
   305 000001F4 66F7E3                  mul bx            ;умножить ax*bx=dx ax  3*10000
   306 000001F7 6689C5                  mov bp,ax         ;внесение результата степени = 30000
   307 000001FA 01EE                    add esi,ebp         ;добавить число к промежуточному значению
   308                                  exit1:
   309                                  
   310                                  ;поместить второе число в регистр esi, скопировать из esi в edi,
   311                                  ;проверить его на корректность
   312                                  
   313                                  ;обнулить rsi, взять данные из стека,
   314                                  ;поместить в rsi и сложить с di
   315                                  
   316                                  ;копируем для сохранения из esi в edi
   317 000001FC 89F7                    mov edi,esi
   318                                  
   319                                  ;проверка вводимого числа в регистре si, оно должно быть
   320                                  ;не меньше 0 и не больше 65535, которое помещается в 2-х байтном регистре
   321 000001FE 81FEFFFF0000            cmp esi,65535
   322 00000204 0F8FA8000000            jg incorrectvalue
   323 0000020A 83FE00                  cmp esi,0
   324 0000020D 0F8C9F000000            jl incorrectvalue
   325                                  
   326 00000213 4831F6                  xor rsi,rsi
   327 00000216 5E                      pop rsi
   328 00000217 6601FE                  add si,di
   329                                  
   330                                  
   331 0000021A 31C0                    xor eax,eax  ;обнуление
   332 0000021C 31D2                    xor edx,edx  ;обнуление
   333                                  ;;;;;;;;;;;;;;;
   334                                  
   335                                  ;;;36553*3 и 36554*3 проверить работу
   336                                  ;36553*3=8590000119 а должно 109659 или 1AC5B(16-й формат)
   337                                  ;содержит значение:
   338                                  ;1 байт не больше 255
   339                                  ;2 байта не больше 65535
   340                                  ;4 байта не больше 4.294.967.295
   341                                  ;8 байт не больше 1,844674407×10¹⁹
   342                                  
   343                                  ;поместить одно значение в регистр ax
   344                                  ;а второе поместить в регистр si
   345 0000021E 6689F0                  mov ax,si          ;получить одно значение
   346 00000221 C1EE10                  shr esi,16         ;передвинуть значение в регистр si
   347                                  
   348                                  ;проверка числа, если число в регистре <0 (т.е.отрицательное) или
   349                                  ;больше 65535, хотя в регистре оно больше не бывает, если оно больше,
   350                                  ;то значение расширится в больший по размеру регистр, но может быть покажет переполнение
   351                                  ;т.е. надо проверять на флаг S(знака) или O(переполнения)
   352                                  ;принцип работы: из ax высчитываем 65535,
   353                                  ;если получается <0, то флаг SF (флаг знака) ставится в 1
   354                                  
   355                                  
   356                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
   357                                  
   358                                  
   359                                  ;;;36553*3 и 36554*3 проверить работу
   360                                  ;36553*3=8590000119 а должно 109659 или 1AC5B(16-й формат)
   361                                  ;содержит значение:
   362                                  ;1 байт не больше 255
   363                                  ;2 байта не больше 65535
   364                                  ;4 байта не больше 4.294.967.295
   365                                  ;8 байт не больше 1,844674407×10¹⁹
   366                                  
   367                                  ;работаем пока со знаком умножения *, его № 42 в ASCII
   368 00000224 803C25[0C000000]2A      cmp byte[sign],42
   369 0000022C 7406                    je yesmul       ;если равно
   370 0000022E 0F858F000000            jne tonosign       ;если не равно
   371                                  
   372                                  yesmul:
   373                                  ;выполнить операцию умножения
   374 00000234 66F7E6                  mul si             ;умножаем ax на si и результат в dx и ax
   375                                  ;перенести результат из dx ax в память  output
   376 00000237 BF[0E000000]            mov edi,output   ;получить адрес output
   377                                  ;add edi,loutput-1  ;адрес последнего символа
   378                                  ;деление 8-и байтных значений
   379                                  ;div 4-х байтный регистр
   380                                  ;edx eax/4-х байтный регистр = eax (результат) и edx (остаток)
   381                                  ;4 байта - число не более 4.294.967.295
   382 0000023C B90A000000              mov ecx,10  ;счетчик
   383 00000241 BE0A000000              mov esi,10  ;для вывода в 10-м формате
   384                                  ;edx 0000fffe и eax 00000001 не работает деление!!!
   385                                  ;пробуем перенести значение из (e)dx в начало регистра eax
   386 00000246 C1E210                  shl edx,16     ;сдвинуть значение влево из 2-х байного dx в начало 4-х байтного регистра edx
   387 00000249 6689C2                  mov dx,ax      ;перенести значение из ax в dx
   388 0000024C 89D0                    mov eax,edx    ;перенести полное значение из edx в eax для деления
   389 0000024E 31D2                    xor edx,edx    ;обнулить edx для деления, так как значение оттуда убрали
   390                                  again:
   391 00000250 F7F6                    div esi      ;делим на 4-х байтный регистр, так как делимое в 4-х байтном регистре
   392                                               ;eax (результат, так как делим на 4-х байтный регистр)
   393                                               ;edx (остаток, так как делим на 4-х байтный регистр)
   394                                               ;так как делим на 10, то остаток, который меньше 10 поместится в dl
   395                                  
   396                                  ;вроде работает с большими числами
   397                                  ;но если после первого деления результат не помещается в eax начинаются проблемки
   398                                  
   399 00000252 678817                  mov byte[edi],dl
   400 00000255 67800730                add byte[edi],'0'
   401 00000259 31D2                    xor edx,edx     ;обнуляем edx, так как там есть остаток, участвующий в следующем делении
   402 0000025B FFC7                    inc edi
   403                                  
   404 0000025D 83F80A                  cmp eax,10
   405 00000260 7C04                    jl no   ;если результат <10
   406 00000262 7D00                    Jge nextend
   407                                  nextend:
   408                                  
   409 00000264 E2EA                    loop again
   410                                  
   411                                  
   412                                  no:            ;далее
   413 00000266 678807                  mov byte[edi],al
   414 00000269 67800730                add byte[edi],'0'
   415                                  ;;;;;;;;;;;;
   416                                  
   417                                  
   418                                  
   419                                  ;переставить числа в памяти в обратном порядке
   420 0000026D BF[0E000000]            mov edi,output    ;поместить адрес, т.е. указатель в регистр
   421 00000272 6631D2                  xor dx,dx            ;для счета значений
   422 00000275 66B90A00                mov cx,10              ; счетчик
   423                                  
   424                                  inputout:
   425 00000279 678A07                  mov al,byte[edi]       ;поместить значение в al
   426                                  
   427                                  ;проверка на число
   428 0000027C 3C30                    cmp al,48
   429 0000027E 7D02                    jge nexttoout
   430 00000280 7C0E                    jl exittoout
   431                                  nexttoout:
   432 00000282 3C39                    cmp al,57
   433 00000284 7E02                    jle inputokout
   434 00000286 7F08                    jg exittoout
   435                                  
   436                                  inputokout:
   437 00000288 66FFC2                  inc dx
   438 0000028B FFC7                    inc edi
   439 0000028D 50                      push rax
   440 0000028E E2E9                    loop inputout
   441                                  
   442                                  exittoout:  ;выход из цикла
   443                                  
   444 00000290 89D1                    mov ecx,edx        ;счетчик
   445 00000292 BF[0E000000]            mov edi,output     ;поместить адрес, т.е. указатель в регистр
   446                                  
   447                                  opoout:
   448 00000297 58                      pop rax
   449 00000298 678807                  mov byte[edi],al
   450 0000029B FFC7                    inc edi
   451 0000029D E2F8                    loop opoout
   452                                  
   453 0000029F EB00                    jmp tofinish
   454                                  ;;;;;;;;;;;;;;;;;;;
   455                                  
   456                                  
   457                                  tofinish:
   458                                  ;вывод результата
   459 000002A1 B9[0E000000]            mov ecx,output       ;ввод адреса
   460 000002A6 BA0A000000              mov edx,loutput     ;ввод количества символов
   461 000002AB E850FDFFFF              call PRINT
   462 000002B0 EB22                    jmp tomainfinish
   463                                  
   464                                  incorrectvalue:
   465                                  ;введено некорректное значение
   466 000002B2 B9[07010000]            mov ecx,nocorrectvalue       ;ввод адреса
   467 000002B7 BA44000000              mov edx,lnocorrectvalue      ;ввод количества символов
   468 000002BC E83FFDFFFF              call PRINT
   469 000002C1 EB11                    jmp tomainfinish
   470                                  
   471                                  tonosign:
   472                                  ;знак не введен
   473 000002C3 B9[EA000000]            mov ecx,nosign       ;ввод адреса
   474 000002C8 BA1D000000              mov edx,lnosign      ;ввод количества символов
   475 000002CD E82EFDFFFF              call PRINT
   476 000002D2 EB00                    jmp tomainfinish
   477                                  
   478                                  tomainfinish:
   479                                  ;переход на новую строку
   480 000002D4 B9[4B010000]            mov ecx,n
   481 000002D9 BA01000000              mov edx,ln
   482 000002DE E81DFDFFFF              call PRINT
   483                                  
   484                                                                               ;6 выход из программы
   485                                  
   486 000002E3 B801000000              mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
   487 000002E8 BB00000000              mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
   488 000002ED CD80                    int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
