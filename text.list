     1                                  SECTION .data        ;для инициализированных данных
     2                                  
     3 00000000 D092D0B2D0B5D0B4D0-     invite db "Введите несколько букв и цифр:",0xa,0
     3 00000009 B8D182D0B520D0BDD0-
     3 00000012 B5D181D0BAD0BED0BB-
     3 0000001B D18CD0BAD0BE20D0B1-
     3 00000024 D183D0BAD0B220D0B8-
     3 0000002D 20D186D0B8D184D180-
     3 00000036 3A0A00             
     4                                  linvite equ $-invite
     5                                  
     6 00000039 0A                      n db 0xa                   ;переменная для переноса строки
     7                                  ln equ $-n
     8                                  
     9                                  SECTION .bss         ;для НЕинициализированных данных
    10                                  ;ввод символов
    11 00000000 <res 64h>               input: resb 100                               ;выделение памяти в 100 байт, где input- адрес первого символа
    12                                  linput equ $-input                           ;адрес с длиной сообщения
    13                                  
    14                                  ;вывод повторяющихся символов
    15 00000064 <res 64h>               output: resb 100                              ;выделение памяти в 100 байт
    16                                  loutput equ $-output                            ;адрес с длиной сообщения
    17                                  
    18                                  ;вывод неповторяющихся символов
    19 000000C8 <res Ah>                nodub: resb 10                              ;выделение памяти в 10 байт
    20                                  lnodub equ $-nodub                            ;адрес с длиной сообщения
    21                                  
    22                                  ;вывод байтов
    23 000000D2 <res 10h>               byteout: resb 16                             ;выделение памяти в 16 байт
    24                                  lbyteout equ $-byteout                            ;адрес с длиной сообщения
    25                                  
    26                                  SECTION .text     ;начало кода самой программы
    27                                  
    28                                  ;инструкция ret подпрограммы использует стек и регистр RSP/ESP
    29                                  ;вывод записи, использование стандартных обязательных данных
    30                                  PRINT:
    31 00000000 B804000000              mov eax,4
    32 00000005 BB01000000              mov ebx,1
    33 0000000A CD80                    int 80h
    34 0000000C C3                      ret
    35                                  
    36                                  ;ввод записи
    37                                  WRITE:
    38 0000000D B803000000              mov eax,3
    39 00000012 BB00000000              mov ebx,0
    40 00000017 CD80                    int 80h
    41 00000019 C3                      ret
    42                                  
    43                                  GLOBAL _start
    44                                      _start:
    45                                                                                ;1 ввод символов в input:
    46                                  
    47                                  ;вывод приглашения ввести символы
    48 0000001A B9[00000000]            mov ecx,invite       ;ввод адреса
    49 0000001F BA39000000              mov edx,linvite      ;ввод количества символов
    50 00000024 E8D7FFFFFF              call PRINT
    51                                  
    52                                  ;ввод символов
    53 00000029 B9[00000000]            mov ecx,input       ;ввод адреса
    54 0000002E BA64000000              mov edx,linput     ;ввод количества символов
    55 00000033 E8D5FFFFFF              call WRITE
    56                                                                      ;2 проверка символов из input на цифры и ввод цифр в память output:
    57                                  
    58                                  ;поместить адрес из памяти в регистр
    59 00000038 BB[00000000]            mov ebx,input
    60 0000003D BA[64000000]            mov edx,output
    61                                  
    62                                  ;кол-во циклов для ввода найденных чисел в память output
    63 00000042 B964000000              mov ecx,linput
    64                                  
    65                                  ;следующий символ
    66                                  next:
    67                                  ;перенос значений из input в output через 1-байтный регистр al для сравнения
    68 00000047 678A03                  mov al,byte[ebx]
    69                                  ;проверяем каждый символ на совпадение с цифрой от от 0 до 9
    70                                  ;в ASCII с 48 по 57 номера цифр
    71 0000004A 3C30                    cmp al,48
    72 0000004C 7D02                    jge continue1
    73 0000004E 7C06                    jl no
    74                                  continue1:
    75 00000050 3C39                    cmp al,57
    76 00000052 7E08                    jle yes
    77 00000054 7F00                    jg no
    78                                  ;если не найдена цифра
    79                                  no:
    80                                  ;увеличение адресов на 1, т.е. получение следующей ячейки памяти
    81 00000056 FFC3                    inc ebx          ;только для адреса ввода, для вывода не надо!!! иначе память вывода расходуется впустую!!!
    82                                  ;на проверку следующего символа
    83 00000058 E2ED                    loop next
    84                                  ;при завершении цикла - на выход
    85 0000005A EB0B                    jmp exit
    86                                  ;ввод цифры в память out
    87                                  yes:
    88                                  ;перенос значений в output через 1-байтный регистр al
    89 0000005C 678802                  mov byte[edx],al
    90                                  
    91                                  ;увеличение адресов на 1, т.е. получение следующей ячейки памяти
    92 0000005F FFC3                    inc ebx
    93 00000061 FFC2                    inc edx
    94                                  
    95                                  ;на проверку следующего символа
    96 00000063 E2E2                    loop next
    97                                  ;при завершении цикла - на выход
    98 00000065 EB00                    jmp exit
    99                                  
   100                                  exit:
   101                                  ;вывод введенных символов
   102 00000067 B9[64000000]            mov ecx,output       ;ввод адреса
   103 0000006C BA64000000              mov edx,loutput      ;ввод количества символов
   104 00000071 E88AFFFFFF              call PRINT
   105                                  
   106                                  ;переход на новую строку
   107 00000076 B9[39000000]            mov ecx,n
   108 0000007B BA01000000              mov edx,ln
   109 00000080 E87BFFFFFF              call PRINT
   110                                  
   111                                              ;3 символы цифр из output сравнить и дублированные заменить любым одинаковым символом
   112                                  
   113                                  ;замена значений в памяти
   114 00000085 BF64000000              mov edi,loutput
   115 0000008A BB64000000              mov ebx,loutput
   116 0000008F BE[64000000]            mov esi,output
   117 00000094 89F5                    mov ebp,esi
   118                                  
   119 00000096 FFCF                    dec edi
   120 00000098 89F9                    mov ecx,edi
   121                                  
   122                                  two:
   123 0000009A 678A36                  mov dh,byte[esi]
   124 0000009D FFC6                    inc esi
   125                                  
   126                                  one:
   127 0000009F 673A36                  cmp dh,byte[esi]
   128 000000A2 7F04                    jg greater
   129 000000A4 7C14                    jl less
   130 000000A6 7414                    je equal
   131                                  greater:
   132                                  ;если символы кончились, то выходим
   133                                  
   134 000000A8 678A16                  mov dl,byte[esi]
   135 000000AB 67885500                mov byte[ebp],dl
   136 000000AF 678836                  mov byte[esi],dh
   137 000000B2 88D6                    mov dh,dl
   138                                  
   139                                  nextto:
   140 000000B4 FFC6                    inc esi
   141 000000B6 E2E7                    loop one
   142 000000B8 EB08                    jmp toend
   143                                  
   144                                  less:
   145 000000BA EBF8                    jmp nextto
   146                                  equal:
   147                                  
   148                                  ;при одинаковых значениях символ меняется на больший по размеру
   149                                  ;и соответственно сдвигается вправо!
   150                                  ;потом их можно отрезать и все, вместо того, чтобы циклом сдвигать все следующие значения!
   151                                  
   152 000000BC 67C6063A                mov byte[esi],58          ;замена символа на символ с номером 58
   153 000000C0 EBF2                    jmp nextto
   154                                  
   155                                  toend:
   156 000000C2 89D9                    mov ecx,ebx
   157 000000C4 FFCB                    dec ebx
   158 000000C6 FFC5                    inc ebp
   159 000000C8 89EE                    mov esi,ebp
   160 000000CA E2CE                    loop two
   161                                  
   162                                  toexit:
   163                                  
   164 000000CC B9[64000000]            mov ecx, output
   165 000000D1 BA64000000              mov edx,loutput
   166 000000D6 E825FFFFFF              call PRINT
   167                                  
   168                                  ;переход на новую строку
   169 000000DB B9[39000000]            mov ecx,n
   170 000000E0 BA01000000              mov edx,ln
   171 000000E5 E816FFFFFF              call PRINT
   172                                  
   173                                  ;Обычно ошибка сегментации segmentation fault происходит потому, что:
   174                                  ;указатель/адрес нулевой,
   175                                  ;указатель указывает на произвольный участок памяти (возможно потому, что не был инициализирован),
   176                                  ;указатель указывает на удалённый участок памяти.
   177                                  ;в качестве размера массива указана неинициализированная переменная
   178                                  
   179                                                                    ;4 выбрать только отсортированные цифры
   180                                  
   181                                  ;выбрать только цифры из output
   182                                  ;ecx - счетчик
   183 000000EA B964000000              mov ecx,loutput
   184                                  ;адрес первого символа для ввода
   185 000000EF BB[64000000]            mov ebx,output
   186                                  
   187                                  ;адрес первого символа для вывода
   188 000000F4 BA[C8000000]            mov edx,nodub
   189                                  
   190                                  again1:
   191                                  ;ввод первого символа в регистр
   192 000000F9 678A03                  mov al,byte[ebx]
   193                                  
   194                                  ;проверка на число
   195                                  ;проверяем каждый символ на совпадение с цифрой от от 0 до 9
   196                                  ;в ASCII с 48 по 57 номера цифр
   197 000000FC 3C30                    cmp al,48
   198 000000FE 7D02                    jge continue11
   199 00000100 7C06                    jl nomatch
   200                                  continue11:
   201 00000102 3C39                    cmp al,57
   202 00000104 7E08                    jle match
   203 00000106 7F00                    jg nomatch
   204                                  ;если не найдена цифра
   205                                  
   206                                  nomatch:
   207 00000108 FFC3                    inc ebx
   208 0000010A E2ED                    loop again1
   209 0000010C EB0B                    jmp away
   210                                  
   211                                  match:
   212 0000010E 678802                  mov byte[edx],al
   213 00000111 FFC3                    inc ebx      ;увеличить номер ячейки памяти ввода
   214 00000113 FFC2                    inc edx      ;увеличить номер ячейки памяти для вывода
   215 00000115 E2E2                    loop again1
   216 00000117 EB00                    jmp away
   217                                  
   218                                  away:
   219                                  
   220 00000119 B9[C8000000]            mov ecx,nodub
   221 0000011E BA0A000000              mov edx,lnodub
   222 00000123 E8D8FEFFFF              call PRINT
   223                                  
   224                                  ;переход на новую строку
   225 00000128 B9[39000000]            mov ecx,n
   226 0000012D BA01000000              mov edx,ln
   227 00000132 E8C9FEFFFF              call PRINT
   228                                  
   229                                                                           ;4 убрать дублирование и установить биты в 1
   230                                  
   231                                  ;0 - 48 или 00110000b, для поиска ставим 11001111b
   232                                  ;1 - 49 или 00110001b, для поиска ставим 11001110b и т.д.
   233                                  ;проверим каждое значение методом test
   234                                  ;сравнение символа через его номер в ASCII в 2-м формате с инвертированной маской этого номера в том же виде
   235                                  ;при замене 0 на 1 и наоборот - при операции И или TEST во флаг ZF помещается 1,  и можно осуществить переход по условию
   236                                  ;например ,если для поиска 001100b использовать 110011b, то искомый результат будет 0, а при любом другом значении - 1
   237                                  ;если совпадает
   238                                  ;jnz yes  ;ZF = 0    1 и 1 = 1, а остальные комбинации = 0
   239                                  ;если не совпадает
   240                                  ;jz   ZF = 1
   241                                  
   242                                  ;xor ax,ax                          ;задать нулевое значение для регистра ax
   243                                  ;mov rsi,0                            ;задать нулевое значение для регистра rsi, а потом перенести его в rax
   244 00000137 6631F6                  xor si,si                            ;обнулить регистр
   245 0000013A BB[C8000000]            mov ebx,nodub        ;адрес первой ячейки nodub
   246 0000013F B90A000000              mov ecx,lnodub      ;счетчик по количеству символов в строке (10)
   247                                  
   248                                  
   249                                  toshift:
   250                                  
   251 00000144 678A13                  mov dl,byte[ebx]   ;значение по адресу ebx
   252                                  
   253 00000147 B630                    mov dh,'0'        ;номер в регистре обычно обозначает номер символа в ASCII
   254 00000149 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   255 0000014B 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   256 0000014D 7448                    jz match0
   257                                  
   258 0000014F B631                    mov dh,'1'        ;номер в регистре обычно обозначает номер символа в ASCII
   259 00000151 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   260 00000153 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   261 00000155 7446                    jz match1
   262                                  
   263 00000157 B632                    mov dh,'2'        ;номер в регистре обычно обозначает номер символа в ASCII
   264 00000159 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   265 0000015B 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   266 0000015D 7444                    jz match2
   267                                  
   268 0000015F B633                    mov dh,'3'        ;номер в регистре обычно обозначает номер символа в ASCII
   269 00000161 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   270 00000163 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   271 00000165 7442                    jz match3
   272                                  
   273 00000167 B634                    mov dh,'4'        ;номер в регистре обычно обозначает номер символа в ASCII
   274 00000169 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   275 0000016B 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   276 0000016D 7440                    jz match4
   277                                  
   278 0000016F B635                    mov dh,'5'        ;номер в регистре обычно обозначает номер символа в ASCII
   279 00000171 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   280 00000173 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   281 00000175 743E                    jz match5
   282                                  
   283 00000177 B636                    mov dh,'6'        ;номер в регистре обычно обозначает номер символа в ASCII
   284 00000179 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   285 0000017B 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   286 0000017D 743C                    jz match6
   287                                  
   288 0000017F B637                    mov dh,'7'        ;номер в регистре обычно обозначает номер символа в ASCII
   289 00000181 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   290 00000183 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   291 00000185 743A                    jz match7
   292                                  
   293 00000187 B638                    mov dh,'8'        ;номер в регистре обычно обозначает номер символа в ASCII
   294 00000189 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   295 0000018B 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   296 0000018D 7439                    jz match8
   297                                  
   298 0000018F B639                    mov dh,'9'        ;номер в регистре обычно обозначает номер символа в ASCII
   299 00000191 F6D6                    not dh   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
   300 00000193 84F2                    test dl,dh                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
   301 00000195 7438                    jz match9
   302                                  
   303                                  
   304                                  
   305                                  
   306                                  ;or si,1 - это не срабатывает никогда
   307                                  match0:    ;это срабатывает при любых условиях, т.е. символ 0 всегда есть в dl,byte[ebx] или dh
   308                                            ;если в памяти остаются свободные ячейки они автоматически заполняются символом '0'
   309                                            ;поэтому этот символ программа находит в памяти!!!
   310                                  ;or ax,0000000000000001b
   311 00000197 6683CE01                or si,1
   312 0000019B EB39                    jmp again3
   313                                  
   314                                  match1:
   315                                  ;or ax,0000000000000010b
   316 0000019D 6683CE02                or si,2
   317 000001A1 EB33                    jmp again3
   318                                  
   319                                  match2:
   320                                  ;or ax,0000000000000100b
   321 000001A3 6683CE04                or si,4
   322 000001A7 EB2D                    jmp again3
   323                                  
   324                                  match3:
   325                                  ;or ax,0000000000001000b
   326 000001A9 6683CE08                or si,8
   327 000001AD EB27                    jmp again3
   328                                  
   329                                  match4:
   330                                  ;or ax,0000000000010000b
   331 000001AF 6683CE10                or si,16
   332 000001B3 EB21                    jmp again3
   333                                  
   334                                  match5:
   335                                  ;or ax,0000000000100000b
   336 000001B5 6683CE20                or si,32
   337 000001B9 EB1B                    jmp again3
   338                                  
   339                                  match6:
   340                                  ;or ax,0000000001000000b
   341 000001BB 6683CE40                or si,64
   342 000001BF EB15                    jmp again3
   343                                  
   344                                  match7:
   345                                  ;or ax,0000000001000000b
   346 000001C1 6681CE8000              or si,128
   347 000001C6 EB0E                    jmp again3
   348                                  
   349                                  match8:
   350                                  ;or ax,0000000100000000b
   351 000001C8 6681CE0001              or si,256
   352 000001CD EB07                    jmp again3
   353                                  
   354                                  match9:
   355                                  ;or ax,0000001000000000b
   356 000001CF 6681CE0002              or si,512 ;512 - не работает Floating point exception (core dumped) 511- работает,а 512 уже нет
   357                                  
   358                                                                                  ;510 и 511 = 0000000111111111
   359                                                          ;возможно проблема с делением
   360                                                          ;результат помещается в ah и al - по 8 байтов
   361                                                          ;макс.значение каждого до 255 или 11111111
   362 000001D4 EB00                    jmp again3
   363                                  
   364                                  
   365                                  again3:
   366 000001D6 FFC3                    inc ebx            ;увеличить номер ячейки
   367                                  ;если loop toshift не срабатывает из-за длинного кода
   368                                  ;можно использовать следующий код:
   369 000001D8 FFC9                    dec ecx
   370 000001DA 0F8564FFFFFF            jnz toshift
   371                                  
   372                                  
   373 000001E0 BA[D2000000]            mov edx,byteout     ;указать адрес первого элемента
   374 000001E5 83C20F                  add edx,lbyteout-1   ;увеличить номер ячейки памяти на lbyteout-1
   375                                  
   376                                  ;всегда в бите №0 выходит значение 1
   377                                  ;и по умолчанию и по указанию
   378                                  ;причина- не все ячейки памяти заполнены значениями
   379                                  ;и если в памяти остается хоть одна пустая ячейка, то в нее автоматически помещается символ '0'
   380                                  ;на который и срабатывает программа
   381                                  
   382 000001E8 6689F0                  mov ax,si             ;перенос значения из si в ax, т.к. в ax может добавляться ответ от какой-либо функции
   383 000001EB B303                    mov bl,3             ;делитель для степени 2 ax
   384                                  
   385                                  ;в памяти надо разместить 16 цифр 0 и 1,
   386                                  ;посчитать выводимые цифры и дополнить остальное до конца справа нулями
   387 000001ED B910000000              mov ecx,16    ;счетчик
   388                                  
   389                                  ;номера памяти 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
   390                                  ;первый номер 0+15=15
   391                                  ;
   392                                  
   393                                  ;если делимое = 256 или меньше
   394                                  metka1:
   395                                  ;dec ecx                 ;уменьшить счетчик
   396 000001F2 F6F3                    div bl
   397                                  ;div делит значение из ax на bl
   398                                  ;целый результат - al
   399                                  ;остаток - ah
   400 000001F4 678822                  mov byte[edx],ah        ;ввод остатка
   401 000001F7 67800230                add byte[edx],'0'       ;чтобы вывести число из регистра, его надо перевести в символ путем добавления '0'
   402 000001FB 660FB6C0                movzx ax,al     ;перенос целого в ax
   403                                  ;inc edx          ;увеличить номер ячейки памяти для вывода
   404 000001FF FFCA                    dec edx                 ;уменьшить номер ячейки памяти
   405 00000201 E2EF                    loop metka1    ;повторение цикла 16 раз и вывод только остатка
   406                                  
   407                                  
   408                                  ;вывод битов
   409 00000203 B9[D2000000]            mov ecx, byteout
   410 00000208 BA10000000              mov edx, lbyteout
   411 0000020D E8EEFDFFFF              call PRINT
   412                                  
   413                                  ;переход на новую строку
   414 00000212 B9[39000000]            mov ecx,n
   415 00000217 BA01000000              mov edx,ln
   416 0000021C E8DFFDFFFF              call PRINT
   417                                  
   418                                  
   419                                                                               ;6 выход из программы
   420                                  
   421 00000221 B801000000              mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
   422 00000226 BB00000000              mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
   423 0000022B CD80                    int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
