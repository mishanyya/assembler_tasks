     1                                  SECTION .data        ;для инициализированных данных
     2                                  
     3 00000000 D092D0B2D0B5D0B4D0-     invite db "Введите первое число от 0 до 65535 включительно:",0xa,0
     3 00000009 B8D182D0B520D0BFD0-
     3 00000012 B5D180D0B2D0BED0B5-
     3 0000001B 20D187D0B8D181D0BB-
     3 00000024 D0BE20D0BED1822030-
     3 0000002D 20D0B4D0BE20363535-
     3 00000036 333520D0B2D0BAD0BB-
     3 0000003F D18ED187D0B8D182D0-
     3 00000048 B5D0BBD18CD0BDD0BE-
     3 00000051 3A0A00             
     4                                  linvite equ $-invite
     5                                  
     6 00000054 D092D0B2D0B5D0B4D0-     invite1 db "Введите второе число от 0 до 65535 включительно:",0xa,0
     6 0000005D B8D182D0B520D0B2D1-
     6 00000066 82D0BED180D0BED0B5-
     6 0000006F 20D187D0B8D181D0BB-
     6 00000078 D0BE20D0BED1822030-
     6 00000081 20D0B4D0BE20363535-
     6 0000008A 333520D0B2D0BAD0BB-
     6 00000093 D18ED187D0B8D182D0-
     6 0000009C B5D0BBD18CD0BDD0BE-
     6 000000A5 3A0A00             
     7                                  linvite1 equ $-invite1
     8                                  
     9 000000A8 D092D0B2D0B5D0B4D0-     invite2 db "Введите знак операции:",0xa,0
     9 000000B1 B8D182D0B520D0B7D0-
     9 000000BA BDD0B0D0BA20D0BED0-
     9 000000C3 BFD0B5D180D0B0D186-
     9 000000CC D0B8D0B83A0A00     
    10                                  linvite2 equ $-invite2
    11                                  
    12 000000D3 D0A0D0B5D0B7D183D0-     invite3 db "Результат:",0xa,0
    12 000000DC BBD18CD182D0B0D182-
    12 000000E5 3A0A00             
    13                                  linvite3 equ $-invite3
    14                                  
    15 000000E8 D09ED181D182D0B0D1-     invite4 db "Остаток:",0xa,0
    15 000000F1 82D0BED0BA3A0A00   
    16                                  linvite4 equ $-invite4
    17                                  
    18 000000F9 D097D0BDD0B0D0BA20-     nosign db "Знак не введен!",0xa,0
    18 00000102 D0BDD0B520D0B2D0B2-
    18 0000010B D0B5D0B4D0B5D0BD21-
    18 00000114 0A00               
    19                                  lnosign equ $-nosign
    20                                  
    21 00000116 D092D0B2D0B5D0B4D0-     nocorrectvalue db "Введено некорректное значение!",0xa,0
    21 0000011F B5D0BDD0BE20D0BDD0-
    21 00000128 B5D0BAD0BED180D180-
    21 00000131 D0B5D0BAD182D0BDD0-
    21 0000013A BED0B520D0B7D0BDD0-
    21 00000143 B0D187D0B5D0BDD0B8-
    21 0000014C D0B5210A00         
    22                                  lnocorrectvalue equ $-nocorrectvalue
    23                                  
    24                                  
    25 00000151 0A                      n db 0xa                   ;переменная для переноса строки
    26                                  ln equ $-n
    27                                  
    28                                  
    29                                  SECTION .bss         ;для НЕинициализированных данных
    30                                  ;при выделении памяти лучше выделить больше чем надо, хотя бы на 1 байт
    31                                  
    32                                  ;ввод символов
    33 00000000 ????????????            value1: resb 6                              ;выделение памяти в 5 байт, где value1 - адрес первого символа
    34                                  lvalue1 equ $-value1                        ;адрес с длиной сообщения
    35                                  
    36                                  ;ввод символов
    37 00000006 ????????????            value2: resb 6                              ;выделение памяти в 5 байт, где value2 - адрес первого символа
    38                                  lvalue2 equ $-value2
    39                                  
    40                                  ;ввод знака
    41 0000000C ????                    sign: resb 2                                ;выделение памяти в 1 байт, где sign - адрес первого символа
    42                                  lsign equ $-sign
    43                                  
    44                                  ;вывод целого результата
    45 0000000E <res Ah>                output: resb 10                             ;выделение памяти в 10 байт
    46                                  loutput equ $-output                        ;адрес с длиной сообщения
    47                                  
    48                                  ;вывод остатка от деления
    49 00000018 <res Ah>                output1: resb 10                             ;выделение памяти в 10 байт
    50                                  loutput1 equ $-output1                        ;адрес с длиной сообщения
    51                                  
    52                                  SECTION .text     ;начало кода самой программы
    53                                  
    54                                  ;инструкция ret подпрограммы использует стек и регистр RSP/ESP, поэтому его не трогать!
    55                                  ;вывод записи, использование стандартных обязательных данных
    56                                  PRINT:
    57 00000000 B804000000              mov eax,4
    58 00000005 BB01000000              mov ebx,1
    59 0000000A CD80                    int 80h       ;данные из rdx копируются в rax
    60 0000000C C3                      ret
    61                                  
    62                                  ;ввод записи
    63                                  WRITE:
    64 0000000D B803000000              mov eax,3
    65 00000012 BB00000000              mov ebx,0
    66 00000017 CD80                    int 80h      ;в rax помещается 0
    67 00000019 C3                      ret
    68                                  
    69                                  GLOBAL _start
    70                                      _start:
    71                                  ;вывод приглашения ввести символы
    72 0000001A B9[00000000]            mov ecx,invite       ;ввод адреса
    73 0000001F BA54000000              mov edx,linvite      ;ввод количества символов
    74 00000024 E8D7FFFFFF              call PRINT
    75                                  
    76                                  ;ввод первого значения
    77 00000029 B9[00000000]            mov ecx,value1       ;ввод адреса
    78 0000002E BA06000000              mov edx,lvalue1    ;ввод количества символов
    79 00000033 E8D5FFFFFF              call WRITE
    80                                  
    81 00000038 B9[A8000000]            mov ecx,invite2       ;ввод адреса
    82 0000003D BA2B000000              mov edx,linvite2    ;ввод количества символов
    83 00000042 E8B9FFFFFF              call PRINT
    84                                  
    85                                  ;ввод арифметического знака
    86 00000047 B9[0C000000]            mov ecx,sign       ;ввод адреса
    87 0000004C BA02000000              mov edx,lsign    ;ввод количества символов
    88 00000051 E8B7FFFFFF              call WRITE
    89                                  
    90                                  ;вывод приглашения ввести символы
    91 00000056 B9[54000000]            mov ecx,invite1       ;ввод адреса
    92 0000005B BA54000000              mov edx,linvite1      ;ввод количества символов
    93 00000060 E89BFFFFFF              call PRINT
    94                                  
    95                                  ;ввод второго значения
    96 00000065 B9[06000000]            mov ecx,value2       ;ввод адреса
    97 0000006A BA06000000              mov edx,lvalue2    ;ввод количества символов
    98 0000006F E899FFFFFF              call WRITE
    99                                  
   100                                  ;вывод результата
   101 00000074 B9[D3000000]            mov ecx,invite3       ;ввод адреса
   102 00000079 BA15000000              mov edx,linvite3      ;ввод количества символов
   103 0000007E E87DFFFFFF              call PRINT
   104                                  
   105                                  ;переставить первое число в памяти в обратном порядке
   106                                  ;проверка на символ '-' №45 в начале строки
   107 00000083 803C25[00000000]2D      cmp byte[value1],45
   108 0000008B 0F84EF030000            je incorrectvalue
   109                                  
   110 00000091 BF[00000000]            mov edi,value1   ;поместить адрес, т.е. указатель в регистр
   111 00000096 4831D2                  xor rdx,rdx        ;для счета значений
   112 00000099 4831C0                  xor rax,rax
   113 0000009C 66B90500                mov cx,5           ; счетчик
   114                                  input:
   115 000000A0 678A07                  mov al,byte[edi]    ;поместить значение в al
   116                                  ;проверка на число
   117 000000A3 3C30                    cmp al,48
   118 000000A5 7D02                    jge nextto
   119 000000A7 7C0E                    jl exitto
   120                                  nextto:
   121 000000A9 3C39                    cmp al,57
   122 000000AB 7E02                    jle inputok
   123 000000AD 7F08                    jg exitto
   124                                  inputok:
   125 000000AF 66FFC2                  inc dx
   126 000000B2 FFC7                    inc edi
   127 000000B4 50                      push rax
   128 000000B5 E2E9                    loop input
   129                                  exitto:  ;выход из цикла
   130 000000B7 89D1                    mov ecx,edx        ;счетчик
   131 000000B9 BF[00000000]            mov edi,value1     ;поместить адрес, т.е. указатель в регистр
   132                                  
   133                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   134 000000BE 83FA00                  cmp edx,0
   135 000000C1 7E08                    jle novalue
   136                                  opo:
   137 000000C3 58                      pop rax
   138 000000C4 678807                  mov byte[edi],al
   139 000000C7 FFC7                    inc edi
   140 000000C9 E2F8                    loop opo
   141                                  novalue:
   142                                  
   143                                  ;переставить второе число в памяти в обратном порядке
   144 000000CB BF[06000000]            mov edi,value2    ;поместить адрес, т.е. указатель в регистр
   145 000000D0 6631D2                  xor dx,dx            ;для счета значений
   146 000000D3 66B90500                mov cx,5              ; счетчик
   147                                  input1:
   148 000000D7 678A07                  mov al,byte[edi]       ;поместить значение в al
   149                                  ;проверка на число
   150 000000DA 3C30                    cmp al,48
   151 000000DC 7D02                    jge nextto1
   152 000000DE 7C0E                    jl exitto1
   153                                  nextto1:
   154 000000E0 3C39                    cmp al,57
   155 000000E2 7E02                    jle inputok1
   156 000000E4 7F08                    jg exitto1
   157                                  inputok1:
   158 000000E6 66FFC2                  inc dx
   159 000000E9 FFC7                    inc edi
   160 000000EB 50                      push rax
   161 000000EC E2E9                    loop input1
   162                                  exitto1:  ;выход из цикла
   163 000000EE 89D1                    mov ecx,edx        ;счетчик
   164 000000F0 BF[06000000]            mov edi,value2     ;поместить адрес, т.е. указатель в регистр
   165                                  
   166                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   167 000000F5 83FA00                  cmp edx,0
   168 000000F8 7E08                    jle novalue1
   169                                  opo1:
   170 000000FA 58                      pop rax
   171 000000FB 678807                  mov byte[edi],al
   172 000000FE FFC7                    inc edi
   173 00000100 E2F8                    loop opo1
   174                                  novalue1:
   175                                  
   176                                  ;;;;;;;;;;;
   177                                  ;поместить первое число в регистр esi, проверить его на корректность
   178                                  ;перенести его в si, сдвинуть вправо и поместить в стек
   179 00000102 31F6                    xor esi,esi         ;обнуление регистра для хранения промежуточного и итогового результата
   180 00000104 4831C0                  xor rax,rax         ;обнуление регистра
   181 00000107 31D2                    xor edx,edx         ;обнуление регистра
   182 00000109 BF[00000000]            mov edi,value1      ;поместить адрес, т.е. указатель в регистр
   183 0000010E 66BB0A00                mov bx,10         ;для хранения чисел со степенями 10
   184 00000112 678A07                  mov al,byte[edi]        ;поместить значение в ax
   185                                  ;проверка на число
   186 00000115 3C30                    cmp al,48
   187 00000117 7D02                    jge next
   188 00000119 7C55                    jl exit
   189                                  next:
   190 0000011B 3C39                    cmp al,57
   191 0000011D 7E02                    jle multi
   192 0000011F 7F4F                    jg exit
   193                                  multi:
   194 00000121 2C30                    sub al,'0'              ;получить числовое значение символа
   195 00000123 0FB6F0                  movzx esi,al           ;поместить 1-байтное значение из al в 4-байтный регистр esi
   196 00000126 FFC7                    inc edi                 ;увеличить адрес памяти на 1
   197 00000128 B903000000              mov ecx,3            ;счетчик по количеству символов
   198                                  mult:
   199 0000012D 678A07                  mov al,byte[edi]       ;поместить значение в ax
   200                                  ;проверка на число
   201 00000130 3C30                    cmp al,48
   202 00000132 7D02                    jge next1
   203 00000134 7C3A                    jl exit
   204                                  next1:
   205 00000136 3C39                    cmp al,57
   206 00000138 7E02                    jle multi1
   207 0000013A 7F34                    jg exit
   208                                  multi1:
   209 0000013C 2C30                    sub al,'0'          ;получить числовое значение символа
   210 0000013E 66F7E3                  mul bx            ;умножить ax*bx=dx ax
   211 00000141 6689C5                  mov bp,ax          ;внесение результата степени
   212 00000144 01EE                    add esi,ebp            ;добавить число к промежуточному значению
   213 00000146 B80A000000              mov eax,10            ;поместить 10 в eax
   214 0000014B 66F7E3                  mul bx               ;умножить ax*bx=dx ax, dx и ax 100.000 4 байта
   215 0000014E 6689C3                  mov bx,ax            ;поместить в bx = 100
   216 00000151 31C0                    xor eax,eax             ;обнулить eax
   217 00000153 FFC7                    inc edi              ;увеличить адрес памяти на 1
   218 00000155 E2D6                    loop mult
   219 00000157 678A07                  mov al,byte[edi]   ;поместить значение в ax
   220                                  ;проверка на число
   221 0000015A 3C30                    cmp al,48
   222 0000015C 7D02                    jge next2
   223 0000015E 7C10                    jl exit
   224                                  next2:
   225 00000160 3C39                    cmp al,57
   226 00000162 7E02                    jle multi2
   227 00000164 7F0A                    jg exit
   228                                  multi2:
   229 00000166 2C30                    sub al,'0'           ;получить числовое значение символа
   230 00000168 66F7E3                  mul bx            ;умножить ax*bx=dx ax  3*10000
   231 0000016B 6689C5                  mov bp,ax         ;внесение результата степени = 30000
   232 0000016E 01EE                    add esi,ebp         ;добавить число к промежуточному значению
   233                                  exit:
   234                                  ;;;;;;;;;;;;;;;;;;;;;;;;;
   235                                  ;проверка вводимого числа в регистре si, оно должно быть
   236                                  ;не меньше 0 и не больше 65535, которое помещается в 2-х байтном регистре
   237 00000170 81FEFFFF0000            cmp esi,65535
   238 00000176 0F8F04030000            jg incorrectvalue
   239                                  ;sub si,65536
   240                                  ;js incorrectvalue       ;если флаг знака SF=1
   241                                  ;по идее отрицательный результат операции можно проверить по флагу SF,
   242                                  ;но иногда проще проверить наличие знака '-' при вводе
   243                                  ;числа, номер символа 'минус' в ASCII №45
   244                                  
   245                                  
   246                                  ;;;;;;;;;;;;;;;;;;;;;;;
   247 0000017C C1E610                  shl esi,16      ;в связи с отсутствием свободных регистров
   248                                                  ;переносим результат для хранения в старшие 3 и 4 биты регистра esi
   249                                                  ;и тогда можно снова использовать регистр si
   250 0000017F 56                      push rsi   ;поместить значение из регистра rsi в стек
   251                                  
   252                                  ;;;;;;;;;;;
   253                                  ;проверка на символ '-' №45 в начале строки (ввод отрицательного числа)
   254 00000180 803C25[06000000]2D      cmp byte[value2],45
   255 00000188 0F84F2020000            je incorrectvalue
   256                                  
   257                                  ;поместить второе число в регистр esi, проверить его на корректность
   258                                  ;перенести его в si, затем скопировать из si в di,
   259                                  ;обнулить rsi, взять данные из стека,
   260                                  ;поместить в rsi и сложить с di
   261                                  
   262 0000018E 31F6                    xor esi,esi         ;обнуление регистра для хранения промежуточного и итогового результата
   263 00000190 4831C0                  xor rax,rax         ;обнуление регистра
   264 00000193 31D2                    xor edx,edx         ;обнуление регистра
   265 00000195 BF[06000000]            mov edi,value2    ;поместить адрес, т.е. указатель в регистр
   266 0000019A 66BB0A00                mov bx,10         ;для хранения чисел со степенями 10
   267 0000019E 678A07                  mov al,byte[edi]        ;поместить значение в ax
   268                                  ;проверка на число
   269 000001A1 3C30                    cmp al,48
   270 000001A3 7D02                    jge next3
   271 000001A5 7C55                    jl exit1
   272                                  next3:
   273 000001A7 3C39                    cmp al,57
   274 000001A9 7E02                    jle multi3
   275 000001AB 7F4F                    jg exit1
   276                                  multi3:
   277 000001AD 2C30                    sub al,'0'              ;получить числовое значение символа
   278 000001AF 0FB6F0                  movzx esi,al           ;поместить 2-байтное значение из al в 2-байтный регистр si
   279 000001B2 FFC7                    inc edi                 ;увеличить адрес памяти на 1
   280 000001B4 B903000000              mov ecx,3            ;счетчик по количеству символов
   281                                  mult1:
   282 000001B9 678A07                  mov al,byte[edi]  ;поместить значение в ax
   283                                  ;проверка на число
   284 000001BC 3C30                    cmp al,48
   285 000001BE 7D02                    jge next4
   286 000001C0 7C3A                    jl exit1
   287                                  next4:
   288 000001C2 3C39                    cmp al,57
   289 000001C4 7E02                    jle multi4
   290 000001C6 7F34                    jg exit1
   291                                  multi4:
   292 000001C8 2C30                    sub al,'0'        ;получить числовое значение символа
   293 000001CA 66F7E3                  mul bx            ;умножить ax*bx=dx ax
   294 000001CD 6689C5                  mov bp,ax         ;внесение результата степени
   295 000001D0 01EE                    add esi,ebp         ;добавить число к промежуточному значению
   296 000001D2 B80A000000              mov eax,10        ;поместить 10 в eax
   297 000001D7 66F7E3                  mul bx            ;умножить ax*bx=dx ax, dx и ax 100.000 4 байта
   298 000001DA 6689C3                  mov bx,ax         ;поместить в bx = 100
   299 000001DD 31C0                    xor eax,eax       ;обнулить eax
   300 000001DF FFC7                    inc edi           ;увеличить адрес памяти на 1
   301 000001E1 E2D6                    loop mult1
   302 000001E3 678A07                  mov al,byte[edi]  ;поместить значение в ax
   303                                  ;проверка на число
   304 000001E6 3C30                    cmp al,48
   305 000001E8 7D02                    jge next5
   306 000001EA 7C10                    jl exit1
   307                                  next5:
   308 000001EC 3C39                    cmp al,57
   309 000001EE 7E02                    jle multi5
   310 000001F0 7F0A                    jg exit1
   311                                  multi5:
   312 000001F2 2C30                    sub al,'0'        ;получить числовое значение символа
   313 000001F4 66F7E3                  mul bx            ;умножить ax*bx=dx ax  3*10000
   314 000001F7 6689C5                  mov bp,ax         ;внесение результата степени = 30000
   315 000001FA 01EE                    add esi,ebp         ;добавить число к промежуточному значению
   316                                  exit1:
   317                                  
   318                                  ;поместить второе число в регистр esi, скопировать из esi в edi,
   319                                  ;проверить его на корректность
   320                                  
   321                                  ;обнулить rsi, взять данные из стека,
   322                                  ;поместить в rsi и сложить с di
   323                                  
   324                                  ;копируем для сохранения из esi в edi
   325 000001FC 89F7                    mov edi,esi
   326                                  
   327                                  ;проверка вводимого числа в регистре si, оно должно быть
   328                                  ;не меньше 0 и не больше 65535, которое помещается в 2-х байтном регистре
   329                                  ;esi указан, так как в si большее число не поместится
   330 000001FE 81FEFFFF0000            cmp esi,65535
   331 00000204 0F8F76020000            jg incorrectvalue
   332                                  
   333 0000020A 4831F6                  xor rsi,rsi
   334 0000020D 5E                      pop rsi
   335 0000020E 6601FE                  add si,di
   336                                  
   337                                  
   338 00000211 31C0                    xor eax,eax  ;обнуление
   339 00000213 31D2                    xor edx,edx  ;обнуление
   340                                  ;;;;;;;;;;;;;;;
   341                                  
   342                                  ;содержит значение:
   343                                  ;1 байт не больше 255
   344                                  ;2 байта не больше 65535
   345                                  ;4 байта не больше 4.294.967.295
   346                                  ;8 байт не больше 1,844674407×10¹⁹
   347                                  
   348                                  ;поместить одно значение в регистр ax
   349                                  ;а второе поместить в регистр si
   350 00000215 6689F0                  mov ax,si          ;получить второе! значение
   351 00000218 C1EE10                  shr esi,16         ;передвинуть первое! значение в регистр si
   352                                  ;;;;;;;;;;;;;;;;;;;;;
   353                                  ;eax и edx- обнулены
   354                                  ;данные введены
   355                                  ;si - первое! число
   356                                  ;ax - второе! число
   357                                  ;byte[sign] - символ знака
   358 0000021B 6696                    xchg si,ax  ;меняем их местами, так как надо ax - первое , а si - второе число!!!
   359                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
   360                                  ;умножение работает
   361                                  ;mov cl,byte[sign]   ;перевести числовое значение из byte[sign] в cl
   362                                  ;mov ch,'*'        ;номер в регистре обычно обозначает номер символа в ASCII
   363                                  ;not ch              ;а затем в обратную двоичную форму
   364                                  ;test cl,ch     ;сравнение символа и инвертированной маски
   365                                  ;jz yesmul      ;если значения обратно сопоставимы и установился ZF=1
   366                                  
   367                                  ;деление работает
   368                                  ;mov cl,byte[sign]   ;перевести числовое значение из byte[sign] в cl
   369                                  ;mov ch,'/'        ;номер в регистре обычно обозначает номер символа в ASCII
   370                                  ;not ch              ;а затем в обратную двоичную форму
   371                                  ;test cl,ch     ;сравнение символа и инвертированной маски
   372                                  ;jz yesdiv            ;если значения обратно сопоставимы и установился ZF=1
   373                                  
   374                                  ;сложение и вычитание пока не работает
   375 0000021D 8A0C25[0C000000]        mov cl,byte[sign]   ;перевести числовое значение из byte[sign] в cl
   376 00000224 B52B                    mov ch,'+'        ;номер в регистре обычно обозначает номер символа в ASCII
   377 00000226 F6D5                    not ch              ;а затем в обратную двоичную форму
   378 00000228 84E9                    test cl,ch     ;сравнение символа и инвертированной маски
   379 0000022A 0F84C1010000            jz yesadd            ;если значения обратно сопоставимы и установился ZF=1
   380                                  
   381                                  
   382                                  ;test cl,'-'     ;-
   383                                  ;jz             ;если значения обратно сопоставимы и установился ZF=1
   384                                  
   385 00000230 0F855B020000            jnz tonosign   ;если значения обратно НЕ сопоставимы и установился ZF=0
   386                                  
   387                                  ;;;;;;;;;;;;;;;;;;
   388                                  ;операция умножения
   389                                  yesmul:
   390                                  ;выполнить операцию умножения
   391 00000236 66F7E6                  mul si             ;умножаем ax на si и результат в dx и ax
   392                                  
   393                                  ;вывод результата умножения из регистров dx ax в память output
   394                                  ;перенести результат из dx ax в память  output
   395 00000239 BF[0E000000]            mov edi,output   ;получить адрес output
   396                                  ;add edi,loutput-1  ;адрес последнего символа
   397                                  ;деление 8-и байтных значений
   398                                  ;div 4-х байтный регистр
   399                                  ;edx eax/4-х байтный регистр = eax (результат) и edx (остаток)
   400                                  ;4 байта - число не более 4.294.967.295
   401 0000023E B90A000000              mov ecx,10  ;счетчик
   402 00000243 BE0A000000              mov esi,10  ;для вывода в 10-м формате
   403                                  ;edx 0000fffe и eax 00000001 не работает деление!!!
   404                                  ;пробуем перенести значение из (e)dx в начало регистра eax
   405 00000248 C1E210                  shl edx,16     ;сдвинуть значение влево из 2-х байного dx в начало 4-х байтного регистра edx
   406 0000024B 6689C2                  mov dx,ax      ;перенести значение из ax в dx
   407 0000024E 89D0                    mov eax,edx    ;перенести полное значение из edx в eax для деления
   408 00000250 31D2                    xor edx,edx    ;обнулить edx для деления, так как значение оттуда убрали
   409                                  again:
   410 00000252 F7F6                    div esi      ;делим на 4-х байтный регистр, так как делимое в 4-х байтном регистре
   411                                               ;eax (результат, так как делим на 4-х байтный регистр)
   412                                               ;edx (остаток, так как делим на 4-х байтный регистр)
   413                                               ;так как делим на 10, то остаток, который меньше 10 поместится в dl
   414                                  
   415 00000254 678817                  mov byte[edi],dl
   416 00000257 67800730                add byte[edi],'0'
   417 0000025B 31D2                    xor edx,edx     ;обнуляем edx, так как там есть остаток, участвующий в следующем делении
   418 0000025D FFC7                    inc edi
   419                                  
   420 0000025F 83F80A                  cmp eax,10
   421 00000262 7C04                    jl no   ;если результат <10
   422 00000264 7D00                    Jge nextend
   423                                  nextend:
   424                                  
   425 00000266 E2EA                    loop again
   426                                  no:            ;далее
   427 00000268 678807                  mov byte[edi],al
   428 0000026B 67800730                add byte[edi],'0'
   429                                  
   430                                  ;переставить числа в памяти в обратном порядке
   431 0000026F BF[0E000000]            mov edi,output    ;поместить адрес, т.е. указатель в регистр
   432 00000274 6631D2                  xor dx,dx            ;для счета значений
   433 00000277 66B90A00                mov cx,10              ; счетчик
   434                                  
   435                                  inputout:
   436 0000027B 678A07                  mov al,byte[edi]       ;поместить значение в al
   437                                  
   438                                  ;проверка на число
   439 0000027E 3C30                    cmp al,48
   440 00000280 7D02                    jge nexttoout
   441 00000282 7C0E                    jl exittoout
   442                                  nexttoout:
   443 00000284 3C39                    cmp al,57
   444 00000286 7E02                    jle inputokout
   445 00000288 7F08                    jg exittoout
   446                                  
   447                                  inputokout:
   448 0000028A 66FFC2                  inc dx
   449 0000028D FFC7                    inc edi
   450 0000028F 50                      push rax
   451 00000290 E2E9                    loop inputout
   452                                  
   453                                  exittoout:  ;выход из цикла
   454                                  
   455 00000292 89D1                    mov ecx,edx        ;счетчик
   456 00000294 BF[0E000000]            mov edi,output     ;поместить адрес, т.е. указатель в регистр
   457                                  
   458                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   459 00000299 83FA00                  cmp edx,0
   460 0000029C 7E08                    jle novalue3
   461                                  opoout:
   462 0000029E 58                      pop rax
   463 0000029F 678807                  mov byte[edi],al
   464 000002A2 FFC7                    inc edi
   465 000002A4 E2F8                    loop opoout
   466                                  novalue3:
   467 000002A6 EB00                    jmp tofinish
   468                                  
   469                                  tofinish:
   470                                  ;вывод результата
   471 000002A8 B9[0E000000]            mov ecx,output       ;ввод адреса
   472 000002AD BA0A000000              mov edx,loutput     ;ввод количества символов
   473 000002B2 E849FDFFFF              call PRINT
   474 000002B7 E9E6010000              jmp tomainfinish
   475                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   476                                  
   477                                  yesdiv:
   478                                  
   479                                  ;операция деления
   480                                  
   481                                  ;делимое - 1 или 2 байта
   482                                  ;делитель - 1 или 2 байта
   483                                  ;поэтому используем операцию div 2-байтный регистр
   484                                  ;DX AX / 2-байта = целое AX + остаток DX
   485                                  
   486                                  ;число si не должно равняться 0!
   487 000002BC 6683FE00                cmp si,0
   488 000002C0 0F84BA010000            je incorrectvalue
   489                                  
   490 000002C6 66F7F6                  div si            ;делим dx ax на si, целое в ax остаток в dx
   491 000002C9 6689D5                  mov bp,dx        ;сдвигаем остаток в регистр bp
   492                                  ;вывод результата деления из регистра ax в память output
   493 000002CC BF[0E000000]            mov edi,output   ;получить адрес output
   494 000002D1 B905000000              mov ecx,5  ;счетчик, так как если максим число 65535/1 получится целое из 5 знаков
   495 000002D6 66BE0A00                mov si,10  ;для вывода в 10-м формате
   496 000002DA 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   497                                  
   498                                  againdiv:
   499 000002DD 66F7F6                  div si
   500 000002E0 678817                  mov byte[edi],dl   ;остаток
   501 000002E3 67800730                add byte[edi],'0'
   502 000002E7 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   503 000002EA FFC7                    inc edi
   504 000002EC 6683F80A                cmp ax,10
   505 000002F0 7C02                    jl no1   ;если результат <10
   506 000002F2 E2E9                    loop againdiv
   507                                  no1:            ;далее
   508 000002F4 678807                  mov byte[edi],al
   509 000002F7 67800730                add byte[edi],'0'
   510                                  
   511                                  ;переставить числа в памяти в обратном порядке
   512 000002FB BF[0E000000]            mov edi,output    ;поместить адрес, т.е. указатель в регистр
   513 00000300 6631D2                  xor dx,dx            ;для счета значений и так пустой регистр после деления
   514 00000303 66B90500                mov cx,5             ;счетчик
   515                                  inputoutdiv:
   516 00000307 678A07                  mov al,byte[edi]
   517                                  
   518                                  ;проверка на число
   519 0000030A 3C30                    cmp al,48
   520 0000030C 7D02                    jge nexttooutdiv
   521 0000030E 7C0E                    jl exittooutdiv
   522                                  nexttooutdiv:
   523 00000310 3C39                    cmp al,57
   524 00000312 7E02                    jle inputokoutdiv
   525 00000314 7F08                    jg exittooutdiv
   526                                  
   527                                  inputokoutdiv:
   528 00000316 66FFC2                  inc dx
   529 00000319 FFC7                    inc edi
   530 0000031B 50                      push rax
   531 0000031C E2E9                    loop inputoutdiv
   532                                  exittooutdiv:  ;выход из цикла
   533                                  
   534 0000031E 6689D1                  mov cx,dx        ;счетчик
   535 00000321 BF[0E000000]            mov edi,output     ;поместить адрес, т.е. указатель в регистр 1
   536                                  
   537                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   538 00000326 6683FA00                cmp dx,0
   539 0000032A 7E08                    jle novalue2
   540                                  
   541                                  opooutdiv:
   542 0000032C 58                      pop rax
   543 0000032D 678807                  mov byte[edi],al
   544 00000330 FFC7                    inc edi
   545 00000332 E2F8                    loop opooutdiv
   546                                  novalue2:
   547                                  
   548                                  ;вывод целого значения от результата
   549 00000334 B9[0E000000]            mov ecx,output       ;ввод адреса
   550 00000339 BA0A000000              mov edx,loutput     ;ввод количества символов
   551 0000033E E8BDFCFFFF              call PRINT
   552                                  
   553                                  ;переход на новую строку
   554 00000343 B9[51010000]            mov ecx,n
   555 00000348 BA01000000              mov edx,ln
   556 0000034D E8AEFCFFFF              call PRINT
   557                                  
   558                                  
   559                                  ;вывод остатка от деления из регистра bx в память output1
   560 00000352 6689E8                  mov ax,bp         ;остаток от основного деления
   561 00000355 BF[18000000]            mov edi,output1   ;получить адрес output1
   562 0000035A 66B90500                mov cx,5  ;счетчик, так как если максим число 65535/65534 получится целое из 5 знаков
   563 0000035E 66BE0A00                mov si,10  ;для вывода в 10-м формате
   564 00000362 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   565                                  
   566                                  againdiv1:
   567 00000365 66F7F6                  div si
   568 00000368 678817                  mov byte[edi],dl  ;остаток как и положено помещен из dl в память
   569 0000036B 67800730                add byte[edi],'0'
   570 0000036F 6631D2                  xor dx,dx    ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   571 00000372 FFC7                    inc edi
   572 00000374 6683F80A                cmp ax,10
   573 00000378 7C02                    jl no2   ;если результат <10
   574 0000037A E2E9                    loop againdiv1
   575                                  no2:            ;далее
   576 0000037C 678807                  mov byte[edi],al
   577 0000037F 67800730                add byte[edi],'0'
   578                                  
   579                                  ;переставить числа в памяти в обратном порядке
   580 00000383 BF[18000000]            mov edi,output1   ;поместить адрес, т.е. указатель в регистр
   581 00000388 6631D2                  xor dx,dx          ;для счета значений и так пустой регистр после деления
   582 0000038B 4831C9                  xor rcx,rcx       ;в регистре rcx остался адрес памяти
   583 0000038E 66B90500                mov cx,5             ;счетчик
   584                                  
   585                                  inputoutdiv2:
   586 00000392 678A07                  mov al,byte[edi]
   587                                  ;проверка на число
   588 00000395 3C30                    cmp al,48
   589 00000397 7D02                    jge nexttooutdiv2
   590 00000399 7C0E                    jl exittooutdiv2
   591                                  nexttooutdiv2:
   592 0000039B 3C39                    cmp al,57
   593 0000039D 7E02                    jle inputokoutdiv2
   594 0000039F 7F08                    jg exittooutdiv2
   595                                  inputokoutdiv2:
   596 000003A1 66FFC2                  inc dx
   597 000003A4 FFC7                    inc edi
   598 000003A6 50                      push rax
   599 000003A7 E2E9                    loop inputoutdiv2
   600                                  
   601                                  exittooutdiv2:  ;выход из цикла
   602                                  
   603 000003A9 6689D1                  mov cx,dx       ;счетчик
   604 000003AC BF[18000000]            mov edi,output1     ;поместить адрес, т.е. указатель в регистр 1
   605                                  
   606                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   607 000003B1 6683FA00                cmp dx,0
   608 000003B5 7E08                    jle novalue4
   609                                  
   610                                  
   611                                  opooutdiv2:
   612 000003B7 58                      pop rax
   613 000003B8 678807                  mov byte[edi],al
   614 000003BB FFC7                    inc edi
   615 000003BD E2F8                    loop opooutdiv2
   616                                  novalue4:
   617                                  
   618                                  ;вывод остатка результата
   619 000003BF B9[E8000000]            mov ecx,invite4       ;ввод адреса
   620 000003C4 BA11000000              mov edx,linvite4     ;ввод количества символов
   621 000003C9 E832FCFFFF              call PRINT
   622                                  
   623                                  ;вывод целого значения от результата
   624 000003CE B9[18000000]            mov ecx,output1       ;ввод адреса
   625 000003D3 BA0A000000              mov edx,loutput1     ;ввод количества символов
   626 000003D8 E823FCFFFF              call PRINT
   627                                  
   628                                  ;переход на новую строку
   629 000003DD B9[51010000]            mov ecx,n
   630 000003E2 BA01000000              mov edx,ln
   631 000003E7 E814FCFFFF              call PRINT
   632                                  
   633 000003EC E9B1000000              jmp tomainfinish
   634                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   635                                  ;операция сложения
   636                                  yesadd:
   637 000003F1 01C6                    add esi,eax    ;сложить регистры, а результат в esi
   638 000003F3 6689F0                  mov ax,si      ;меньшие 2 байта поместить в ax
   639 000003F6 C1EE10                  shr esi,16     ;сдвинуть значение в esi на 16 битов
   640 000003F9 6689F2                  mov dx,si      ;старшие 2 бита от суммы esi поместить в dx
   641                                  
   642                                  ;вывод результата деления из регистра ax в память output
   643 000003FC BF[0E000000]            mov edi,output   ;получить адрес output
   644 00000401 66B90600                mov cx,6  ;счетчик, так как если максим сумма для чисел 65535 поместится в 6 знаков
   645 00000405 66BE0A00                mov si,10  ;для вывода в 10-м формате
   646                                  
   647                                  
   648                                  againdiv13:
   649 00000409 66F7F6                  div si
   650 0000040C 678817                  mov byte[edi],dl   ;остаток
   651 0000040F 67800730                add byte[edi],'0'
   652 00000413 6631D2                  xor dx,dx     ;обнуляем dx, так как там есть остаток, участвующий в следующем делении
   653 00000416 FFC7                    inc edi
   654 00000418 6683F80A                cmp ax,10
   655 0000041C 7C02                    jl no13   ;если результат <10
   656 0000041E E2E9                    loop againdiv13
   657                                  no13:            ;далее
   658 00000420 678807                  mov byte[edi],al
   659 00000423 67800730                add byte[edi],'0'
   660                                  
   661                                  ;переставить числа в памяти в обратном порядке
   662 00000427 BF[0E000000]            mov edi,output    ;поместить адрес, т.е. указатель в регистр
   663 0000042C 6631D2                  xor dx,dx            ;для счета значений и так пустой регистр после деления
   664 0000042F 66B90600                mov cx,6             ;счетчик
   665                                  inputoutdiv13:
   666 00000433 678A07                  mov al,byte[edi]
   667                                  
   668                                  ;проверка на число
   669 00000436 3C30                    cmp al,48
   670 00000438 7D02                    jge nexttooutdiv13
   671 0000043A 7C0E                    jl exittooutdiv13
   672                                  nexttooutdiv13:
   673 0000043C 3C39                    cmp al,57
   674 0000043E 7E02                    jle inputokoutdiv13
   675 00000440 7F08                    jg exittooutdiv13
   676                                  
   677                                  inputokoutdiv13:
   678 00000442 66FFC2                  inc dx
   679 00000445 FFC7                    inc edi
   680 00000447 50                      push rax
   681 00000448 E2E9                    loop inputoutdiv13
   682                                  exittooutdiv13:  ;выход из цикла
   683                                  
   684 0000044A 6689D1                  mov cx,dx        ;счетчик
   685 0000044D BF[0E000000]            mov edi,output     ;поместить адрес, т.е. указатель в регистр 1
   686                                  
   687                                  ;если ничего не вводилось, перепрыгиваем извлечение из стека
   688 00000452 6683FA00                cmp dx,0
   689 00000456 7E08                    jle novalue13
   690                                  
   691                                  opooutdiv13:
   692 00000458 58                      pop rax
   693 00000459 678807                  mov byte[edi],al
   694 0000045C FFC7                    inc edi
   695 0000045E E2F8                    loop opooutdiv13
   696                                  novalue13:
   697                                  
   698                                  
   699                                  ;вывод результата
   700 00000460 B9[0E000000]            mov ecx,output       ;ввод адреса
   701 00000465 BA0A000000              mov edx,loutput     ;ввод количества символов
   702 0000046A E891FBFFFF              call PRINT
   703                                  
   704                                  ;переход на новую строку
   705 0000046F B9[51010000]            mov ecx,n
   706 00000474 BA01000000              mov edx,ln
   707 00000479 E882FBFFFF              call PRINT
   708 0000047E EB22                    jmp tomainfinish
   709                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   710                                  ;операция вычитания
   711                                  
   712                                  ;;;;;;;;;;;;;;;;;;;;;;;;;
   713                                  incorrectvalue:
   714                                  ;введено некорректное значение
   715 00000480 B9[16010000]            mov ecx,nocorrectvalue       ;ввод адреса
   716 00000485 BA3B000000              mov edx,lnocorrectvalue      ;ввод количества символов
   717 0000048A E871FBFFFF              call PRINT
   718 0000048F EB11                    jmp tomainfinish
   719                                  
   720                                  tonosign:
   721                                  ;знак не введен
   722 00000491 B9[F9000000]            mov ecx,nosign       ;ввод адреса
   723 00000496 BA1D000000              mov edx,lnosign      ;ввод количества символов
   724 0000049B E860FBFFFF              call PRINT
   725 000004A0 EB00                    jmp tomainfinish
   726                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   727                                  tomainfinish:
   728                                  ;перенос строки
   729 000004A2 B9[51010000]            mov ecx,n       ;ввод адреса
   730 000004A7 BA01000000              mov edx,ln     ;ввод количества символов
   731 000004AC E84FFBFFFF              call PRINT                                      ;6 выход из программы
   732                                  
   733 000004B1 B801000000              mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
   734 000004B6 BB00000000              mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
   735 000004BB CD80                    int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
