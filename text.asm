
;- получить из стека командную строку (содержащую имя файла и
;параметры, переданные программе при запуске);
;- первый параметр вывести на экран красным цветом, второй —
;синим и с новой строки.
;- выполнить побайтный «переворот» содержимого файла, имя которого задано первым параметром командной
; строки; информацию записывать в этот же файл без промежуточных и дополнительных файлов,
;с использованием отображения файла на память;
;- каждая файловая операция контролируются на ошибку без анализа ее номера с выдачей на
;терминал своего сообщения, типа
;;«Ошибка открытия файла», «Ошибка записи» и т.д.
;-; завершить программу.

;ввести в командной строке ./text forsearch.txt
;вывысти ./text красным цветом
;перейти на новую строку
;вывысти forsearch.txt синим цветом

;"^[[5;34;42mIn color"

;Командная строка:

;forsearch.txt Ctrl+@ Ctrl+V+Esc [;31;m   Ctrl+V+Esc [;34;m    Ctrl+V+Esc[1E

SECTION .data        ;для инициализированных данных

invite1 db "Введите с клавиатуры адрес/имя файла forsearch.txt Ctrl+@",0xa,0
;символ NUL обозначается ^@ и вводится с помощью клавиш Ctrl+@
linvite1 equ $-invite1

match db "Найдено",0xa,0
lmatch equ $-match

nomatch db "Не найдено",0xa,0
lnomatch equ $-nomatch

filetoopen: db "forsearch.txt",0 ;ввод адреса
lfiletoopen equ $-filetoopen
;return rax=fffffffffffffffe или 18446744073709551614,а eax=-2
;не меняется при изменении имени файла



n db 0xa                   ;переменная для переноса строки

SECTION .bss         ;для НЕинициализированных данных
input: resb 100               ;что ищем
linput equ $-input

input2: resb 100               ;где ищем
linput2 equ $-input2

input3: resb 100               ;выделение памяти в 10 байт, где input3- адрес первого символа
linput3 equ $-input3             ;адрес с длиной сообщения

input4: resb 1               ;выделение памяти в 1 байт, где input4- адрес первого символа
linput4 equ $-input4             ;адрес с длиной сообщения


SECTION .text      ;начало кода самой программы
GLOBAL _start
      _start:

;показать параметры программы , которые вводятся в командной строке
;и помещаются в стек, например:
;./text one two three four five six seven - передача параметров

;первый элемент в стеке - количество введенных символов в ком.строке, включая имя,
;исполняемого файла, добавляем символ '0' для вывода этого числа на экран

;вывод кол-ва элементов из стека
pop rbx
add bl,'0'
mov [input4],bl

mov ecx,input4       ;ввод адреса
mov edx,linput4      ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

;вывод переноса строки
 mov ecx,n   ;ввод полученного адреса памяти
 mov edx,1      ;ввод количества символов
 mov eax,4
 mov ebx,1
 int 80h

;ввод через командную строку на ассемблере, это то же, что и
;функция int main(int argc, char *argv[]); на языке C;
;например ввод в строке:  ./text 1 2  9
;выводит 4(кол-во элементов) и указатели/адрес для каждого элемента  .129(первый символ каждого элемента)


;вывод элементов массива, работает!
;пробелы не учитываются!
;кол-во элементов должно быть не меньше выводов из стека!!!
;показывает только первый символ из каждого элемента!!!
;выводит в порядке ввода, т.е. ввод в стек начинается с последнего вводимого элемента, заодно и
;идет подсчет элементов!

;вывод первых 8 символов из стека
;mov esi,input3  ;в esi адрес первого символа
;pop rdi         ;адрес из стека
;mov rbp,[rdi] ;содержимое по адресу из стека
;mov [esi],rbp
;вывод следующих символов из стека, без пробела, который заменялся повторно символом
;add esi,7
;pop rdi         ;адрес из стека
;mov rbp,[rdi] ;содержимое по адресу из стека
;mov [esi],rbp
;всего выводится 15 символов, можно и 16, но один символ за пробелом дублипуется


;адрес ячейки стека содержится в rsp
;mov esi,input3  ;в esi адрес первого символа

;./text qwerty
;mov rsi,qword[rsp]       ;ввод адреса начальной ячейки/вершины стека в rsi

mov rsi,qword[rsp]       ;ввод адреса начальной ячейки/вершины стека в rsi
;mov ax,byte[rsi]        ;ввод содержимого по адресу esi в ah - 1 символ и 1 же символ выведет
;mov ax,word[rsi]        ;ввод содержимого по адресу esi в ax - 2 символа и 2 же символа выведет
;mov eax,dword[rsi]      ;ввод содержимого по адресу esi в eax - 4 символа и 4 же символа выведет
;mov rax,qword[rsi]       ;ввод содержимого по адресу esi в eax - 8 символов и 8 же символов выведет
                         ;даже из двух значений, например ./text qwerty выведет ./textq - их 7!, но
                         ;пробел исчез!

;mov rax,qword[rsi+1]     ;вывод /textqw
;mov rax,qword[rsi+2]     ;вывод textqwe
;mov rax,qword[rsi+4]     ;вывод xtqwert
;mov rax,qword[rsi+5]     ;вывод tqwerty
;mov rax,qword[rsi+6]     ;вывод  qwerty
;mov rax,qword[rsi+8]     ;вывод wertySH
;mov rax,qword[rsi+9]     ;вывод ertySHE
;./text qwerty1234567
;mov rax,qword[rsi+9]     ;вывод erty1234
;mov rax,qword[rsi+16]    ;вывод ./text 4567SHE
;./text qwerty1234567890asdfgh
;mov rax,qword[rsi+16] ;вывод 4567890a
;mov rax,qword[rsi+24] ;вывод sdfghSH
;./text qwertyuiop1234567890asdfghjkl
;mov rax,qword[rsi+24] ;вывод 890asdfg
;mov rax,qword[rsi+32] ;вывод hjklSHE

;pop rax ;переход к следующему нижнему уровню стека
;mov rsi,qword[rsp]       ;ввод адреса начальной ячейки/вершины стека в rsi
;mov rax,qword[rsi] ;вывод qwertyS - т.е. символы следующего (второго) арнумента строки!
;mov [input3],rax   ;поместить от 1 до 8 символов, которые будут выведены

;Вывод: элемент длины от1 до 8 байт можно вывести используя адрес начала строки от byte[rsp] до qword[rsp],
;если кол-во символов аргумента командной строки больше этого кол-ва, то надо использовать
;для получения следующих символов увеличение адреса, например
;mov rsi,qword[rsp]       ;ввод адреса начальной ячейки/вершины стека в rsi
;mov rax,qword[rsi+4]       ;вывод qwertyS - т.е. символы следующего (второго) арнумента строки!

;Для вывода следующего аргумента надо использовать команду pop для вывода из следующей ячейки стека!




mov ecx,input3       ;ввод адреса
mov edx,linput3      ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

;./text qwerty
;2
;./te/t





;- открыть файл, прочитать его в буфер и найти в содержимом подстроку, используя строковые инструкции;-
;mov eax,5             ;open
;mov ebx,filetoopen    ;имя/адрес файла
;mov ecx,0             ;0-read, 1-write, 2-read and write
;int 80h

;возвращаемое значение — неотрицательное целое число, равное дескриптору файла.
;в случае ошибки возвращается значение -1.

;mov edi,eax   ;filedes - дескриптор отображаемого файла, описатель файла
;mov eax,192     ;90-возможно устаревший системный вызов, № системного вызова  192 работает, а 90 - нет
;mov ebx,0     ;*address - указатель/адрес участка памяти процесса, в который отображается содержимое файла, обычно 0
;mov ecx,50    ;length - длина отображаемого участка файла с начала или с символа offset (по умолчанию = 0)
;mov edx,1     ;protect - защита файла, 0 - доступ запрещен, 1 - read, 2 - write, 4 - для исполнения кода
;mov esi,2     ;flags - 1 или 2 передача изменений: да или нет
;mov edi,1     ;filedes - дескриптор отображаемого файла, описатель файла, 1 - для вывода данных
;mov ebp,0     ;offset - от какого символа считать начало отображаемого текста
;int 80h
;возвращает fffffffffffffff2 в rax

;вывод результата
 ;mov ecx,eax   ;ввод полученного адреса памяти от mmap
 ;mov edx,50      ;ввод количества символов
 ;mov eax,4
 ;mov ebx,1
 ;int 80h

 ;закрыть файл
 ;mov eax,6
 ;mov ebx,0    ;дескриптор
 ;int 0x80
;возвращаемое значение — 0; значение -1 возвращается в случае ошибки.

;- завершить программу.+
;вывод переноса строки
 mov ecx,n   ;ввод полученного адреса памяти
 mov edx,1      ;ввод количества символов
 mov eax,4
 mov ebx,1
 int 80h

mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
