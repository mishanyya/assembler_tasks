SECTION .data        ;для инициализированных данных

invite db "Введите несколько букв и цифр:",0xa,0
linvite equ $-invite

aless db "less",0xa,0
lless equ $-aless

agreater db "greater",0xa,0
lgreater equ $-agreater

aequal db "equal",0xa,0
lequal equ $-aequal


n db 0xa                   ;переменная для переноса строки

SECTION .bss         ;для НЕинициализированных данных
;ввод символов
input: resb 100                              ;выделение памяти в 100 байт, где input- адрес первого символа
linput equ $-input                           ;адрес с длиной сообщения

;вывод повторяющихся символов
output: resb 100                              ;выделение памяти в 100 байт, где output - адрес первого символа
loutput equ $-output                            ;адрес с длиной сообщения

;вывод неповторяющихся символов
nodub: resb 10                              ;выделение памяти в 10 байт, где output - адрес первого символа
lnodub equ $-nodub                            ;адрес с длиной сообщения

SECTION .text     ;начало кода самой программы


GLOBAL _start

;подпрограммы
;вывод записи, использование стандартных обязательных данных
PRINT:
mov eax,4
mov ebx,1
int 80h
ret

;ввод записи
WRITE:
mov eax,3
mov ebx,0
int 80h
ret

    _start:

;отсюда начинается обработка и ввод данных:




;вывод приглашения ввести символы
mov ecx,invite       ;ввод адреса
mov edx,linvite      ;ввод количества символов
call PRINT

;ввод символов
mov ecx,input       ;ввод адреса
mov edx,linput     ;ввод количества символов
call WRITE

;по моему здесь выдает в gdb ;Program received signal SIGSEGV, Segmentation fault
;поместить адрес из памяти в регистр
mov esi,input
mov edi,output

;кол-во циклов для ввода найденных чисел в память output
mov ecx,linput

;следующий символ
next:

;перенос значений из input в output через 1-байтный регистр bpl для сравнения
mov al,byte[esi]

;проверяем каждый символ 10 раз на совпадение с цифрой от от 0 до 9

;в ASCII с 48 по 57 номера цифр
;0 - 48 или 00110000b, для поиска ставим 11001111b
;1 - 49 или 00110001b, для поиска ставим 11001110b
;2 - 50 или 00110010b, для поиска ставим 11001101b
;3 - 51 или 00110011b, для поиска ставим 11001100b
;4 - 52 или 00110100b, для поиска ставим 11001011b
;5 - 53 или 00110101b, для поиска ставим 11001010b
;6 - 54 или 00110110b, для поиска ставим 11001010b
;7 - 55 или 00110111b, для поиска ставим 11001000b
;8 - 56 или 00111000b, для поиска ставим 11000111b
;9 - 57 или 00111001b, для поиска ставим 11000110b
;проверим каждое значение методом test
;сравнение символа через его номер в ASCII в 2-м формате с инвертированной маской этого номера в том же виде
;при замене 0 на 1 и наоборот - при операции И или TEST во флаг ZF помещается 1,  и можно осуществить переход по условию
;например ,если для поиска 001100b использовать 110011b, то искомый результат будет 0, а при любом другом значении - 1
;если совпадает
;jnz yes  ;ZF = 0    1 и 1 = 1, а остальные комбинации = 0
;если не совпадает
;jz   ZF = 1

mov ah,'0'        ;номер в регистре обычно обозначает номер символа в ASCII
                 ;он может быть в двоичной форме или десятичной, например 00111001b или 57
                 ;или же просто указать сам символ в ковычках, и он автоматически переведется в номер
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
;т.к. №0 в таблице=48 или 001100000b, то ставим инвертированное (замененное) значение 11001111b
jz yes

mov ah,'1'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah               ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

mov ah,'2'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah               ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

mov ah,'3'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

mov ah,'4'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

mov ah,'5'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

mov ah,'6'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

mov ah,'7'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah               ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

mov ah,'8'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

mov ah,'9'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz yes

;если не найдена цифра

;увеличение адресов на 1, т.е. получение следующей ячейки памяти
inc esi          ;только для адреса ввода, для вывода не надо!!! иначе память вывода расходуется впустую!!!

;на проверку следующего символа
loop next

;на выход
jmp exit

;ввод символа в память out
yes:
;перенос значений в output через 1-байтный регистр al
mov byte[edi],al

;увеличение адресов на 1, т.е. получение следующей ячейки памяти
inc esi
inc edi

;на проверку следующего символа
loop next

;на выход
jmp exit

exit:
;вывод введенных символов
mov ecx,output       ;ввод адреса
mov edx,loutput      ;ввод количества символов
call PRINT

;переход на новую строку
mov ecx, n
mov edx, 1
call PRINT


;;;;;;;;;;;;


;замена значений в памяти
mov edi,loutput
mov ebx,loutput
mov esi,output
mov ebp,esi


dec edi
mov ecx,edi
two:
mov dh,byte[esi]
inc esi

;все работает, кроме реакции на пустой символа
;если появляется NULL, то надо брать следующий символ и вставлять опять в ту же ячейку

one:

cmp dh,byte[esi]
jg greater
jl less
je equal
greater:

;если символы кончились, то выходим
;если пробел вместо числа
mov ah,0   ;если символ с номером 0, т.е. null, или пустое место (не пробел!)
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test dh,ah                ;проверяем на null, не 0! и не НОЛЬ!, обозначение символа в таблице ASCII в двоичном формате
;т.к. №NULL в таблице=0 или 000000000b, то ставим инвертированное (замененное) значение 11111111b
jz toexit

;если пробел вместо числа
mov ah,0   ;если символ с номером 0, т.е. null, или пустое место (не пробел!)
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test byte[esi],ah                ;проверяем на null, не 0! и не НОЛЬ!, обозначение символа в таблице ASCII в двоичном формате
;т.к. №NULL в таблице=0 или 000000000b, то ставим инвертированное (замененное) значение 11111111b
jz toend

mov dl,byte[esi]
mov byte[ebp],dl
mov byte[esi],dh
mov dh,dl

nextto:
inc esi
loop one
jmp toend

less:
jmp nextto

equal:
;надо доработать!чтоб не было одинаковых значений!
;при одинаковых значениях символ меняется на больший по размеру
;и соответственно сдвигается вправо!
;потом их можно отрезать и все, вместо того, чтобы циклом сдвигать все следующие значения!

mov byte[esi],'a'
jmp nextto

toend:
mov ecx,ebx
dec ebx
inc ebp
mov esi,ebp
loop two

toexit:

mov ecx, output
mov edx,loutput
call PRINT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;выбрать только цифры из output
;ecx - счетчик
mov ecx,loutput
;адрес первого символа для ввода
mov ebx,output

;адрес первого символа для вывода
mov edx,nodub


again1:
;ввод первого символа в регистр
mov al,byte[ebx]


mov ah,'0'        ;номер в регистре обычно обозначает номер символа в ASCII
                 ;он может быть в двоичной форме или десятичной, например 00111001b или 57
                 ;или же просто указать сам символ в ковычках, и он автоматически переведется в номер
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
;т.к. №0 в таблице=48 или 001100000b, то ставим инвертированное (замененное) значение 11001111b
jz match

mov ah,'1'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah               ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'2'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah               ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'3'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'4'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'5'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'6'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'7'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah               ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'8'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

mov ah,'9'
not ah   ;инвертирует значение, т.е. меняет 1 и 0 наоборот, т.е. на 0 и 1 соответственно
test al,ah                ;проверяем на 0, обозначение символа в таблице ASCII в двоичном формате
jz match

jnz nomatch
nomatch:
inc ebx
loop again1
jmp away

match:
mov byte[edx],al
inc ebx      ;увеличить номер ячейки памяти ввода
inc edx      ;увеличить номер ячейки памяти для вывода
loop again1
jmp away

away:
;переход на новую строку
mov ecx, n
mov edx, 1
call PRINT

mov ecx,nodub
mov edx,lnodub
call PRINT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                     ;здесь заканчивается вывод данных:

;переход на новую строку
mov ecx, n
mov edx, 1
call PRINT

mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
