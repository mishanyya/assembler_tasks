
;ввести в командной строке ./text forsearch.txt

;вывысти кол-во аргументов красным цветом+
;перейти на новую строку+
;вывысти слово forsearch.txt синим цветом+

;получить значение файла forsearch.txt в память


;перевернуть текст файла наоборот
;заменить текст файла на перевернутый
;создать тексты ошибок для всех операций
;выдавать сообщения об этих ошибках

SECTION .data        ;для инициализированных данных

invite1 db "Введите с клавиатуры адрес/имя файла forsearch.txt Ctrl+@",0xa,0
;символ NUL обозначается ^@ и вводится с помощью клавиш Ctrl+@
linvite1 equ $-invite1

match db "Найдено",0xa,0
lmatch equ $-match

nomatch db "Не найдено",0xa,0
lnomatch equ $-nomatch

filetoopen: db "forsearch.txt",0 ;ввод адреса
lfiletoopen equ $-filetoopen

n db 0xa                   ;переменная для переноса строки

redf db 27,"[31m",0xa,0 ;31 - красный цвет символов
lredf equ $-redf

bluef db 27,"[34m",0xa,0 ;34 - синий цвет символов
lbluef equ $-bluef

ef db 27,"[0m",0xa,0   ;0 - сбросить все настройки
lef equ $-ef


SECTION .bss         ;для НЕинициализированных данных
input: resb 100               ;что ищем
linput equ $-input

input2: resb 100               ;где ищем
linput2 equ $-input2

input3: resb 100               ;выделение памяти в 10 байт, где input3- адрес первого символа
linput3 equ $-input3             ;адрес с длиной сообщения

input4: resb 1               ;выделение памяти в 1 байт, где input4- адрес первого символа
linput4 equ $-input4             ;адрес с длиной сообщения



SECTION .text      ;начало кода самой программы
GLOBAL _start
      _start:


;первый элемент в стеке - количество введенных символов в ком.строке, включая имя,
;исполняемого файла, добавляем символ '0' для вывода этого числа на экран

;вывод кол-ва элементов из стека
mov ecx,redf       ;ввод адреса
mov edx,lredf      ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

pop rbx
add bl,'0'
mov [input],bl

mov ecx,input       ;ввод адреса
mov edx,linput      ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

mov ecx,bluef       ;ввод адреса
mov edx,lbluef      ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

pop rax         ;переход к следующему элементу стека, регистр rdi, но может быть и другой
                ;это здесь значения не имеет
mov ecx,100       ;счетчик
mov esi,input2  ;в esi адрес первого символа
pop rdi         ;адрес из стека

again:
;вывод первых 8 символов из стека

mov bpl,[rdi] ;содержимое по адресу из стека rbp
mov [esi],bpl
add esi,1
add rdi,1

cmp bpl,0   ;0 - NULL, конец строки, для символов лучше использовать регистр меньшего размера - bpl, а не rbp
je next

loop again

next:
mov ecx,input2       ;ввод адреса
mov edx,linput2      ;ввод количества символов
mov eax,4
mov ebx,1
int 80h


;отключить эффект
mov ecx,ef       ;ввод адреса
mov edx,lef      ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

;вывод переноса строки
 mov ecx,n   ;ввод полученного адреса памяти
 mov edx,1      ;ввод количества символов
 mov eax,4
 mov ebx,1
 int 80h

;ввод через командную строку на ассемблере, это то же, что и
;функция int main(int argc, char *argv[]); на языке C;
;например ввод в строке:  ./text 1 2  9
;выводит 4(кол-во элементов) и указатели/адрес для каждого элемента  .129(первый символ каждого элемента)

;Вывод: элемент длины от1 до 8 байт можно вывести используя адрес начала строки от byte[rsp] до qword[rsp],
;если кол-во символов аргумента командной строки больше этого кол-ва, то надо использовать
;для получения следующих символов увеличение адреса, например
;mov rsi,qword[rsp]       ;ввод адреса начальной ячейки/вершины стека в rsi
;mov rax,qword[rsi+4]       ;вывод qwertyS - т.е. символы следующего (второго) арнумента строки!

;Для вывода следующего аргумента надо использовать команду pop для вывода из следующей ячейки стека!










;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;- получить из стека командную строку (содержащую имя файла и
;параметры, переданные программе при запуске);
;- первый параметр вывести на экран красным цветом, второй —
;синим и с новой строки.
;- выполнить побайтный «переворот» содержимого файла, имя которого задано первым параметром командной строки; информацию записывать в этот же файл без промежуточных и дополнительных файлов, с использованием отображения файла на память;
;- каждая файловая операция контролируются на ошибку без анализа ее номера с выдачей на терминал своего сообщения, типа
;«Ошибка открытия файла», «Ошибка записи» и т.д.
;-; завершить программу.

;- открыть файл, прочитать его в буфер и найти в содержимом подстроку, используя строковые инструкции;-
mov eax,5             ;open
mov ebx,filetoopen    ;имя/адрес файла
mov ecx,0             ;0-read, 1-write, 2-read and write
int 80h

;возвращаемое значение — неотрицательное целое число, равное дескриптору файла.
;в случае ошибки возвращается значение -1.

mov edi,eax   ;filedes - дескриптор отображаемого файла, описатель файла
mov eax,192     ;90-возможно устаревший системный вызов, № системного вызова  192 работает, а 90 - нет
mov ebx,0     ;*address - указатель/адрес участка памяти процесса, в который отображается содержимое файла, обычно 0
mov ecx,50    ;length - длина отображаемого участка файла с начала или с символа offset (по умолчанию = 0)
mov edx,1     ;protect - защита файла, 0 - доступ запрещен, 1 - read, 2 - write, 4 - для исполнения кода
mov esi,2     ;flags - 1 или 2 передача изменений: да или нет
;mov edi,1     ;filedes - дескриптор отображаемого файла, описатель файла, 1 - для вывода данных
mov ebp,0     ;offset - от какого символа считать начало отображаемого текста
int 80h
;возвращает fffffffffffffff2 в rax

;вывод результата
 mov ecx,eax   ;ввод полученного адреса памяти от mmap
 mov edx,50      ;ввод количества символов
 mov eax,4
 mov ebx,1
 int 80h

 ;закрыть файл
 mov eax,6
 mov ebx,0    ;дескриптор
 int 0x80
;возвращаемое значение — 0; значение -1 возвращается в случае ошибки.

;- завершить программу.+


mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
