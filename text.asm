SECTION .data        ;для инициализированных данных

filetoopen db "exampledir",0
lfiletoopen equ $-filetoopen

n db 0xa                   ;переменная для переноса строки


text db "Вывести имена файлов: ",0xa,0;
ltext equ $-text



SECTION .bss         ;для НЕинициализированных данных

input: resb 1000               ;что ищем
linput equ $-input


desc: resd 1         ;filedes - дескриптор файла, resd = 4 байта
ldesc equ $-desc

amount: resd 1         ;amount - кол-во символов, resd = 4 байта
lamount equ $-amount

adress: resd 1         ;adress - адрес, resd = 4 байта
ladress equ $-adress

SECTION .text      ;начало кода самой программы
GLOBAL _start
      _start:

;открыть директорию и получить ее дескриптор
mov eax,5                 ;open
mov ebx,filetoopen       ;имя/адрес файла, этого параметра для открытия каталога достаточно!
;mov ecx,2               ;Для директории/каталога этот аргумент не указывать или закомментировать!
int 80h
mov [desc],eax

;Для получения списка файлов в таком универсальном формате существует
;системный вызов getdents с номером 141:
;int getdents(unsigned int fd, struct dirent *dirp,unsigned int count);

mov eax,141      ;141 - 4 элемента структуры или 220 - ;системный вызов getdents
mov ebx,[desc]   ;unsigned int fd - файловый дескриптор этой директории, полученный, системным вызовом open
mov ecx,input    ;struct dirent *dirp - адрес буфера в памяти, куда запишется информация о содержимом текущего каталога в виде следующих друг за другом структур
mov edx,linput   ;unsigned int count - размер буфера, в который должна быть записана информация
int 80h

;bp - 2-х байтный регистр для хранеия данных типа short int / для 64 байтной ОС

mov esi,input    ;адрес начала памяти
add esi,10       ;сдвинуть адрес на ячейки памяти с именем первого файла
                 ;8 байт - метаданные по файлу, тип long int
                 ;2 байта - смещениее следующей структуры = 0, тип off_t

;текст
mov ecx,text        ;ввод полученного адреса памяти
mov edx,ltext        ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

mov r8d,linput          ;присвоить регистру r8d значение счетчика

again:

cmp byte[esi],0
je next             ;если 0



mov edi,esi         ;адрес имени файла
sub edi,2           ;уменьшить адрес на 2
mov bp,word[edi]    ;получить 2-х байтное значение из памяти; т.к. short=2 байта
mov ecx,esi      ;ввод полученного адреса памяти
sub bp,10        ;высчитать из размера структуры все поля кроме имени
mov edx,ebp       ;ввод количества символов
add bp,10        ;вернуть размер регистра ebp
mov eax,4
mov ebx,1
int 80h

;на новую строку
mov ecx,n        ;ввод полученного адреса памяти
mov edx,1        ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

add esi,ebp       ;увеличить адрес до следующего имени файла


;если число символов всех имен файлов меньше, чем кол-во выделеной памяти linput, то не выводит ничего!!!
sub r8d,10
cmp r8d,0
jge again
jl next
next:

;;;;;;;;;;;;;;;;;;;;;;;; неизвестные файлы в каталоге!!!

 ;закрыть файл
 mov eax,6
 mov ebx,[desc]    ;filedes
 int 0x80
;возвращаемое значение — 0; значение -1 возвращается в случае ошибки.



;- завершить программу.+
exit:

mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
