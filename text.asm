SECTION .data        ;для инициализированных данных

filetoopen db "exampledir/",0  ;ОРИГИНАЛ

;filetoopen db "/home/mishanyya/for_assembler_programm/exampledir",0 ;директория exampledir
;filetoopen db "/home/mishanyya/for_assembler_programm",0  ;общая директория
lfiletoopen equ $-filetoopen

n db 0xa                   ;переменная для переноса строки


warning db "Показывает все имена файлов, но пишет Файл существует, если этот файл скопирован из главной папки и присутствует в главной папке, пишет Файл не существует, если файла нет в главной папке, и пишет Файл не существует, если он был создан в общей прапке, затем скопирован в каталог поиска, и затем удален в общей папке! Заняться этим позже! Отображает данные только из файлов общего каталога!",0xa,0;
lwarning equ $-warning

text db "Вывести имена файлов: ",0xa,0;
ltext equ $-text

er db "Файл существует!",0xa,0;
ler equ $-er

er1 db "Файл НЕ существует!",0xa,0;
ler1 equ $-er1




SECTION .bss         ;для НЕинициализированных данных

createnewfilaname: resb 100   ;память для создания новых имен файлов

nfcountinter: resb 1   ;память для счетчика символов


input: resb 1000               ;память для структур каталога
linput equ $-input

reserv: resb 1               ;промеж память
reserb: resb 4               ;промеж память
reserc: resb 4               ;промеж память


descofcat: resd 1         ;дескриптор каталога, resd = 4 байта

descoffile: resd 1         ;дескриптор файла, resd = 4 байта

filename: resd 1  ;адрес имени для каждого файла (не каталога!)

newfilename: resb 100 ;память для имени файла вместе с именем каталога exampledir

eaxvalue: resd 1  ;промеж. величина
ebxvalue: resd 1  ;промеж. величина
ecxvalue: resd 1  ;промеж. величина
edxvalue: resd 1  ;промеж. величина
esivalue: resd 1  ;промеж. величина
edivalue: resd 1  ;промеж. величина
ebpvalue: resd 1  ;промеж. величина

amount: resd 1         ;amount - кол-во символов в файле, resd = 4 байта

adress: resd 1         ;adress - адрес,куда отражаются данные resd = 4 байта


adress1: resd 1         ;adress1 - адрес, resd = 4 байта
ladress1 equ $-adress1

SECTION .text      ;начало кода самой программы
GLOBAL _start
            ;прописать подпрограммы

;Result:      ;начало подпрограммы
;ret          ;конец подпрограммы


                       ;начало исполнения
      _start:

;вывод текста
mov ecx,warning        ;ввод полученного адреса памяти
mov edx,lwarning        ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

;текст
mov ecx,text        ;ввод полученного адреса памяти
mov edx,ltext        ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

xor eax,eax ;обнуление eax
xor ebx,ebx ;обнуление ebx
xor ecx,ecx ;обнуление ecx
xor edx,edx ;обнуление edx



;открыть директорию и получить ее дескриптор
mov eax,5                 ;open
mov ebx,filetoopen       ;имя/адрес файла, этого параметра для открытия каталога достаточно!
;mov ecx,2               ;Для директории/каталога этот аргумент не указывать или закомментировать!
int 80h
mov [descofcat],eax

;Для получения списка файлов в таком универсальном формате существует
;системный вызов getdents с номером 141:
;int getdents(unsigned int fd, struct dirent *dirp,unsigned int count);
;возвращает несколько структур в память input размером linput

mov eax,141      ;141 - 4 элемента структуры или 220 - ;системный вызов getdents
mov ebx,[descofcat]   ;unsigned int fd - файловый дескриптор этой директории, полученный, системным вызовом open
mov ecx,input    ;struct dirent *dirp - адрес буфера в памяти, куда запишется информация о содержимом
                 ;текущего каталога в виде следующих друг за другом структур
mov edx,linput   ;unsigned int count - размер буфера, в который должна быть записана информация
int 80h

mov esi,input    ;адрес начала памяти
add esi,10       ;сдвинуть адрес на ячейки памяти с именем первого файла
                 ;8 байт - метаданные по файлу, тип long int
                 ;2 байта - смещение следующей структуры = 0, тип off_t
                 ;в esi помещается адрес именно имени файла из каждой структуры

mov r8d,linput          ;присвоить регистру r8d значение счетчика, в соответствии
                        ;с объемом памяти (в байтах) всех символов для всех структур

                        ;esi - адрес начала памяти всех структур, начало с имени файла
                        ;r8d - счетчик (кол-во байтов выделенной памяти под все структуры)
                        ;bp - 2-х байтный регистр для хранеия данных типа short int / для 64 байтной ОС


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;вывод имен файлов из структур в цикле AGAIN побайтово!!!


again:
cmp byte[esi],0     ;сравнение символов структур с 0
je next             ;если 0, т.е. символы имени кончились и вышел 0-символ, то идем на выход из цикла AGAIN


;вывод имени каждого файла


mov edi,esi         ;адрес имени файла
sub edi,2           ;уменьшить адрес на 2

mov [filename],esi  ;адрес с началом именем каждого файла

mov bp,word[edi]    ;получить 2-х байтное значение из памяти - расстояние до следующего изменений
                    ;т.к. short=2 байта
mov ecx,esi      ;ввод полученного адреса памяти с именем файла
sub bp,10        ;высчитать из размера структуры все поля кроме имени
mov edx,ebp       ;ввод количества символов имени файла
add bp,10        ;вернуть размер регистра ebp

mov [edxvalue],edx
mov [esivalue],esi
mov [ebpvalue],ebp

;mov [eaxvalue],eax
;mov [ebxvalue],ebx
;mov [ecxvalue],ecx

;mov [edivalue],edi


mov r10d,ebp ;сохраняем число из ebp
mov eax,4
mov ebx,1
int 80h

;на новую строку
mov ecx,n        ;ввод полученного адреса памяти
mov edx,1        ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;ОТКРЫТИЕ, ОТОБРАЖЕНИЕ СТАРОГО ФАЙЛА В ПАМЯТЬ И ПОКАЗ СОДЕРЖИМОГО ИЗ ПАМЯТИ, В которую
;;;;;;выводятся данные


;newfilename = exampledir + [filename]
;соединить имя файла с именем каталога exampledir
;можно использовать eax,ebx и ecx
;[filename] - адрес имени файла, его надо добавить к имени каталога

mov eax,filetoopen    ;адрес каталога
mov ebx,newfilename   ;адрес для полного нового имени
mov ch,0               ;счетчик символов в новой строке

step:
mov cl,byte[eax]
mov byte[ebx],cl
inc eax
inc ebx
inc ch
cmp cl,0 ;поиск 0-символа конца слова
jne step ;если не найдено, то берем следующий символ
         ;если найден, то присоединяем имя из filename

;;;;;;;

;dec ebx
mov eax,[filename]    ;адрес просто имени файла - без каталога

                     ;edx - кол-во символов в имени
;mov ebx,[filename]  ;адрес для полного нового имени


step1:
mov cl,byte[eax]
mov byte[ebx],cl
inc eax
inc ebx
inc ch ;счетчик символов
cmp cl,0 ;поиск 0-символа
jne step1

;;;;;;;;;

mov [ecxvalue],ecx



movzx eax,ch
mov edx,eax      ;ввод количества символов
mov ecx,newfilename         ;ввод полученного адреса памяти
mov eax,4
mov ebx,1
int 80h

 ;на новую строку
 mov ecx,n        ;ввод полученного адреса памяти
 mov edx,1        ;ввод количества символов
 mov eax,4
 mov ebx,1
 int 80h

mov ecx,[ecxvalue]







mov eax,5                 ;open
mov ebx,[filename]       ;имя/адрес файла
mov ecx,2                 ;0-read, 1-write, 2-read and write,100-create
int 80h

mov [descoffile],eax  ;filedes
;возвращаемое значение — неотрицательное целое число, равное дескриптору файла.
;в случае ошибки возвращается значение -1.

;кол-во символов в файле
mov eax,19       ;системный номер функции
mov ebx,[descoffile]   ;filedes
mov ecx,0        ;offset
mov edx,2        ;whence
int 80h

mov [amount],eax  ;length - длина отображаемого участка файла с начала или с символа offset (по умолчанию = 0)

mov eax,192     ;90-возможно устаревший системный вызов, № системного вызова  192 работает, а 90 - нет
mov ebx,0     ;*address - указатель/адрес участка памяти процесса, в который отображается содержимое файла, обычно 0
mov ecx,[amount]    ;length - длина отображаемого участка файла с начала или с символа offset (по умолчанию = 0)
mov edx,1|2     ;protect - защита файла, 0 - доступ запрещен, 1 - read, 2 - write, 4 - для исполнения кода
mov esi,1     ;flags - 1 или 2 передача изменений: да или нет
mov edi,[descoffile]   ;filedes - дескриптор отображаемого файла,
mov ebp,0     ;offset - от какого символа считать начало отображаемого текста
int 80h
;возвращает fffffffffffffff2 в rax
mov [adress],eax ;адрес вывода


;вывод результата
 mov ecx,[adress]   ;ввод полученного адреса памяти от mmap
 mov edx,[amount]      ;ввод количества символов
 mov eax,4
 mov ebx,1
 int 80h


 mov esi,[esivalue]
 mov ebp,[ebpvalue]
 ;mov eax,[eaxvalue]
 ;mov ebx,[ebxvalue]
 ;mov ecx,[ecxvalue]
 ;mov edx,[edxvalue]

 ;mov edi,[edivalue]






















;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



































;получить адрес и кол-во символов старого имени для дальнейшей обработки
mov ecx,esi        ;ввод полученного адреса памяти
sub bp,10        ;высчитать из размера структуры все поля кроме имени
mov edx,ebp       ;ввод количества символов имени файла
add bp,10        ;вернуть размер регистра ebp





;в ecx содержится адрес выводимого имени
;в createnewfilaname содержится адрес нового выводимого имени
;поместить кол-во символов в ячейку памяти по адресу nfcountinter
mov [nfcountinter],edx

;eax, ebx и edx можно использовать для подсчета

mov al,byte [nfcountinter] ;кол-во символов
;ah - хранение символов

mov ebx,createnewfilaname ;поместить в ebx адрес первого символа памяти


;КАК добавить символ ~ №126
;dec al  ;уменьшить счетчик на 1, чтобы не считать последний символ 0 из старого имени

sub:

mov ah,byte[ecx]
mov byte[ebx],ah

cmp ah,0
je isnull

mov dword[reserb],ebx
mov dword[reserc],ecx
mov byte[reserv],al

mov al,byte[reserv]
mov ebx,dword[reserb]
mov ecx,dword[reserc]

inc ecx
inc ebx
dec al
cmp al,0
jg sub

isnull:
;почему то последний символ в имя не добавляется((
mov byte[ebx],126    ;добавить требуемый символ ~
inc ebx              ;увеличить ячейку памяти на 1
mov byte[ebx],0      ;добавить нуль-символ в конце строки




;создаются файлы, но без расширения! Надо попробовать изменить имя, т.е. другие символы
;создание файла с добавленным знаком ~
mov eax,8                 ;create
mov ebx,createnewfilaname       ;адрес имени файла
mov ecx, 0777               ;0777 - permission - полный доступ
int 80h

;Что-то там создало, но знака ~ не видать. проверить весь код, может что-то где=то создается непонятно

;временно убираем вывод нового имени
;новое имя из памяти
mov ecx,createnewfilaname        ;ввод полученного адреса памяти
mov edx,[nfcountinter]        ;ввод количества символов
mov eax,4
mov ebx,1
int 80h



;Для открытия существующего файла или создания нового используют функцию open (системный вызов номер 5). В
;синтаксисе Си она выглядит следующим образом:
;int open (const char *filename, int flags[, mode_t mode])
;Функция open создает и возвращает новый дескриптор для указанного файла. Индикатор текущей позиции
 ;при этом находится в начале файла. Функция может иметь переменный набор аргументов;
; аргумент mode используется только при создании файла и задает права доступа к нему
  ;(в стандартном для UNIX-систем числовом виде, например восьмеричным числом из трех цифр).

;на новую строку
mov ecx,n        ;ввод полученного адреса памяти
mov edx,1        ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

;открыть и прочитать каждый файл
mov eax,5                 ;open
mov ebx,esi        ;адрес имени файла
mov r9d,esi        ;сохраняем адрес из esi
mov ecx,2                 ;0-read, 1-write, 2-read and write,100-create
int 80h

;получить дескриптор каждого файла
;mov [desc1],eax  ;filedes
;возвращаемое значение — неотрицательное целое число, равное дескриптору файла.
;в случае ошибки возвращается значение -1.



;;;;;;;;;;;;проверка файла на ошибку ENOENT
;ошибки open
;enoent -2
;enotdir -20
;
cmp eax,-2d
jne ok
je neok
ok:
;файл существует
mov ecx,er        ;ввод полученного адреса памяти
mov edx,ler        ;ввод количества символов
mov eax,4
mov ebx,1
int 80h
jmp further
neok:
;файл не существует
mov ecx,er1        ;ввод полученного адреса памяти
mov edx,ler1        ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

jmp nofurther

further:




nofurther:
;типа конец подпрограммы

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Увеличиваем адрес до получения следующего имени файла
mov esi,r9d ;возвращаем адрес в esi
mov ebp,r10d ;возвращаем число в ebp

add esi,ebp       ;увеличить адрес до следующего имени файла
;если число символов всех имен файлов меньше, чем кол-во выделеной памяти linput, то не выводит ничего!!!
;sub r8d,10 - это исходное значение
sub r8d,ebp  ; - это исправляем значение счетчика всех символов




;FINISH вывода имен файлов из структур в цикле AGAIN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


cmp r8d,0
jg again
jle next
next:

;закрыть файл каталога
mov eax,6
mov ebx,[descofcat]    ;filedes
int 0x80
;возвращаемое значение — 0; значение -1 возвращается в случае ошибки.


;- завершить программу.+
exit:

mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
