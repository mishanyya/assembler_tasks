;ввести в командной строке ./text forsearch.txt

;вывысти кол-во аргументов красным цветом+
;перейти на новую строку+
;вывысти слово forsearch.txt синим цветом+
;посчитать кол-во символов в файле+
;получить значение файла forsearch.txt в память+
;перевернуть текст файла наоборот+

;заменить текст файла на перевернутый

;создать тексты ошибок для всех операций
;выдавать сообщения об этих ошибках

SECTION .data        ;для инициализированных данных

invite1 db "Введите с клавиатуры адрес/имя файла forsearch.txt Ctrl+@",0xa,0
;символ NUL обозначается ^@ и вводится с помощью клавиш Ctrl+@
linvite1 equ $-invite1

match db "Найдено",0xa,0
lmatch equ $-match

nomatch db "Не найдено",0xa,0
lnomatch equ $-nomatch

filetoopen: db "forsearch.txt",0 ;ввод адреса
lfiletoopen equ $-filetoopen

n db 0xa                   ;переменная для переноса строки

redf db 27,"[31m",0xa,0 ;31 - красный цвет символов
lredf equ $-redf

bluef db 27,"[34m",0xa,0 ;34 - синий цвет символов
lbluef equ $-bluef

ef db 27,"[0m",0xa,0   ;0 - сбросить все настройки
lef equ $-ef


SECTION .bss         ;для НЕинициализированных данных
input: resb 100               ;что ищем
linput equ $-input

input2: resb 100               ;где ищем
linput2 equ $-input2

input3: resb 100               ;выделение памяти в 100 байт, где input3- адрес первого символа
linput3 equ $-input3             ;адрес с длиной сообщения

input4: resb 100               ;выделение памяти в 1 байт, где input4- адрес первого символа
linput4 equ $-input4             ;адрес с длиной сообщения

desc: resd 1         ;filedes - дескриптор файла, resd = 4 байта
ldesc equ $-desc

amount: resd 1         ;amount - кол-во символов, resd = 4 байта
lamount equ $-amount

adress: resd 1         ;adress - адрес, resd = 4 байта
ladress equ $-adress

SECTION .text      ;начало кода самой программы
GLOBAL _start
      _start:

;первый элемент в стеке - количество введенных символов в ком.строке, включая имя,
;исполняемого файла, добавляем символ '0' для вывода этого числа на экран

;вывод кол-ва элементов из стека
mov ecx,redf       ;ввод адреса
mov edx,lredf      ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

pop rbx
add bl,'0'
mov [input],bl

mov ecx,input       ;ввод адреса
mov edx,linput      ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

mov ecx,bluef       ;ввод адреса
mov edx,lbluef      ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

pop rax         ;переход к следующему элементу стека, регистр rdi, но может быть и другой
                ;это здесь значения не имеет
mov ecx,100       ;счетчик
mov esi,input2  ;в esi адрес первого символа
pop rdi         ;адрес из стека

again:
;вывод первых 8 символов из стека

mov bpl,[rdi] ;содержимое по адресу из стека rbp
mov [esi],bpl
add esi,1
add rdi,1

cmp bpl,0   ;0 - NULL, конец строки, для символов лучше использовать регистр меньшего размера - bpl, а не rbp
je next

loop again

next:
mov ecx,input2       ;ввод адреса
mov edx,linput2      ;ввод количества символов
mov eax,4
mov ebx,1
int 80h


;отключить эффект
mov ecx,ef       ;ввод адреса
mov edx,lef      ;ввод количества символов
mov eax,4
mov ebx,1
int 80h

;вывод переноса строки
 mov ecx,n   ;ввод полученного адреса памяти
 mov edx,1      ;ввод количества символов
 mov eax,4
 mov ebx,1
 int 80h

;ввод через командную строку на ассемблере, это то же, что и
;функция int main(int argc, char *argv[]); на языке C;
;например ввод в строке:  ./text 1 2  9
;выводит 4(кол-во элементов) и указатели/адрес для каждого элемента  .129(первый символ каждого элемента)

;Вывод: элемент длины от1 до 8 байт можно вывести используя адрес начала строки от byte[rsp] до qword[rsp],
;если кол-во символов аргумента командной строки больше этого кол-ва, то надо использовать
;для получения следующих символов увеличение адреса, например
;mov rsi,qword[rsp]       ;ввод адреса начальной ячейки/вершины стека в rsi
;mov rax,qword[rsi+4]       ;вывод qwertyS - т.е. символы следующего (второго) арнумента строки!

;Для вывода следующего аргумента надо использовать команду pop для вывода из следующей ячейки стека!

;- получить из стека командную строку (содержащую имя файла и
;параметры, переданные программе при запуске);
;- первый параметр вывести на экран красным цветом, второй —
;синим и с новой строки.
;- выполнить побайтный «переворот» содержимого файла, имя которого задано первым параметром командной строки; информацию записывать в этот же файл без промежуточных и дополнительных файлов, с использованием отображения файла на память;
;- каждая файловая операция контролируются на ошибку без анализа ее номера с выдачей на терминал своего сообщения, типа
;«Ошибка открытия файла», «Ошибка записи» и т.д.
;-; завершить программу.

mov eax,5                 ;open
mov ebx,filetoopen        ;имя/адрес файла
mov ecx,0                 ;0-read, 1-write, 2-read and write
int 80h

;возвращаемое значение — неотрицательное целое число, равное дескриптору файла.
;в случае ошибки возвращается значение -1.

mov [desc],eax  ;filedes

;кол-во символов в файле
mov eax,19       ;системный номер функции
mov ebx,[desc]      ;filedes
mov ecx,0        ;offset
mov edx,2        ;whence
int 80h

mov [amount],eax  ;length - длина отображаемого участка файла с начала или с символа offset (по умолчанию = 0)


mov eax,192     ;90-возможно устаревший системный вызов, № системного вызова  192 работает, а 90 - нет
mov ebx,0     ;*address - указатель/адрес участка памяти процесса, в который отображается содержимое файла, обычно 0
mov ecx,[amount]    ;length - длина отображаемого участка файла с начала или с символа offset (по умолчанию = 0)
mov edx,1     ;protect - защита файла, 0 - доступ запрещен, 1 - read, 2 - write, 4 - для исполнения кода
mov esi,2     ;flags - 1 или 2 передача изменений: да или нет
mov edi,[desc]   ;filedes - дескриптор отображаемого файла,
mov ebp,0     ;offset - от какого символа считать начало отображаемого текста
int 80h
;возвращает fffffffffffffff2 в rax

mov [adress],eax ;адрес вывода

;вывод результата
 mov ecx,[adress]   ;ввод полученного адреса памяти от mmap
 mov edx,[amount]      ;ввод количества символов
 mov eax,4
 mov ebx,1
 int 80h

mov esi,input3        ;адрес для вывода
mov ecx,[amount]       ;счетчик
mov edi,[adress]        ;адрес имеющейся строки
add edi,[amount]     ;получить номер ячейки памяти последнего символа
dec edi

again1:
mov al,byte[edi]
mov byte[esi],al
dec edi
inc esi
loop again1

;вывод результата
 mov ecx,input3   ;ввод адреса памяти
 mov edx,[amount]      ;ввод количества символов
 mov eax,4
 mov ebx,1
 int 80h





 ;закрыть файл
 mov eax,6
 mov ebx,[desc]    ;filedes
 int 0x80
;возвращаемое значение — 0; значение -1 возвращается в случае ошибки.

;- завершить программу.+


mov eax, 1          ;содержимое помещается в регистр в EAX помещается 1 - номер системного вызова "exit"
mov ebx, 0          ;содержимое помещается в регистр в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы
int 0x80            ;системный вызов. После системного вызова "exit" выполнение программы завершается
